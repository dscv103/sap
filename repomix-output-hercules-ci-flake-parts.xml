This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
dev/
  tests/
    eval-tests.nix
    README.md
    template.nix
  flake-module.nix
  flake.lock
  flake.nix
examples/
  project-commands/
    flake.lock
    flake.nix
    Hello.avdl
    README.md
  shell-environments/
    flake.lock
    flake.nix
    README.md
extras/
  bundlers.nix
  easyOverlay.nix
  flakeModules.nix
  modules.nix
  partitions.nix
lib/
  memoize/
    measure-bytes-per-char.nix
    memoize.nix
    test.nix
modules/
  apps.nix
  checks.nix
  debug.nix
  devShells.nix
  flake.nix
  formatter.nix
  legacyPackages.nix
  moduleWithSystem.nix
  nixosConfigurations.nix
  nixosModules.nix
  nixpkgs.nix
  overlays.nix
  packages.nix
  perSystem.nix
  transposition.nix
  withSystem.nix
template/
  default/
    flake.nix
  multi-module/
    hello/
      flake-module.nix
    flake.nix
  package/
    hello/
      hello.sh
      package.nix
      test.nix
    flake.nix
  unfree/
    flake.nix
.gitignore
all-modules.nix
bors.toml
ChangeLog.md
CONTRIBUTING.md
flake.lock
flake.nix
lib.nix
LICENSE
README.md
shell.nix
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="dev/tests/eval-tests.nix">
# Run with
#
#     nix build .#checks.x86_64-linux.eval-tests

{ flake-parts }:
rec {
  nixpkgs = flake-parts.inputs.nixpkgs;
  f-p-lib = flake-parts.lib;
  inherit (f-p-lib) mkFlake;
  inherit (flake-parts.inputs.nixpkgs-lib) lib;

  pkg = system: name:
    derivation
      {
        name = name;
        builder = "no-builder";
        system = system;
      }
    // {
      meta = {
        mainProgram = name;
      };
    };

  empty = mkFlake
    { inputs.self = { }; }
    {
      systems = [ ];
    };

  emptyExposeArgs = mkFlake
    { inputs.self = { outPath = "the self outpath"; }; }
    ({ config, moduleLocation, ... }: {
      flake = {
        inherit moduleLocation;
      };
    });

  emptyExposeArgsNoSelf = mkFlake
    { inputs.self = throw "self won't be available in case of some errors"; }
    ({ config, moduleLocation, ... }: {
      flake = {
        inherit moduleLocation;
      };
    });

  example1 = mkFlake
    { inputs.self = { }; }
    {
      systems = [ "a" "b" ];
      perSystem = { config, system, ... }: {
        packages.hello = pkg system "hello";
        apps.hello.program = config.packages.hello;
      };
    };

  packagesNonStrictInDevShells = mkFlake
    { inputs.self = packagesNonStrictInDevShells; /* approximation */ }
    {
      systems = [ "a" "b" ];
      perSystem = { system, self', ... }: {
        packages.hello = pkg system "hello";
        packages.default = self'.packages.hello;
        devShells = throw "can't be strict in perSystem.devShells!";
      };
      flake.devShells = throw "can't be strict in devShells!";
    };

  easyOverlay = mkFlake
    { inputs.self = { }; }
    {
      imports = [ flake-parts.flakeModules.easyOverlay ];
      systems = [ "a" "aarch64-linux" ];
      perSystem = { system, config, final, pkgs, ... }: {
        packages.default = config.packages.hello;
        packages.hello = pkg system "hello";
        packages.hello_new = final.hello;
        overlayAttrs = {
          hello = config.packages.hello;
          hello_old = pkgs.hello;
          hello_new = config.packages.hello_new;
        };
      };
    };

  bundlersExample = mkFlake
    { inputs.self = { }; }
    {
      imports = [ flake-parts.flakeModules.bundlers ];
      systems = [ "a" "b" ];
      perSystem = { system, ... }: {
        packages.hello = pkg system "hello";
        bundlers.toTarball = drv: pkg system "tarball-${drv.name}";
        bundlers.toAppImage = drv: pkg system "appimage-${drv.name}";
      };
    };

  modulesFlake = mkFlake
    {
      inputs.self = { };
      moduleLocation = "modulesFlake";
    }
    {
      imports = [ flake-parts.flakeModules.modules ];
      systems = [ ];
      flake = {
        modules.generic.example = { lib, ... }: {
          options.generic.example = lib.mkOption { default = "works in any module system application"; };
        };
        modules.foo.example = { lib, ... }: {
          options.foo.example = lib.mkOption { default = "works in foo application"; };
        };
      };
    };

  flakeModulesDeclare = mkFlake
    { inputs.self = { outPath = ./.; }; }
    ({ config, ... }: {
      imports = [ flake-parts.flakeModules.flakeModules ];
      systems = [ ];
      flake.flakeModules.default = { lib, ... }: {
        options.flake.test123 = lib.mkOption { default = "option123"; };
        imports = [ config.flake.flakeModules.extra ];
      };
      flake.flakeModules.extra = {
        flake.test123 = "123test";
      };
    });

  flakeModulesImport = mkFlake
    { inputs.self = { }; }
    {
      imports = [ flakeModulesDeclare.flakeModules.default ];
    };

  flakeModulesDisable = mkFlake
    { inputs.self = { }; }
    {
      imports = [ flakeModulesDeclare.flakeModules.default ];
      disabledModules = [ flakeModulesDeclare.flakeModules.extra ];
    };

  nixpkgsWithoutEasyOverlay = import nixpkgs {
    system = "x86_64-linux";
    overlays = [ ];
    config = { };
  };

  nixpkgsWithEasyOverlay = import nixpkgs {
    # non-memoized
    system = "x86_64-linux";
    overlays = [ easyOverlay.overlays.default ];
    config = { };
  };

  nixpkgsWithEasyOverlayMemoized = import nixpkgs {
    # memoized
    system = "aarch64-linux";
    overlays = [ easyOverlay.overlays.default ];
    config = { };
  };

  specialArgFlake = mkFlake
    {
      inputs.self = { };
      specialArgs.soSpecial = true;
    }
    ({ soSpecial, ... }: {
      imports = assert soSpecial; [ ];
      flake.foo = true;
    });

  partitionWithoutExtraInputsFlake = mkFlake
    {
      inputs.self = { };
    }
    ({ config, ... }: {
      imports = [ flake-parts.flakeModules.partitions ];
      systems = [ "x86_64-linux" ];
      partitions.dev.module = { inputs, ... }: builtins.seq inputs { };
      partitionedAttrs.devShells = "dev";
    });

  /**
    This one is for manual testing. Should look like:

    ```
    nix-repl> checks.x86_64-linux.eval-tests.internals.printSystem.withSystem "foo" ({ config, ... }: null)
    trace: Evaluating perSystem for foo
    null

    nix-repl> checks.x86_64-linux.eval-tests.internals.printSystem.withSystem "foo" ({ config, ... }: null)
    null

    ```
  */
  printSystem = mkFlake
    { inputs.self = { }; }
    ({ withSystem, ... }: {
      systems = [ ];
      perSystem = { config, system, ... }:
        builtins.trace "Evaluating perSystem for ${system}" { };
      flake.withSystem = withSystem;
    });

  dogfoodProvider = mkFlake
    { inputs.self = { }; }
    ({ flake-parts-lib, ... }: {
      imports = [
        (flake-parts-lib.importAndPublish "dogfood" { flake.marker = "dogfood"; })
      ];
    });

  dogfoodConsumer = mkFlake
    { inputs.self = { }; }
    ({ flake-parts-lib, ... }: {
      imports = [
        dogfoodProvider.modules.flake.dogfood
      ];
    });

  runTests = ok:

    assert empty == {
      apps = { };
      checks = { };
      devShells = { };
      formatter = { };
      legacyPackages = { };
      nixosConfigurations = { };
      nixosModules = { };
      overlays = { };
      packages = { };
    };

    assert example1 == {
      apps = {
        a = {
          hello = {
            program = "${pkg "a" "hello"}/bin/hello";
            type = "app";
            meta = { };
          };
        };
        b = {
          hello = {
            program = "${pkg "b" "hello"}/bin/hello";
            type = "app";
            meta = { };
          };
        };
      };
      checks = { a = { }; b = { }; };
      devShells = { a = { }; b = { }; };
      formatter = { };
      legacyPackages = { a = { }; b = { }; };
      nixosConfigurations = { };
      nixosModules = { };
      overlays = { };
      packages = {
        a = { hello = pkg "a" "hello"; };
        b = { hello = pkg "b" "hello"; };
      };
    };

    assert bundlersExample.bundlers.a.toTarball (pkg "a" "hello") == pkg "a" "tarball-hello";
    assert bundlersExample.bundlers.b.toAppImage (pkg "b" "hello") == pkg "b" "appimage-hello";

    # - exported package becomes part of overlay.
    # - perSystem is invoked for the right system, when system is non-memoized
    assert nixpkgsWithEasyOverlay.hello == pkg "x86_64-linux" "hello";

    # - perSystem is invoked for the right system, when system is memoized
    assert nixpkgsWithEasyOverlayMemoized.hello == pkg "aarch64-linux" "hello";

    # - Non-exported package does not become part of overlay.
    assert nixpkgsWithEasyOverlay.default or null != pkg "x86_64-linux" "hello";

    # - hello_old comes from super
    assert nixpkgsWithEasyOverlay.hello_old == nixpkgsWithoutEasyOverlay.hello;

    # - `hello_new` shows that the `final` wiring works
    assert nixpkgsWithEasyOverlay.hello_new == nixpkgsWithEasyOverlay.hello;

    assert flakeModulesImport.test123 == "123test";

    assert flakeModulesDisable.test123 == "option123";

    assert packagesNonStrictInDevShells.packages.a.default == pkg "a" "hello";

    assert emptyExposeArgs.moduleLocation == "the self outpath/flake.nix";

    assert (lib.evalModules {
      class = "barrr";
      modules = [
        modulesFlake.modules.generic.example
      ];
    }).config.generic.example == "works in any module system application";

    assert (lib.evalModules {
      class = "foo";
      modules = [
        modulesFlake.modules.foo.example
      ];
    }).config.foo.example == "works in foo application";

    assert specialArgFlake.foo;

    assert builtins.isAttrs partitionWithoutExtraInputsFlake.devShells.x86_64-linux;

    assert dogfoodProvider.marker == "dogfood";
    assert dogfoodConsumer.marker == "dogfood";

    ok;

  result = runTests "ok";
}
</file>

<file path="dev/tests/README.md">
# Running the tests

These tests can be run locally with the `hci effect run` command. This gives
the tests access to a proper nix daemon and the network.

Designed for convenient deployments, it needs some information from git. You
may use `--no-token` to disable this functionality if you're getting errors, or
if you're asked to log in.

Example:

```console
hci effect run --no-token default.effects.tests.template
```
</file>

<file path="dev/tests/template.nix">
{ hci-effects, nix, git, path }:

hci-effects.mkEffect {
  inputs = [ nix git ];
  effectScript = ''
    ann() { # announce
      printf '\n\e[34;1m%s\e[0m\n' "$*"
    }
    mkdir -p ~/.config/nix
    echo 'experimental-features = nix-command flakes' >>~/.config/nix/nix.conf
    mkdir clean
    cd clean

    ann nix flake init...
    nix -v flake init -t ${../..}

    ann pointing to local sources...

    override=(--override-input flake-parts ${../..})

    ann nix flake lock...
    nix flake lock "''${override[@]}"

    ann nix flake show...
    nix -v flake show "''${override[@]}"

    ann nix build...
    nix build . "''${override[@]}"

    ann checking result...
    readlink ./result | grep hello

    echo
    printf '\n\e[32;1m%s\e[0m\n' 'All good!'
  '';
}
</file>

<file path="dev/flake-module.nix">
{ config, lib, inputs, self, withSystem, ... }:

{
  imports = [
    inputs.pre-commit-hooks-nix.flakeModule
    inputs.hercules-ci-effects.flakeModule # herculesCI attr
  ];
  systems = [ "x86_64-linux" "aarch64-darwin" ];

  hercules-ci.flake-update = {
    enable = true;
    autoMergeMethod = "merge";
    when.dayOfMonth = 1;
    flakes = {
      "." = { };
      "dev" = { };
    };
  };

  perSystem = { config, pkgs, ... }: {

    devShells.default = pkgs.mkShell {
      nativeBuildInputs = [
        pkgs.nixpkgs-fmt
        pkgs.pre-commit
        pkgs.hci
      ];
      shellHook = ''
        ${config.pre-commit.installationScript}
      '';
    };

    pre-commit = {
      inherit pkgs; # should make this default to the one it can get via follows
      settings = {
        hooks.nixpkgs-fmt.enable = true;
      };
    };

    checks.eval-tests =
      let tests = import ./tests/eval-tests.nix { flake-parts = self; };
      in tests.runTests pkgs.emptyFile // { internals = tests; };

  };
  flake = {
    # for repl exploration / debug
    config.config = config;
    options.mySystem = lib.mkOption { default = config.allSystems.${builtins.currentSystem}; };
    config.effects = withSystem "x86_64-linux" ({ pkgs, hci-effects, ... }: {
      tests = {
        template = pkgs.callPackage ./tests/template.nix { inherit hci-effects; };
      };
    });
  };
}
</file>

<file path="dev/flake.lock">
{
  "nodes": {
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1747046372,
        "narHash": "sha256-CIVLLkVgvHYbgI2UpXvIIBJ12HWgX+fjA8Xf8PUmqCY=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "9100a0f413b0c601e0533d1d94ffd501ce2e7885",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-parts": {
      "inputs": {
        "nixpkgs-lib": [
          "hercules-ci-effects",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1754487366,
        "narHash": "sha256-pHYj8gUBapuUzKV/kN/tR3Zvqc7o6gdFB9XKXIp1SQ8=",
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "rev": "af66ad14b28a127c5c0f3bbb298218fc63528a18",
        "type": "github"
      },
      "original": {
        "id": "flake-parts",
        "type": "indirect"
      }
    },
    "gitignore": {
      "inputs": {
        "nixpkgs": [
          "pre-commit-hooks-nix",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1709087332,
        "narHash": "sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=",
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "rev": "637db329424fd7e46cf4185293b9cc8c88c95394",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "type": "github"
      }
    },
    "hercules-ci-effects": {
      "inputs": {
        "flake-parts": "flake-parts",
        "nixpkgs": "nixpkgs"
      },
      "locked": {
        "lastModified": 1755233722,
        "narHash": "sha256-AavrbMltJKcC2Fx0lfJoZfmy7g87ebXU0ddVenhajLA=",
        "owner": "hercules-ci",
        "repo": "hercules-ci-effects",
        "rev": "99e03e72e3f7e13506f80ef9ebaedccb929d84d0",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "hercules-ci-effects",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1755027561,
        "narHash": "sha256-IVft239Bc8p8Dtvf7UAACMG5P3ZV+3/aO28gXpGtMXI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "005433b926e16227259a1843015b5b2b7f7d1fc3",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1756768872,
        "narHash": "sha256-sqCV23o4NP0xfpuTOSSOTJb5lObq4mOgCCS06b5OzrI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "27fb23f48dbaa28c3965ff2e8ef766c7ab897888",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "pre-commit-hooks-nix": {
      "inputs": {
        "flake-compat": "flake-compat",
        "gitignore": "gitignore",
        "nixpkgs": [
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1755960406,
        "narHash": "sha256-RF7j6C1TmSTK9tYWO6CdEMtg6XZaUKcvZwOCD2SICZs=",
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "rev": "e891a93b193fcaf2fc8012d890dc7f0befe86ec2",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "hercules-ci-effects": "hercules-ci-effects",
        "nixpkgs": "nixpkgs_2",
        "pre-commit-hooks-nix": "pre-commit-hooks-nix"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="dev/flake.nix">
{
  description = "Dependencies for development purposes";

  inputs = {
    # Flakes don't give us a good way to depend on .., so we don't.
    # As a consequence, this flake only provides dependencies, and
    # we can't use the `nix` CLI as expected.

    nixpkgs.url = "github:NixOS/nixpkgs";
    pre-commit-hooks-nix.url = "github:cachix/pre-commit-hooks.nix";
    pre-commit-hooks-nix.inputs.nixpkgs.follows = "nixpkgs";
    hercules-ci-effects.url = "github:hercules-ci/hercules-ci-effects";
  };

  outputs = { ... }:
    {
      # The dev tooling is in ./flake-module.nix
      # See comment at `inputs` above.
      # It is loaded into partitions.dev by the root flake.
    };
}
</file>

<file path="examples/project-commands/flake.lock">
{
  "nodes": {
    "flake-parts": {
      "inputs": {
        "nixpkgs-lib": "nixpkgs-lib"
      },
      "locked": {
        "lastModified": 1685662779,
        "narHash": "sha256-cKDDciXGpMEjP1n6HlzKinN0H+oLmNpgeCTzYnsA2po=",
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "rev": "71fb97f0d875fd4de4994dfb849f2c75e17eb6c3",
        "type": "github"
      },
      "original": {
        "id": "flake-parts",
        "type": "indirect"
      }
    },
    "flake-root": {
      "locked": {
        "lastModified": 1680964220,
        "narHash": "sha256-dIdTYcf+KW9a4pKHsEbddvLVSfR1yiAJynzg2x0nfWg=",
        "owner": "srid",
        "repo": "flake-root",
        "rev": "f1c0b93d05bdbea6c011136ba1a135c80c5b326c",
        "type": "github"
      },
      "original": {
        "owner": "srid",
        "repo": "flake-root",
        "type": "github"
      }
    },
    "mission-control": {
      "locked": {
        "lastModified": 1683658484,
        "narHash": "sha256-JkGnWyYZxOnyOhztrxLSqaod6+O/3rRypq0dAqA/zn0=",
        "owner": "Platonic-Systems",
        "repo": "mission-control",
        "rev": "a0c93bd764a3c25e6999397e9f5f119c1b124e38",
        "type": "github"
      },
      "original": {
        "owner": "Platonic-Systems",
        "repo": "mission-control",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1687502512,
        "narHash": "sha256-dBL/01TayOSZYxtY4cMXuNCBk8UMLoqRZA+94xiFpJA=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "3ae20aa58a6c0d1ca95c9b11f59a2d12eebc511f",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs-lib": {
      "locked": {
        "dir": "lib",
        "lastModified": 1685564631,
        "narHash": "sha256-8ywr3AkblY4++3lIVxmrWZFzac7+f32ZEhH/A8pNscI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "4f53efe34b3a8877ac923b9350c874e3dcd5dc0a",
        "type": "github"
      },
      "original": {
        "dir": "lib",
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-parts": "flake-parts",
        "flake-root": "flake-root",
        "mission-control": "mission-control",
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="examples/project-commands/flake.nix">
{
  description = "Description for the project";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";

    mission-control.url = "github:Platonic-Systems/mission-control";
    flake-root.url = "github:srid/flake-root";
  };

  outputs = inputs@{ flake-parts, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      imports = [
        inputs.mission-control.flakeModule
        inputs.flake-root.flakeModule
      ];
      systems = [ "x86_64-linux" "aarch64-darwin" "x86_64-darwin" ];
      perSystem = { config, self', inputs', pkgs, system, ... }: {
        devShells.default = pkgs.mkShell {
          nativeBuildInputs = with pkgs; [ avro-tools ];
          inputsFrom = [ config.mission-control.devShell config.flake-root.devShell ];
        };
        mission-control = {
          wrapperName = "run";
          scripts = {
            build = {
              description = "convert files from .avdl to .avsc";
              exec = ''
                avro-tools idl2schemata "$FLAKE_ROOT/Hello.avdl" .
              '';
              category = "Development";
            };
          };
        };
      };
    };
}
</file>

<file path="examples/project-commands/Hello.avdl">
protocol Hello {
    record Hello {
        string message;
        int timestamp;
    }
}
</file>

<file path="examples/project-commands/README.md">
# project-commands

> **Warning**
> If you copy the flake.nix remember to `git add [-N|--intent-to-add] flake.nix`, otherwise it won't work

This example shows how to create scripts for your project, by leveraging [mission-control](https://github.com/Platonic-Systems/mission-control)

This is a **potential** alternative to:

- Using a `Makefile` to manage your project's scripts
- Using the popular [Scripts To Rule Them All](https://github.com/github/scripts-to-rule-them-all); a naming convention for a `scripts/` directory
- Using a `bin/` directory

## Explanation

In this example we use the [avro-tools](https://avro.apache.org/) to convert our scripts from `.avdl` to `.avsc`.

You don't need to know anything about avro to understand mission-control and use this example (that's Nix baby 🚀).

When setting up [mission-control](https://github.com/Platonic-Systems/mission-control), we add
one script called `build`. Because of `wrapperName = "run";`, once we open the shell created by nix,
the commands will be listed as `run build`.

mission-control depends on flake-root, which also exposes the helpful `$FLAKE_ROOT` variable.

After creating the scripts, we need to pass the newly created scripts to the desired shell, in this example we use the default shell.

## Usage

Run:

```sh
nix develop
```

And mission-control will print in the new shell the available commands (you should see only one).

Try running

```sh
run build
```
</file>

<file path="examples/shell-environments/flake.lock">
{
  "nodes": {
    "flake-parts": {
      "inputs": {
        "nixpkgs-lib": "nixpkgs-lib"
      },
      "locked": {
        "lastModified": 1685662779,
        "narHash": "sha256-cKDDciXGpMEjP1n6HlzKinN0H+oLmNpgeCTzYnsA2po=",
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "rev": "71fb97f0d875fd4de4994dfb849f2c75e17eb6c3",
        "type": "github"
      },
      "original": {
        "id": "flake-parts",
        "type": "indirect"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1687412861,
        "narHash": "sha256-Z/g0wbL68C+mSGerYS2quv9FXQ1RRP082cAC0Bh4vcs=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "e603dc5f061ca1d8a19b3ede6a8cf9c9fcba6cdc",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs-lib": {
      "locked": {
        "dir": "lib",
        "lastModified": 1685564631,
        "narHash": "sha256-8ywr3AkblY4++3lIVxmrWZFzac7+f32ZEhH/A8pNscI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "4f53efe34b3a8877ac923b9350c874e3dcd5dc0a",
        "type": "github"
      },
      "original": {
        "dir": "lib",
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-parts": "flake-parts",
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="examples/shell-environments/flake.nix">
{
  description = "Description for the project";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };

  outputs = inputs@{ flake-parts, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [ "x86_64-linux" "aarch64-darwin" "x86_64-darwin" ];
      perSystem = { config, self', inputs', pkgs, system, ... }: {
        devShells.default = pkgs.mkShell {
          nativeBuildInputs = with pkgs; [ terraform wget bat nixpkgs-fmt ];
        };

        devShells.another_env = pkgs.mkShell {
          nativeBuildInputs = with pkgs; [ curl ];
        };
      };

    };
}
</file>

<file path="examples/shell-environments/README.md">
# shell-environment

> **Warning**
> If you copy the flake.nix remember to `git add [-N|--intent-to-add] flake.nix`, otherwise it won't work

This example shows how to create a shell environment which
includes a diverse set of tools:

```sh
terraform
wget
bat
nixpkgs-fmt
```

You can search for more packages in [nix packages](https://search.nixos.org/packages)

## Usage

The [`devShells` option](https://flake.parts/options/flake-parts.html#opt-perSystem.devShells) is used by the following command:

```sh
nix develop
```

You can have as many shells as you want, in this [flake.nix](./flake.nix), you also have
`another_env` which includes `curl`. To open it:

```sh
nix develop .#another_env
```

## Troubleshooting

### I get bash instead of my shell

`nix develop` was designed for Nixpkgs stdenv, which uses bash, so that you can troubleshoot a Nix build with it. If you use a different shell, you'll want to get just the variables instead.

There are 3 possible solutions:

First, using [direnv](https://direnv.net/) to manage your dev environments. See [direnv-guide](https://haskell.flake.page/direnv). This is the recommended approach.

Second is a simple-unreliable hack, which is adding a `shellHook` to `devShells`

```nix
devShells.default = pkgs.mkShell {
  shellHook = ''
    exec $SHELL
  '';
};
```

You might get a lot different issues, use it at your own risk.

Lastly, there's `nix print-dev-env` which returns the variables - in case you're feeling adventurous, because this is far from a complete solution. See `nix print-dev-env --help`.
</file>

<file path="extras/bundlers.nix">
{ lib
, flake-parts-lib
, ...
}:
let
  inherit
    (lib)
    mkOption
    types
    ;
  inherit
    (flake-parts-lib)
    mkTransposedPerSystemModule
    ;
in
mkTransposedPerSystemModule {
  name = "bundlers";
  option = mkOption {
    type = types.lazyAttrsOf (types.functionTo types.package);
    default = { };
    description = ''
      An attribute set of bundlers to be used by [`nix bundle`](https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-bundle.html).

      `nix bundle --bundler .#<name>` <derivation> will bundle <derivation> using the bundler `bundlers.<name>`.
    '';
  };
  file = ./bundlers.nix;
}
</file>

<file path="extras/easyOverlay.nix">
toplevel@{ lib, flake-parts-lib, getSystemIgnoreWarning, ... }:
let
  inherit (flake-parts-lib)
    mkPerSystemOption;
  inherit (lib)
    mkOption
    types;
in
{
  options = {
    perSystem = mkPerSystemOption ({ config, extendModules, pkgs, ... }: {
      _file = ./easyOverlay.nix;
      options = {
        extendModules = mkOption {
          type = types.raw;
          default = extendModules;
          internal = true;
        };
        overlayAttrs = mkOption {
          type = types.lazyAttrsOf types.raw;
          default = { };
          description = ''
            Attributes to add to `overlays.default`.

            The `overlays.default` overlay will re-evaluate `perSystem` with
            the "prev" (or "super") overlay argument value as the `pkgs` module
            argument. The `easyOverlay` module also adds the `final` module
            argument, for the result of applying the overlay.

            When not in an overlay, `final` defaults to `pkgs` plus the generated
            overlay. This requires Nixpkgs to be re-evaluated, which is more
            expensive than setting `pkgs` to a Nixpkgs that already includes
            the necessary overlays that are required for the flake itself.

            See [Overlays](../overlays.html).
          '';
        };
      };
      config = {
        _module.args.final = lib.mkDefault (pkgs.extend toplevel.config.flake.overlays.default);
      };
    });
  };
  config = {
    flake.overlays.default = final: prev:
      let
        system =
          prev.stdenv.hostPlatform.system or (
            prev.system or (
              throw "Could not determine the `hostPlatform` of Nixpkgs. Was this overlay loaded as a Nixpkgs overlay, or was it loaded into something else?"
            )
          );
        perSys = (getSystemIgnoreWarning system).extendModules {
          modules = [
            {
              _file = "flake-parts#flakeModules.easyOverlay/overlay-overrides";
              _module.args.pkgs = lib.mkForce prev;
              _module.args.final = lib.mkForce final;
            }
          ];
        };
      in
      perSys.config.overlayAttrs;
  };
}
</file>

<file path="extras/flakeModules.nix">
{ self, lib, flake-parts-lib, moduleLocation, ... }:
let
  inherit (lib)
    mapAttrs
    mkOption
    types
    ;
  inherit (flake-parts-lib)
    mkAliasOptionModule
    ;

  flakeModulesOption = mkOption {
    type = types.lazyAttrsOf types.deferredModule;
    default = { };
    apply = mapAttrs (k: v: {
      _file = "${toString moduleLocation}#flakeModules.${k}";
      key = "${toString moduleLocation}#flakeModules.${k}";
      imports = [ v ];
      _class = "flake";
    });
    description = ''
      flake-parts modules for use by other flakes.

      If the flake defines only one module, it should be `flakeModules.default`.

      You can not read this option in defining the flake's own `imports`. Instead, you can
      put the module in question into its own file or let binding and reference
      it both in `imports` and export it with this option.

      See [Dogfood a Reusable Module](../dogfood-a-reusable-module.md) for details and an example.
    '';
  };
in
{
  options = {
    flake = mkOption {
      type = types.submoduleWith {
        modules = [
          (mkAliasOptionModule [ "flakeModule" ] [ "flakeModules" "default" ])
          {
            options.flakeModules = flakeModulesOption;
          }
        ];
      };
    };
  };
}
</file>

<file path="extras/modules.nix">
{ lib, moduleLocation, ... }:
let
  inherit (lib)
    mapAttrs
    mkOption
    types
    ;
  inherit (lib.strings)
    escapeNixIdentifier
    ;

  addInfo = class: moduleName:
    if class == "generic"
    then module: module
    else
      module:
      # TODO: set key?
      {
        _class = class;
        _file = "${toString moduleLocation}#modules.${escapeNixIdentifier class}.${escapeNixIdentifier moduleName}";
        imports = [ module ];
      };
in
{
  options = {
    flake.modules = mkOption {
      type = types.lazyAttrsOf (types.lazyAttrsOf types.deferredModule);
      description = ''
        Groups of modules published by the flake.

        The outer attributes declare the [`class`](https://nixos.org/manual/nixpkgs/stable/#module-system-lib-evalModules-param-class) of the modules within it.
        The special attribute `generic` does not declare a class, allowing its modules to be used in any module class.
      '';
      example = lib.literalExpression ''
        {
          # NixOS configurations are modules with class "nixos"
          nixos = {
            # You can define a module right here:
            noBoot = { config, ... }: {
              boot.loader.enable = false;
            };
            # Or you may refer to it by file
            autoDeploy = ./nixos/auto-deploy.nix;
            # Or maybe you need both
            projectIcarus = { config, pkgs, ... }: {
              imports = [ ./nixos/project-icarus.nix ];
              services.project-icarus.package =
                withSystem pkgs.stdenv.hostPlatform.system ({ config, ... }:
                  config.packages.default
                );
            };
          };
          # Flake-parts modules
          # If you're not just publishing a module, but also using it locally,
          # create a let binding to declare it before calling `mkFlake` so you can
          # use it in both places.
          flake = {
            foo = someModule;
          };
          # Modules that can be loaded anywhere
          generic = {
            my-pkgs = { _module.args.my-pkgs = …; };
          };
        }
      '';
      apply = mapAttrs (k: mapAttrs (addInfo k));
    };
  };
}
</file>

<file path="extras/partitions.nix">
{ lib, config, inputs, extendModules, partitionStack, self, ... }:
let
  inherit (lib)
    literalMD
    mapAttrs
    mkOption
    optionalAttrs
    types
    ;

  partitionModule = { config, options, name, ... }: {
    options = {
      extraInputsFlake = mkOption {
        type = types.raw;
        description = ''
          Location of a flake whose inputs to add to the inputs module argument in the partition.
          Note that flake `follows` are resolved without any awareness of inputs that are not in the flake.
          As a consequence, a `follows` entry in the flake inputs can not refer to inputs that are not in that specific flake.

          Implementation note: if the type of `extraInputsFlake` is a path, it is loaded with an expression-based reimplementation of `builtins.getFlake`, as `getFlake` is incapable of loading paths in pure mode as of writing.
        '';
        example = lib.literalExpression "./dev";
      };
      extraInputs = mkOption {
        type = types.lazyAttrsOf types.raw;
        description = ''
          Extra inputs to add to the inputs module argument in the partition.

          This can be used as a workaround for the fact that transitive inputs are locked in the "end user" flake.
          That's not desirable for inputs they don't need, such as development inputs.
        '';
        default = { };
        defaultText = literalMD ''
          if `extraInputsFlake` is set, then `builtins.getFlake extraInputsFlake`, else `{ }`
        '';
      };
      module = mkOption {
        type = (extendModules {
          specialArgs =
            let
              inputs2 = inputs // config.extraInputs // {
                self = self2;
              };
              self2 = self // {
                inputs = inputs2;
              };
            in
            {
              inputs = inputs2;
              self = self2;
              partitionStack = partitionStack ++ [ name ];
            };
        }).type;
        default = { };
        description = ''
          A re-evaluation of the flake-parts top level modules.

          You may define config definitions, `imports`, etc here, and it can be read like any other submodule.
        '';
        example = lib.literalExpression ''
          {
            imports = [
              ./dev/flake-module.nix
            ];
          }
        '';
        visible = "shallow";
      };
    };
    config = {
      extraInputs = lib.mkIf options.extraInputsFlake.isDefined (
        let
          p = options.extraInputsFlake.value;
          flake =
            if builtins.typeOf p == "path"
            then get-flake p
            else builtins.getFlake p;
        in
        flake.inputs
      );
    };
  };

  # Nix does not recognize that a flake like "${./dev}", which is a content
  # addressed store path is a pure input, so we have to fetch and wire it
  # manually with flake-compat.
  get-flake = src: (flake-compat { inherit src; system = throw "operating flake-compat in pure mode; system not allowed to be used"; }).outputs;
  # TODO: update
  flake-compat = import (builtins.fetchTarball {
    url = "https://github.com/edolstra/flake-compat/archive/9ed2ac151eada2306ca8c418ebd97807bb08f6ac.tar.gz";
    sha256 = "sha256:063slk1np1g1dkh21a82x655kpja7p4pc74rb3lqankyrbbpy4hx";
  });

in
{
  options = {
    partitionedAttrs = mkOption {
      type = types.attrsOf types.str;
      default = { };
      description = ''
        A set of flake output attributes that are taken from a partition instead of the default top level flake-parts evaluation.

        The attribute name refers to the flake output attribute name, and the value is the name of the partition to use.

        The flake attributes are overridden with `lib.mkForce` priority.

        See the `partitions` options to understand the purpose.
      '';
      example = {
        "devShells" = "dev";
        "checks" = "dev";
        "herculesCI" = "dev";
      };
    };
    partitions = mkOption {
      type = types.attrsOf (types.submodule partitionModule);
      default = { };
      description = ''
        By partitioning the flake, you can avoid fetching inputs that are not
        needed for the evaluation of a particular attribute.

        Each partition is a distinct module system evaluation. This allows
        attributes of the final flake to be defined by multiple sets of modules,
        so that for example the `packages` attribute can be evaluated without
        loading development related inputs.

        While the module system does a good job at preserving laziness, the fact
        that a development related import can define `packages` means that
        in order to evaluate `packages`, you need to evaluate at least to the
        point where you can conclude that the development related import does
        not actually define a `packages` attribute. While the actual evaluation
        is cheap, it can only happen after fetching the input, which is not
        as cheap.
      '';
      example = lib.literalExpression ''
        {
          dev = {
            extraInputsFlake = ./dev;
            module = ./dev/flake-module.nix;
          };
        }
      '';
    };
  };
  config = {
    # Default, overriden with specialArgs inside partitions.
    _module.args.partitionStack = [ ];
    flake = optionalAttrs (partitionStack == [ ]) (
      mapAttrs
        (attrName: partition: lib.mkForce (config.partitions.${partition}.module.flake.${attrName}))
        config.partitionedAttrs
    );
  };
}
</file>

<file path="lib/memoize/measure-bytes-per-char.nix">
# Run with:
#   NIX_SHOW_STATS=1 nix eval --expr 'import ./measure-bytes-per-char.nix { control = false; size = 10; }' --impure
#   NIX_SHOW_STATS=1 nix eval --expr 'import ./measure-bytes-per-char.nix { control = true; size = 10; }' --impure

{ control ? false, size ? 10 }:

let
  lib = import <nixpkgs/lib>;
  inherit (import ./memoize.nix { inherit lib; }) memoizeStr;

  # Create a string of the specified size
  key = lib.concatStrings (lib.genList (i: "a") size);

  # Memoized identity function
  memoId = memoizeStr (x: x);

  # Prime the trie with a minimal query to force its construction
  prime = memoId "";

in
if control
then builtins.seq prime key  # Return key after priming
else builtins.seq prime (memoId key)  # Pass through memoization after priming
</file>

<file path="lib/memoize/memoize.nix">
{ lib, ... }:
let
  keys =
    let
      nonNullBytesStr =
        builtins.readFile ./bytes.dat;
      nonNullItems =
        lib.stringToCharacters nonNullBytesStr;

      keysList = [ "" ] ++ nonNullItems;

      byteNames = lib.genAttrs keysList (k: null);
    in
    byteNames;

  /**
    Produce an infinite trie for memoizing a function with a string input.
    
    This uses memory in terms of a large factor of the number of unique string suffixes passed to the memoizeStr / queryTrie functions.
  */
  makeTrie = prefix: f:
    lib.mapAttrs
      (k: v: if k == "" then f prefix else makeTrie (prefix + k) f)
      keys;

  queryTrie =
    trie: needle:
    let
      needleList = lib.stringToCharacters needle;
      destination = lib.foldl'
        (subtrie: c: subtrie.${c})
        trie
        needleList;
    in
    destination."";

in
{
  /**
    Turn a function that accepts a string input into one that memoizes the results.
    Make sure to partially apply it and use it over and over in e.g. the same let binding.
    Otherwise, you're wasting kilobytes of memory allocations *for each letter in each call*.
    That's 12+ KB per input byte on Nix 2.31, and more on older versions.
    Yes, this function is surprisingly EXPENSIVE, but cheaper than e.g. reinvoking Nixpkgs.
    Its memory cost is comparable to that of loading a small Nix file.
   */
  memoizeStr = f:
    let trie = makeTrie "" f;
    in queryTrie trie;
}
</file>

<file path="lib/memoize/test.nix">
# Ad hoc manual test dependent on observing side effects
let
  lib = import ~/src/nixpkgs-master/lib;
  inherit (import ./memoize.nix { inherit lib; }) memoizeStr;
  # Don't use this in the wild, it's too expensive!
  printOnce = memoizeStr (x: builtins.trace "computing f ${lib.strings.escapeNixString x}" x);
in
{
  inherit printOnce memoizeStr lib;
}
</file>

<file path="modules/apps.nix">
{ lib, flake-parts-lib, ... }:
let
  inherit (lib)
    mkOption
    types
    ;
  inherit (flake-parts-lib)
    mkTransposedPerSystemModule
    ;

  getExe = lib.getExe or (
    x:
    "${lib.getBin x}/bin/${x.meta.mainProgram or (throw ''Package ${x.name or ""} does not have meta.mainProgram set, so I don't know how to find the main executable. You can set meta.mainProgram, or pass the full path to executable, e.g. program = "''${pkg}/bin/foo"'')}"
  );

  programType = lib.types.coercedTo derivationType getExe lib.types.str;

  derivationType = lib.types.package // {
    check = lib.isDerivation;
  };

  appType = lib.types.submodule {
    options = {
      type = mkOption {
        type = lib.types.enum [ "app" ];
        default = "app";
        description = ''
          A type tag for `apps` consumers.
        '';
      };
      program = mkOption {
        type = programType;
        description = ''
          A path to an executable or a derivation with `meta.mainProgram`.
        '';
      };
      meta = mkOption {
        type = types.lazyAttrsOf lib.types.raw;
        default = { };
        # TODO refer to Nix manual 2.25
        description = ''
          Metadata information about the app.
          Standardized in Nix at <https://github.com/NixOS/nix/pull/11297>.

          Note: `nix flake check` is only aware of the `description` attribute in `meta`.
        '';
      };
    };
  };
in
mkTransposedPerSystemModule {
  name = "apps";
  option = mkOption {
    type = types.lazyAttrsOf appType;
    default = { };
    description = ''
      Programs runnable with nix run `<name>`.
    '';
    example = lib.literalExpression or lib.literalExample ''
      {
        default.program = "''${config.packages.hello}/bin/hello";
      }
    '';
  };
  file = ./apps.nix;
}
</file>

<file path="modules/checks.nix">
{ lib, flake-parts-lib, ... }:
let
  inherit (lib)
    mkOption
    types
    ;
  inherit (flake-parts-lib)
    mkTransposedPerSystemModule
    ;
in
mkTransposedPerSystemModule {
  name = "checks";
  option = mkOption {
    type = types.lazyAttrsOf types.package;
    default = { };
    description = ''
      Derivations to be built by [`nix flake check`](https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake-check.html).
    '';
  };
  file = ./checks.nix;
}
</file>

<file path="modules/debug.nix">
{ config, flake-parts-lib, lib, options, getSystem, extendModules, ... }:
let
  inherit (lib)
    mapAttrs
    mkIf
    mkOption
    optionalAttrs
    types
    ;
  inherit (flake-parts-lib)
    mkPerSystemOption
    ;

  mkDebugConfig = { config, options, extendModules }: config // {
    inherit config;
    inherit (config) _module;
    inherit options;
    inherit extendModules;
  };
in
{
  options = {
    debug = mkOption {
      type = types.bool;
      default = false;
      description = ''
        Whether to add the attributes `debug`, `allSystems` and `currentSystem`
        to the flake output. When `true`, this allows inspection of options via
        `nix repl`.

        ```
        $ nix repl
        nix-repl> :lf .
        nix-repl> currentSystem._module.args.pkgs.hello
        «derivation /nix/store/7vf0d0j7majv1ch1xymdylyql80cn5fp-hello-2.12.1.drv»
        ```

        Each of `debug`, `allSystems.<system>` and `currentSystem` is an
        attribute set consisting of the `config` attributes, plus the extra
        attributes `_module`, `config`, `options`, `extendModules`. So note that
        these are not part of the `config` parameter, but are merged in for
        debugging convenience.

         - `debug`: The top-level options
         - `allSystems`: The `perSystem` submodule applied to the configured `systems`.
         - `currentSystem`: Shortcut into `allSystems`. Only available in impure mode.
           Works for arbitrary system values.

        See [Expore and debug option values](../debug.html) for more examples.
      '';
    };
    perSystem = mkPerSystemOption
      ({ options, config, extendModules, ... }: {
        _file = ./formatter.nix;
        options = {
          debug = mkOption {
            description = ''
              Values to return in e.g. `allSystems.<system>` when
              [`debug = true`](#opt-debug).
            '';
            type = types.lazyAttrsOf types.raw;
          };
        };
        config = {
          debug = mkDebugConfig { inherit config options extendModules; };
        };
      });
  };

  config = mkIf config.debug {
    flake = {
      debug = mkDebugConfig { inherit config options extendModules; };
      allSystems = mapAttrs (_s: c: c.debug) config.allSystems;
    } // optionalAttrs (builtins?currentSystem) {
      currentSystem = (getSystem builtins.currentSystem).debug;
    };
  };
}
</file>

<file path="modules/devShells.nix">
{ lib, flake-parts-lib, ... }:
let
  inherit (lib)
    mkOption
    types
    literalExpression
    ;
  inherit (flake-parts-lib)
    mkTransposedPerSystemModule
    ;
in
mkTransposedPerSystemModule {
  name = "devShells";
  option = mkOption {
    type = types.lazyAttrsOf types.package;
    default = { };
    description = ''
      An attribute set of packages to be used as shells.
      [`nix develop .#<name>`](https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-develop.html) will run `devShells.<name>`.
    '';
    example = literalExpression ''
      {
        default = pkgs.mkShell {
          nativeBuildInputs = with pkgs; [ wget bat cargo ];
        };
      }
    '';
  };
  file = ./devShells.nix;
}
</file>

<file path="modules/flake.nix">
{ lib, ... }:
let
  inherit (lib)
    mkOption
    types
    ;
in
{
  options = {
    flake = mkOption {
      type = types.submoduleWith {
        modules = [
          {
            freeformType =
              types.lazyAttrsOf
                (types.unique
                  {
                    message = ''
                      No option has been declared for this flake output attribute, so its definitions can't be merged automatically.
                      Possible solutions:
                        - Load a module that defines this flake output attribute
                          Many modules are listed at https://flake.parts
                        - Declare an option for this flake output attribute
                        - Make sure the output attribute is spelled correctly
                        - Define the value only once, with a single definition in a single module
                    '';
                  }
                  types.raw);
          }
        ];
      };
      description = ''
        Raw flake output attributes. Any attribute can be set here, but some
        attributes are represented by options, to provide appropriate
        configuration merging.
      '';
    };
  };
}
</file>

<file path="modules/formatter.nix">
{ config, lib, flake-parts-lib, ... }:
let
  inherit (lib)
    filterAttrs
    mapAttrs
    mkOption
    optionalAttrs
    types
    ;
  inherit (flake-parts-lib)
    mkSubmoduleOptions
    mkPerSystemOption
    ;
in
{
  options = {
    flake = mkSubmoduleOptions {
      formatter = mkOption {
        type = types.lazyAttrsOf types.package;
        default = { };
        description = ''
          An attribute set of per system a package used by [`nix fmt`](https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-fmt.html).
        '';
      };
    };

    perSystem = mkPerSystemOption {
      _file = ./formatter.nix;
      options = {
        formatter = mkOption {
          type = types.nullOr types.package;
          default = null;
          description = ''
            A package used by [`nix fmt`](https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-fmt.html).
          '';
        };
      };
    };
  };
  config = {
    flake.formatter =
      mapAttrs
        (k: v: v.formatter)
        (filterAttrs
          (k: v: v.formatter != null)
          config.allSystems
        );

    perInput = system: flake:
      optionalAttrs (flake?formatter.${system}) {
        formatter = flake.formatter.${system};
      };

  };
}
</file>

<file path="modules/legacyPackages.nix">
{ lib, flake-parts-lib, ... }:
let
  inherit (lib)
    mkOption
    types
    ;
  inherit (flake-parts-lib)
    mkTransposedPerSystemModule
    ;
in
mkTransposedPerSystemModule {
  name = "legacyPackages";
  option = mkOption {
    type = types.lazyAttrsOf types.raw;
    default = { };
    description = ''
      An attribute set of unmergeable values. This is also used by [`nix build .#<attrpath>`](https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-build.html).
    '';
  };
  file = ./legacyPackages.nix;
}
</file>

<file path="modules/moduleWithSystem.nix">
{ withSystem, ... }:
{
  config = {
    _module.args = {
      moduleWithSystem =
        module:

        { config, ... }:
        let
          system =
            config._module.args.system or
              config._module.args.pkgs.stdenv.hostPlatform.system or
                (throw "moduleWithSystem: Could not determine the configuration's system parameter for this module system application.");

          allArgs = withSystem system (args: args);

          lazyArgsPerParameter = f: builtins.mapAttrs
            (k: v: allArgs.${k} or (throw "moduleWithSystem: module argument `${k}` does not exist."))
            (builtins.functionArgs f);

          # Use reflection to make the call lazy in the argument.
          # Restricts args to the ones declared.
          callLazily = f: a: f (lazyArgsPerParameter f);
        in
        {
          imports = [
            (callLazily module allArgs)
          ];
        };
    };
  };
}
</file>

<file path="modules/nixosConfigurations.nix">
{ lib, flake-parts-lib, ... }:
let
  inherit (lib)
    mkOption
    types
    literalExpression
    ;
  inherit (flake-parts-lib)
    mkSubmoduleOptions
    ;
in
{
  options = {
    flake = mkSubmoduleOptions {
      nixosConfigurations = mkOption {
        type = types.lazyAttrsOf types.raw;
        default = { };
        description = ''
          Instantiated NixOS configurations. Used by `nixos-rebuild`.

          `nixosConfigurations` is for specific machines. If you want to expose
          reusable configurations, add them to [`nixosModules`](#opt-flake.nixosModules)
          in the form of modules (no `lib.nixosSystem`), so that you can reference
          them in this or another flake's `nixosConfigurations`.
        '';
        example = literalExpression ''
          {
            my-machine = inputs.nixpkgs.lib.nixosSystem {
              # system is not needed with freshly generated hardware-configuration.nix
              # system = "x86_64-linux";  # or set nixpkgs.hostPlatform in a module.
              modules = [
                ./my-machine/nixos-configuration.nix
                config.nixosModules.my-module
              ];
            };
          }
        '';
      };
    };
  };
}
</file>

<file path="modules/nixosModules.nix">
{ self, lib, flake-parts-lib, moduleLocation, ... }:
let
  inherit (lib)
    mapAttrs
    mkOption
    types
    ;
  inherit (flake-parts-lib)
    mkSubmoduleOptions
    ;
in
{
  options = {
    flake = mkSubmoduleOptions {
      nixosModules = mkOption {
        type = types.lazyAttrsOf types.deferredModule;
        default = { };
        apply = mapAttrs (k: v: { _file = "${toString moduleLocation}#nixosModules.${k}"; imports = [ v ]; });
        description = ''
          NixOS modules.

          You may use this for reusable pieces of configuration, service modules, etc.
        '';
      };
    };
  };
}
</file>

<file path="modules/nixpkgs.nix">
#
# Nixpkgs module. The only exception to the rule.
#
# Provides a `pkgs` argument in `perSystem`.
#
# Arguably, this shouldn't be in flake-parts, but in nixpkgs.
# Nixpkgs could define its own module that does this, which would be
# a more consistent UX, but for now this will do.
#
# The existence of this module does not mean that other flakes' logic
# will be accepted into flake-parts, because it's against the
# spirit of Flakes.
#
{
  config = {
    perSystem = { inputs', lib, ... }: {
      config = {
        _module.args.pkgs = lib.mkOptionDefault (
          builtins.seq
            (inputs'.nixpkgs or (throw "flake-parts: The flake does not have a `nixpkgs` input. Please add it, or set `perSystem._module.args.pkgs` yourself."))
            inputs'.nixpkgs.legacyPackages
        );
      };
    };
  };
}
</file>

<file path="modules/overlays.nix">
{ lib, flake-parts-lib, ... }:
let
  inherit (lib)
    mkOption
    types
    ;
  inherit (flake-parts-lib)
    mkSubmoduleOptions
    ;
in
{
  options = {
    flake = mkSubmoduleOptions {
      overlays = mkOption {
        # uniq -> ordered: https://github.com/NixOS/nixpkgs/issues/147052
        # also update description when done
        type = types.lazyAttrsOf (types.uniq (types.functionTo (types.functionTo (types.lazyAttrsOf types.unspecified))));
        # This eta expansion exists for the sole purpose of making nix flake check happy.
        apply = lib.mapAttrs (_k: f: final: prev: f final prev);
        default = { };
        example = lib.literalExpression or lib.literalExample ''
          {
            default = final: prev: {};
          }
        '';
        description = ''
          An attribute set of [overlays](https://nixos.org/manual/nixpkgs/stable/#chap-overlays).

          Note that the overlays themselves are not mergeable. While overlays
          can be composed, the order of composition is significant, but the
          module system does not guarantee sufficiently deterministic
          definition ordering, across versions and when changing `imports`.
        '';
      };
    };
  };
}
</file>

<file path="modules/packages.nix">
{ lib, flake-parts-lib, ... }:
let
  inherit (lib)
    mkOption
    types
    ;
  inherit (flake-parts-lib)
    mkTransposedPerSystemModule
    ;
in
mkTransposedPerSystemModule {
  name = "packages";
  option = mkOption {
    type = types.lazyAttrsOf types.package;
    default = { };
    description = ''
      An attribute set of packages to be built by [`nix build`](https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-build.html).

      `nix build .#<name>` will build `packages.<name>`.
    '';
  };
  file = ./packages.nix;
}
</file>

<file path="modules/perSystem.nix">
{ config, lib, flake-parts-lib, self, ... }:
let
  inherit (lib)
    genAttrs
    mapAttrs
    mkOption
    types
    ;
  inherit (lib.strings)
    escapeNixIdentifier
    ;
  inherit (flake-parts-lib)
    mkPerSystemType
    ;

  rootConfig = config;

  # Stubs for self and inputs. While it'd be possible to define aliases
  # inside perSystem, that is not a general solution, and it would make
  # top.config harder to discover, stretching the learning curve rather
  # than flattening it.

  throwAliasError' = param:
    throw ''
      `${param}` (without `'`) is not a `perSystem` module argument, but a
      module argument of the top level config.

      The following is an example usage of `${param}`. Note that its binding
      is in the `top` parameter list, which is declared by the top level module
      rather than the `perSystem` module.

        top@{ config, lib, ${param}, ... }: {
          perSystem = { config, ${param}', ... }: {
            # in scope here:
            #  - ${param}
            #  - ${param}'
            #  - config (of perSystem)
            #  - top.config (note the `top@` pattern)
          };
        }
    '';

  throwAliasError = param:
    throw ''
      `${param}` is not a `perSystem` module argument, but a module argument of
      the top level config.

      The following is an example usage of `${param}`. Note that its binding
      is in the `top` parameter list, which is declared by the top level module
      rather than the `perSystem` module.

        top@{ config, lib, ${param}, ... }: {
          perSystem = { config, ... }: {
            # in scope here:
            #  - ${param}
            #  - config (of perSystem)
            #  - top.config (note the `top@` pattern)
          };
        }
    '';

  /**
    We primarily use `systems` to help memoize the per system context, but that
    doesn't extend to arbitrary `system`s.
    For that, we use the slightly less efficient, but perfectly acceptable
    `memoizeStr` function.
   */
  otherMemoizedSystems = flake-parts-lib.memoizeStr config.perSystem;

in
{
  options = {
    systems = mkOption {
      description = ''
        All the system types to enumerate in the flake output subattributes.

        In other words, all valid values for `system` in e.g. `packages.<system>.foo`.
      '';
      type = types.listOf types.str;
    };

    perInput = mkOption {
      description = ''
        A function that pre-processes flake inputs.

        It is called for users of `perSystem` such that `inputs'.''${name} = config.perInput system inputs.''${name}`.

        This is used for [`inputs'`](../module-arguments.html#inputs) and [`self'`](../module-arguments.html#self).

        The attributes returned by the `perInput` function definitions are merged into a single namespace (per input), 
        so each module should return an attribute set with usually only one or two predictable attribute names. Otherwise,
        the `inputs'` namespace gets polluted.
      '';
      type = types.functionTo (types.functionTo (types.lazyAttrsOf types.unspecified));
    };

    perSystem = mkOption {
      description = ''
        A function from system to flake-like attributes omitting the `<system>` attribute.

        Modules defined here have access to the suboptions and [some convenient module arguments](../module-arguments.html).
      '';
      type = mkPerSystemType ({ config, system, ... }: {
        _file = ./perSystem.nix;
        config = {
          _module.args.inputs' =
            mapAttrs
              (inputName: input:
                builtins.addErrorContext "while retrieving system-dependent attributes for input ${escapeNixIdentifier inputName}" (
                  if input._type or null == "flake"
                  then rootConfig.perInput system input
                  else
                    throw "Trying to retrieve system-dependent attributes for input ${escapeNixIdentifier inputName}, but this input is not a flake. Perhaps flake = false was added to the input declarations by mistake, or you meant to use a different input, or you meant to use plain old inputs, not inputs'."
                )
              )
              self.inputs;
          _module.args.self' =
            builtins.addErrorContext "while retrieving system-dependent attributes for a flake's own outputs" (
              rootConfig.perInput system self
            );

          # Custom error messages
          _module.args.self = throwAliasError' "self";
          _module.args.inputs = throwAliasError' "inputs";
          _module.args.getSystem = throwAliasError "getSystem";
          _module.args.withSystem = throwAliasError "withSystem";
          _module.args.moduleWithSystem = throwAliasError "moduleWithSystem";
        };
      });
      apply = modules: system:
        (lib.evalModules {
          inherit modules;
          prefix = [ "perSystem" system ];
          specialArgs = {
            inherit system;
          };
          class = "perSystem";
        }).config;
    };

    allSystems = mkOption {
      type = types.lazyAttrsOf types.unspecified;
      description = "The system-specific config for each of systems.";
      internal = true;
    };
  };

  config = {
    allSystems = genAttrs config.systems config.perSystem;
    _module.args.getSystem = system: config.allSystems.${system} or (otherMemoizedSystems system);

    # The warning is there for a reason. Only use this in situations where the
    # performance cost has already been incurred, such as in `flakeModules.easyOverlay`,
    # where we run in the context of an overlay, and the performance cost of the
    # extra `pkgs` makes the cost of running `perSystem` probably negligible.
    _module.args.getSystemIgnoreWarning = system: config.allSystems.${system} or (config.perSystem system);
  };

}
</file>

<file path="modules/transposition.nix">
{ config, lib, flake-parts-lib, ... }:

let
  inherit (lib)
    filterAttrs
    mapAttrs
    mkOption
    types
    ;
  inherit (lib.strings)
    escapeNixIdentifier
    ;

  transpositionModule = {
    options = {
      adHoc = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Whether to provide a stub option declaration for {option}`perSystem.<name>`.

          The stub option declaration does not support merging and lacks
          documentation, so you are recommended to declare the {option}`perSystem.<name>`
          option yourself and avoid {option}`adHoc`.
        '';
      };
    };
  };

  perInputAttributeError = { flake, attrName, system, attrConfig }:
    # This uses flake.outPath for lack of a better identifier.
    # Consider adding a perInput variation that has a normally-redundant argument for the input name.
    # Tested manually with
    # perSystem = { inputs', ... }: {
    #   packages.extra = inputs'.nixpkgs.extra;
    #   packages.default = inputs'.nixpkgs.packages.default;
    #   packages.veryWrong = (top.config.perInput "x86_64-linux" inputs'.nixpkgs.legacyPackages.hello).packages.default;
    # };
    # transposition.extra = {};
    let
      attrPath = "${escapeNixIdentifier attrName}.${escapeNixIdentifier system}";
      flakeIdentifier =
        if flake._type or null != "flake"
        then
          throw "An attempt was made to access attribute ${attrPath} on a value that's supposed to be a flake, but may not be a proper flake."
        else
          builtins.addErrorContext "while trying to find out how to describe what is supposedly a flake, whose attribute ${attrPath} was accessed but does not exist" (
            toString flake.outPath
          );
      # This ought to be generalized by extending attrConfig, but this is the only known and common mistake for now.
      alternateAttrNameHint =
        if attrName == "packages" && flake?legacyPackages
        then # Unfortunately we can't just switch them out, because that will put packages *sets* where single packages are expected in user code, resulting in potentially much worse and more confusing errors down the line.
          "\nIt does define legacyPackages; try that instead?"
        else "";
    in
    if flake?${attrName}
    then
      throw ''
        Attempt to access ${attrPath} of flake ${flakeIdentifier}, but it does not have it.
        It does have attribute ${escapeNixIdentifier attrName}, so it appears that it does not support system type ${escapeNixIdentifier system}.
      ''
    else
      throw ''
        Attempt to access ${attrPath} of flake ${flakeIdentifier}, but it does not have attribute ${escapeNixIdentifier attrName}.${alternateAttrNameHint}
      '';


in
{
  options = {
    transposition = lib.mkOption {
      description = ''
        A helper that defines transposed attributes in the flake outputs.

        When you define `transposition.foo = { };`, definitions are added to the effect of (pseudo-code):

        ```nix
        flake.foo.''${system} = (perSystem system).foo;
        perInput = system: inputFlake: inputFlake.foo.''${system};
        ```

        Transposition is the operation that swaps the indices of a data structure.
        Here it refers specifically to the transposition between

        ```plain
        perSystem: .''${system}.''${attribute}
        outputs:   .''${attribute}.''${system}
        ```

        It also defines the reverse operation in [{option}`perInput`](#opt-perInput).
      '';
      type =
        types.lazyAttrsOf
          (types.submoduleWith { modules = [ transpositionModule ]; });
    };
  };

  config = {
    flake =
      lib.mapAttrs
        (attrName: attrConfig:
          mapAttrs
            (system: v: v.${attrName} or (
              abort ''
                Could not find option ${attrName} in the perSystem module. It is required to declare such an option whenever transposition.<name> is defined (and in this instance <name> is ${attrName}).
              ''))
            config.allSystems
        )
        config.transposition;

    perInput =
      system: flake:
      mapAttrs
        (attrName: attrConfig:
          flake.${attrName}.${system} or (
            throw (perInputAttributeError { inherit system flake attrName attrConfig; })
          )
        )
        config.transposition;

    perSystem = {
      options =
        mapAttrs
          (k: v: lib.mkOption { })
          (filterAttrs
            (k: v: v.adHoc)
            config.transposition
          );
    };
  };
}
</file>

<file path="modules/withSystem.nix">
{ lib, flake-parts-lib, getSystem, ... }:
let
  inherit (lib)
    mkOption
    types
    ;
  inherit (flake-parts-lib)
    mkPerSystemOption
    ;
in
{
  options = {
    perSystem = mkPerSystemOption ({ config, options, specialArgs, ... }: {
      _file = ./perSystem.nix;
      options = {
        allModuleArgs = mkOption {
          type = types.lazyAttrsOf (types.raw or types.unspecified);
          internal = true;
          readOnly = true;
          description = "Internal option that exposes _module.args, for use by withSystem.";
        };
      };
      config = {
        allModuleArgs = config._module.args // specialArgs // { inherit config options; };
      };
    });
  };

  config = {
    _module.args = {
      withSystem =
        system: f:
        f
          (getSystem system).allModuleArgs;
    };
  };
}
</file>

<file path="template/default/flake.nix">
{
  description = "Description for the project";

  inputs = {
    flake-parts.url = "github:hercules-ci/flake-parts";
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };

  outputs = inputs@{ flake-parts, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      imports = [
        # To import a flake module
        # 1. Add foo to inputs
        # 2. Add foo as a parameter to the outputs function
        # 3. Add here: foo.flakeModule

      ];
      systems = [ "x86_64-linux" "aarch64-linux" "aarch64-darwin" "x86_64-darwin" ];
      perSystem = { config, self', inputs', pkgs, system, ... }: {
        # Per-system attributes can be defined here. The self' and inputs'
        # module parameters provide easy access to attributes of the same
        # system.

        # Equivalent to  inputs'.nixpkgs.legacyPackages.hello;
        packages.default = pkgs.hello;
      };
      flake = {
        # The usual flake attributes can be defined here, including system-
        # agnostic ones like nixosModule and system-enumerating ones, although
        # those are more easily expressed in perSystem.

      };
    };
}
</file>

<file path="template/multi-module/hello/flake-module.nix">
# Definitions can be imported from a separate file like this one

{ self, lib, ... }: {
  perSystem = { config, self', inputs', pkgs, ... }: {
    # Definitions like this are entirely equivalent to the ones
    # you may have directly in flake.nix.
    packages.hello = pkgs.hello;
  };
  flake = {
    nixosModules.hello = { pkgs, ... }: {
      environment.systemPackages = [
        # or self.inputs.nixpkgs.legacyPackages.${pkgs.stdenv.hostPlatform.system}.hello
        self.packages.${pkgs.stdenv.hostPlatform.system}.hello
      ];
    };
  };
}
</file>

<file path="template/multi-module/flake.nix">
{
  description = "Description for the project";

  inputs = {
    flake-parts.url = "github:hercules-ci/flake-parts";
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };

  outputs = inputs@{ flake-parts, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      imports = [
        ./hello/flake-module.nix
      ];
      systems = [ "x86_64-linux" "aarch64-darwin" ];
      perSystem = { config, self', inputs', ... }: {
        # Per-system attributes can be defined here. The self' and inputs'
        # module parameters provide easy access to attributes of the same
        # system.

        packages.figlet = inputs'.nixpkgs.legacyPackages.figlet;
      };
      flake = {
        # The usual flake attributes can be defined here, including system-
        # agnostic ones like nixosModule and system-enumerating ones, although
        # those are more easily expressed in perSystem.

      };
    };
}
</file>

<file path="template/package/hello/hello.sh">
#!@shell@

echo Hello world
</file>

<file path="template/package/hello/package.nix">
{ stdenv, lib, runtimeShell }:

let
  # Bring fileset functions into scope.
  # See https://nixos.org/manual/nixpkgs/stable/index.html#sec-functions-library-fileset
  inherit (lib.fileset) toSource unions;
in

# Example package in the style that `mkDerivation`-based packages in Nixpkgs are written.
stdenv.mkDerivation (finalAttrs: {
  name = "hello";
  src = toSource {
    root = ./.;
    fileset = unions [
      ./hello.sh
    ];
  };
  buildPhase = ''
    # Note that Nixpkgs has builder functions for simple packages
    # like this, but this template avoids it to make for a more
    # complete example.
    substitute hello.sh hello --replace '@shell@' ${runtimeShell}
    cat hello
    chmod a+x hello
  '';
  installPhase = ''
    install -D hello $out/bin/hello
  '';
})
</file>

<file path="template/package/hello/test.nix">
{ hello, runCommand }:

runCommand "test-hello"
{
  inherit hello;
} '' 
  (
    set -x
    [[ "Hello world" == "$(${hello}/bin/hello)" ]]
  )
  touch $out
''
</file>

<file path="template/package/flake.nix">
{
  description = "Description for the project";

  inputs = {
    flake-parts.url = "github:hercules-ci/flake-parts";
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };

  outputs = inputs@{ flake-parts, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [ "x86_64-linux" "aarch64-linux" "aarch64-darwin" "x86_64-darwin" ];
      perSystem = { config, pkgs, ... }: {
        packages.default = config.packages.hello;

        packages.hello = pkgs.callPackage ./hello/package.nix { };

        checks.hello = pkgs.callPackage ./hello/test.nix {
          hello = config.packages.hello;
        };
      };
    };
}
</file>

<file path="template/unfree/flake.nix">
{
  description = "Description for the project";

  inputs = {
    flake-parts.url = "github:hercules-ci/flake-parts";
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };

  outputs = inputs@{ flake-parts, nixpkgs, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [ "x86_64-linux" "aarch64-darwin" ];
      perSystem = { pkgs, system, ... }: {
        # This sets `pkgs` to a nixpkgs with allowUnfree option set.
        _module.args.pkgs = import nixpkgs {
          inherit system;
          config.allowUnfree = true;
        };

        packages.default = pkgs.hello-unfree;
      };
    };
}
</file>

<file path=".gitignore">
# nix
result
result-*

# pre-commit-hooks.nix
.pre-commit-config.yaml
</file>

<file path="all-modules.nix">
{
  imports = [
    ./modules/apps.nix
    ./modules/checks.nix
    ./modules/debug.nix
    ./modules/devShells.nix
    ./modules/flake.nix
    ./modules/formatter.nix
    ./modules/legacyPackages.nix
    ./modules/moduleWithSystem.nix
    ./modules/nixosConfigurations.nix
    ./modules/nixosModules.nix
    ./modules/nixpkgs.nix
    ./modules/overlays.nix
    ./modules/packages.nix
    ./modules/perSystem.nix
    ./modules/transposition.nix
    ./modules/withSystem.nix
  ];
}
</file>

<file path="bors.toml">
status = [
  "ci/hercules/onPush/default",
  "ci/hercules/evaluation",
]
delete_merged_branches = true
</file>

<file path="ChangeLog.md">
# 2023-05-30

 - Fix a strictness issue in `perInput`, affecting `inputs'`, `self'`.
   This has caused infinite recursions and potentially performance issues since
   the introduction of these module arguments.

# 2023-05-08

 - Add [`importApply`](https://flake.parts/define-module-in-separate-file.html?highlight=importApply#importApply) for bringing variables from the flake scope into module files.

 - Add `mkDeferredModuleOption` as a generic name for the implementation of `mkPerSystemOption`.

# 2023-03-26

 - Add preliminary support for `disabledModules` for modules exposed via the importable `flakeModules` module.
   This requires a Nixpkgs of 2023-03-09 or newer.

# 2023-01-05

 - Add importable `easyOverlay` module for defining an overlay "easily" by reusing `perSystem`.
   This is not for consuming overlays.

# 2022-12-25

 - Added a new `flake.flakeModules` option so a flake can expose a module
   to be used in a downstream flake's flake-parts usage. `.flakeModule` is
   now an alias for `.flakeModules.default`.

   Option only available if `flake-parts.flakeModules.flakeModules` is imported.

# 2022-12-17

 - The old syntax `mkFlake { inherit self; }` is now strongly discouraged in
 favor of:

   ```nix
   outputs = inputs@{ flake-parts, ... }:
     flake-parts.lib.mkFlake { inherit inputs; } { /* module */ }
   ```

   This fixes an infinite recursion that occurs with the old syntax when
   using the `inputs` module argument in `imports`.

   If you're under the impression that this already worked, that's probably
   because you were using `inputs` from the lexical scope (ie directly from
   the flake outputs function arguments), rather than in a separate module file.


# 2022-12-07

 - The `darwinModules` option has been removed. This was added in the early days
   without full consideration. The removal will have no effect on most flakes
   considering that the [`flake` option](https://flake.parts/options/flake-parts.html#opt-flake)
   allows any attribute to be set. This attribute and related attributes should
   be added to the nix-darwin project instead.

# 2022-10-11

 - The `nixpkgs` input has been renamed to `nixpkgs-lib` to signify that the
   only dependency is on the `lib` attribute, which can be provided by either
   the `nixpkgs?dir=lib` subflake or by the `nixpkgs` flake itself.

 - The templates now use the default, _fixed_ `nixpkgs?dir=lib` dependency instead
   of a _following_ `nixpkgs` dependency.

# 2022-05-25

 - `perSystem` is not a `functionTo submodule` anymore, but a `deferredModule`,
    which is a lot like a regular submodule, but possible to invoke multiple
    times, for each `system`.

    All `perSystem` value definitions must remove the `system: ` argument.
    If you need `system` to be in scope, use the one in the module arguments.

    ```diff
    -perSystem = system: { config, lib, ... }:
    +perSystem = { config, lib, system, ... }:
    ```

    All `perSystem` option declarations must now use `flake-parts-lib.mkPerSystemOption`.

    ```nix
    {
      options.perSystem = mkPerSystemOption ({ config, ... }: {
        options = {
          # ...
        };
        # ...
      });
    }
    ```

 - `flake-modules-core` is now called `flake-parts`.

 - `flake.overlay` has been removed in favor of `flake.overlays.default`.
</file>

<file path="CONTRIBUTING.md">
# How do I contribute?

Flake-parts is designed to be extremely modular, so often, you don't have to.

Nonetheless, some changes can only be made here.

Step 1. Look for an open or closed issue. This may be the quickest path to a solution to your problem.

Step 2. If needed, open an issue. This way we can discuss the problem, and if necessary discuss changes, if any need to be made.

Step 3. If needed, create a PR. Make sure to run `nix-shell` before comitting. It installs a pre-commit hook with `nixpkgs-fmt`.


# Style

This repository is written in a style similar to that of Nixpkgs, with some exceptions.
The following sections describe such additions, exceptions, and it probably confirms some rules.

## Rule #1. Go with the flow

Write code that fits in. Don't reformat existing code. Don't obsess over fitting in. Write good docs and tests instead.

## Camel case


 - File names may be in camelCase. This reduces the number of unique names in the project.

Except for file names, the Nixpkgs casing rule is maintained here as well:

 - Package names are verbatim or in snake-case. Example:
    - `flake-parts-lib`

 - Functionality provided by flake-parts is in camelCase. Examples:
    - `getSystem`
    - `mkFlake`

## Operators and such

- The "contains attribute" operator is spelled without spaces, just like the "select attribute" operator. I believe Nixpkgs is undecided on this.

  ```nix
  if x?a then x.a else "does not have a"
  #  ^^^
  ```

- `@` pattern goes before and uses no extra spaces.

  ```nix
  # immediately before parameter list when single line
  pair@{ name, value }:

  # newline after @ when multi-line
  pair@
  { name
  , value
  }
  ```
</file>

<file path="flake.lock">
{
  "nodes": {
    "nixpkgs-lib": {
      "locked": {
        "lastModified": 1754788789,
        "narHash": "sha256-x2rJ+Ovzq0sCMpgfgGaaqgBSwY+LST+WbZ6TytnT9Rk=",
        "owner": "nix-community",
        "repo": "nixpkgs.lib",
        "rev": "a73b9c743612e4244d865a2fdee11865283c04e6",
        "type": "github"
      },
      "original": {
        "owner": "nix-community",
        "repo": "nixpkgs.lib",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "nixpkgs-lib": "nixpkgs-lib"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  description = "Flake basics described using the module system";

  inputs = {
    nixpkgs-lib.url = "github:nix-community/nixpkgs.lib";
  };

  outputs = inputs@{ nixpkgs-lib, ... }:
    let
      lib = import ./lib.nix {
        inherit (nixpkgs-lib) lib;
        # Extra info for version check message
        revInfo =
          if nixpkgs-lib?rev
          then " (nixpkgs-lib.rev: ${nixpkgs-lib.rev})"
          else "";
      };
      templates = {
        default = {
          path = ./template/default;
          description = ''
            A minimal flake using flake-parts.
          '';
        };
        multi-module = {
          path = ./template/multi-module;
          description = ''
            A minimal flake using flake-parts.
          '';
        };
        unfree = {
          path = ./template/unfree;
          description = ''
            A minimal flake using flake-parts importing nixpkgs with the unfree option.
          '';
        };
        package = {
          path = ./template/package;
          description = ''
            A flake with a simple package:
            - Nixpkgs
            - callPackage
            - src with fileset
            - a check with runCommand
          '';
        };
      };
      flakeModules = {
        easyOverlay = ./extras/easyOverlay.nix;
        flakeModules = ./extras/flakeModules.nix;
        modules = ./extras/modules.nix;
        partitions = ./extras/partitions.nix;
        bundlers = ./extras/bundlers.nix;
      };
    in
    lib.mkFlake { inherit inputs; } {
      systems = [ ];
      imports = [ flakeModules.partitions ];
      partitionedAttrs.checks = "dev";
      partitionedAttrs.devShells = "dev";
      partitionedAttrs.herculesCI = "dev";
      partitions.dev.extraInputsFlake = ./dev;
      partitions.dev.module = {
        imports = [ ./dev/flake-module.nix ];
      };
      flake = {
        inherit lib templates flakeModules;
      };
    };

}
</file>

<file path="lib.nix">
{ lib
  # Optionally a string with extra version info to be included in the error message
  # in case is lib is out of date. Empty or starts with space.
, revInfo ? ""
}:
let
  inherit (lib)
    mkOption
    mkOptionType
    defaultFunctor
    isAttrs
    isFunction
    showOption
    throwIf
    types
    warnIf
    getAttrFromPath
    setAttrByPath
    attrByPath
    optionalAttrs
    ;
  inherit (lib.modules)
    mkAliasAndWrapDefsWithPriority;
  inherit (lib.types)
    path
    submoduleWith
    ;

  # Polyfill isFlake until Nix with https://github.com/NixOS/nix/pull/7207 is common
  isFlake = maybeFlake:
    if maybeFlake ? _type
    then maybeFlake._type == "flake"
    else maybeFlake ? inputs && maybeFlake ? outputs && maybeFlake ? sourceInfo;

  # Polyfill https://github.com/NixOS/nixpkgs/pull/163617
  deferredModuleWith = lib.deferredModuleWith or (
    attrs@{ staticModules ? [ ] }: mkOptionType {
      name = "deferredModule";
      description = "module";
      check = x: isAttrs x || isFunction x || path.check x;
      merge = loc: defs: staticModules ++ map (def: lib.setDefaultModuleLocation "${def.file}, via option ${showOption loc}" def.value) defs;
      inherit (submoduleWith { modules = staticModules; })
        getSubOptions
        getSubModules;
      substSubModules = m: deferredModuleWith (attrs // {
        staticModules = m;
      });
      functor = defaultFunctor "deferredModuleWith" // {
        type = deferredModuleWith;
        payload = {
          inherit staticModules;
        };
        binOp = lhs: rhs: {
          staticModules = lhs.staticModules ++ rhs.staticModules;
        };
      };
    }
  );

  errorExample = ''
    For example:

        outputs = inputs@{ flake-parts, ... }:
          flake-parts.lib.mkFlake { inherit inputs; } { /* module */ };

    To avoid an infinite recursion, *DO NOT* pass `self.inputs` and
    *DO NOT* pass `inherit (self) inputs`, but pass the output function
    arguments as `inputs` like above.
  '';

  flake-parts-lib = rec {
    evalFlakeModule =
      args@
      { inputs ? self.inputs
      , specialArgs ? { }

        # legacy
      , self ? inputs.self or (throw ''
          When invoking flake-parts, you must pass all the flake output arguments,
          and not just `self.inputs`.

          ${errorExample}
        '')
      , moduleLocation ? "${self.outPath}/flake.nix"
      }:
      let
        inputsPos = builtins.unsafeGetAttrPos "inputs" args;
        errorLocation =
          # Best case: user makes it explicit
          args.moduleLocation or (
            # Slightly worse: Nix does not technically commit to unsafeGetAttrPos semantics
            if inputsPos != null
            then inputsPos.file
            # Slightly worse: self may not be valid when an error occurs
            else if args?inputs.self.outPath
            then args.inputs.self.outPath + "/flake.nix"
            # Fallback
            else "<mkFlake argument>"
          );
      in
      throwIf
        (!args?self && !args?inputs) ''
        When invoking flake-parts, you must pass in the flake output arguments.

        ${errorExample}
      ''
        warnIf
        (!args?inputs) ''
        When invoking flake-parts, it is recommended to pass all the flake output
        arguments in the `inputs` parameter. If you only pass `self`, it's not
        possible to use the `inputs` module argument in the module `imports`.

        Please pass the output function arguments. ${errorExample}
      ''

        (module:
        lib.evalModules {
          specialArgs = {
            inherit self flake-parts-lib moduleLocation;
            inputs = args.inputs or /* legacy, warned above */ self.inputs;
          } // specialArgs;
          modules = [ ./all-modules.nix (lib.setDefaultModuleLocation errorLocation module) ];
          class = "flake";
        }
        );

    # Function to extract the default flakeModule from
    # what may be a flake, returning the argument unmodified
    # if it's not a flake.
    #
    # Useful to map over an 'imports' list to make it less
    # verbose in the common case.
    defaultModule = maybeFlake:
      if isFlake maybeFlake
      then maybeFlake.flakeModules.default or maybeFlake
      else maybeFlake;

    mkFlake = args: module:
      let
        eval = flake-parts-lib.evalFlakeModule args module;
      in
      eval.config.flake;

    # For extending options in an already declared submodule.
    # Workaround for https://github.com/NixOS/nixpkgs/issues/146882
    mkSubmoduleOptions =
      options:
      mkOption {
        type = types.submoduleWith {
          modules = [{ inherit options; }];
        };
      };

    mkDeferredModuleType =
      module:
      deferredModuleWith {
        staticModules = [ module ];
      };
    mkPerSystemType = mkDeferredModuleType;

    mkDeferredModuleOption =
      module:
      mkOption {
        type = flake-parts-lib.mkPerSystemType module;
      };
    mkPerSystemOption = mkDeferredModuleOption;

    # Helper function for defining a per-system option that
    # gets transposed by the usual flake system logic to a
    # top-level flake attribute.
    mkTransposedPerSystemModule = { name, option, file }: {
      _file = file;

      options = {
        flake = flake-parts-lib.mkSubmoduleOptions {
          ${name} = mkOption {
            type = types.attrsWith {
              elemType = option.type;
              lazy = true;
              placeholder = "system";
            };
            default = { };
            description = ''
              See {option}`perSystem.${name}` for description and examples.
            '';
          };
        };

        perSystem = flake-parts-lib.mkPerSystemOption {
          _file = file;

          options.${name} = option;
        };
      };

      config = {
        transposition.${name} = { };
      };
    };

    # Needed pending https://github.com/NixOS/nixpkgs/pull/198450
    mkAliasOptionModule = from: to: { config, options, ... }:
      let
        fromOpt = getAttrFromPath from options;
        toOf = attrByPath to
          (abort "Renaming error: option `${showOption to}' does not exist.");
        toType = let opt = attrByPath to { } options; in opt.type or (types.submodule { });
      in
      {
        options = setAttrByPath from (mkOption
          {
            visible = true;
            description = "Alias of {option}`${showOption to}`.";
            apply = x: (toOf config);
          } // optionalAttrs (toType != null) {
          type = toType;
        });
        config = mkAliasAndWrapDefsWithPriority (setAttrByPath to) fromOpt;
      };

    # Helper function for importing while preserving module location. To be added
    # in nixpkgs: https://github.com/NixOS/nixpkgs/pull/230588
    # I expect these functions to remain identical. This one will stick around
    # for a while to support older nixpkgs-lib.
    importApply =
      modulePath: staticArgs:
      lib.setDefaultModuleLocation modulePath (import modulePath staticArgs);

    inherit (import ./lib/memoize/memoize.nix {
      inherit lib;
    }) memoizeStr;

    /**
      `importAndPublish name module` returns a module that both imports the `module`, and exposes it as flake attribute `modules.flake.${name}`.

      This also imports the optional [`modules`](https://flake.parts/options/flake-parts-modules.html) module to support that.
    */
    importAndPublish = name: module: { lib, ... }: {
      _class = "flake";
      imports = [
        module
        ./extras/modules.nix
      ];
      flake.modules.flake.${name} = module;
    };
  };

  # A best effort, lenient estimate. Please use a recent nixpkgs lib if you
  # override it at all.
  minVersion = "22.05";

in

if builtins.compareVersions lib.version minVersion < 0
then
  abort ''
    The nixpkgs-lib dependency of flake-parts was overridden but is too old.
    The minimum supported version of nixpkgs-lib is ${minVersion},
    but the actual version is ${lib.version}${revInfo}.
  ''
else

  flake-parts-lib
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2021 Hercules CI

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# Flake Parts

_Core of a distributed framework for writing Nix Flakes._

`flake-parts` provides the options that represent standard flake attributes
and establishes a way of working with `system`.
Opinionated features are provided by an ecosystem of modules that you can import.

`flake-parts` _itself_ has the goal to be a minimal mirror of the Nix flake schema.
Used by itself, it is very lightweight.

> It is definitely the best Flake framework and it is simply out of this world!

—Pol Dellaiera ([source](https://not-a-number.io/2025/refactoring-my-infrastructure-as-code-configurations/#trade-offs))

---

**Documentation**: [flake.parts](https://flake.parts)

---

# Why Modules?

Flakes are configuration. The module system lets you refactor configuration
into modules that can be shared.

It reduces the proliferation of custom Nix glue code, similar to what the
module system has done for NixOS configurations.

Unlike NixOS, but following Flakes' spirit, `flake-parts` is not a
monorepo with the implied goal of absorbing all of open source, but rather
a single module that other repositories can build upon, while ensuring a
baseline level of compatibility: the core attributes that constitute a flake.

# Features

 - Split your `flake.nix` into focused units, each in their own file.

 - Take care of [system](https://flake.parts/system.html).

 - Allow users of your library flake to easily integrate your generated flake outputs
   into their flake.

 - Reuse project logic written by others

<!-- end_of_intro -->
<!-- ^^^^^^^^^^^^ used by https://github.com/hercules-ci/flake.parts-website -->

# Getting Started

If your project does not have a flake yet:

```console
nix flake init -t github:hercules-ci/flake-parts
```

# Migrate

Otherwise, add the input,

```nix
    flake-parts.url = "github:hercules-ci/flake-parts";
```

then slide `mkFlake` between your outputs function head and body,

```nix
  outputs = inputs@{ flake-parts, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      flake = {
        # Put your original flake attributes here.
      };
      systems = [
        # systems for which you want to build the `perSystem` attributes
        "x86_64-linux"
        # ...
      ];
    };
```

Now you can add the remaining module attributes like in the [the template](./template/default/flake.nix).

# Templates

See [the template](./template/default/flake.nix).

# Examples

See the [examples/](./examples) directory.

# Projects using flake-parts

- [nixd](https://github.com/nix-community/nixd/blob/main/flake.nix) (c++)
- [hyperswitch](https://github.com/juspay/hyperswitch/blob/main/flake.nix) (rust)
- [argo-workflows](https://github.com/argoproj/argo-workflows/blob/master/dev/nix/flake.nix) (go)
- [nlp-service](https://github.com/recap-utr/nlp-service/blob/main/flake.nix) (python)
- [emanote](https://github.com/srid/emanote/blob/master/flake.nix) (haskell)

# Options Reference

See [flake.parts options](https://flake.parts/options/flake-parts.html)
</file>

<file path="shell.nix">
(builtins.getFlake ("git+file://" + toString ./.)).devShells.${builtins.currentSystem}.default
</file>

</files>
