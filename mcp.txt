Perfect--here’s a drop-in setup for Augment (VS Code) + GitHub Spec Kit that auto-routes to the right MCP server:

⸻

1) Add both MCP servers to Augment

In Augment → Settings → MCP → Import from JSON, paste:

{
  "mcpServers": {
    "code-reasoning": {
      "command": "npx",
      "args": ["-y", "@mettamatt/code-reasoning"]
    },
    "mcp-reasoner": {
      "command": "node",
      "args": ["/ABSOLUTE/PATH/TO/mcp-reasoner/dist/index.js"]
    }
  }
}

	•	Augment supports "Import from JSON" and local command servers exactly like this.  ￼
	•	@mettamatt/code-reasoning is designed to be run with npx.  ￼
	•	mcp-reasoner ships a dist/index.js entry--point your node args there.  ￼

Tip: you can also configure remote HTTP/SSE MCP in Augment; not needed here.  ￼

⸻

2) Rules that auto-invoke the right server (drop these in your repo)

Create .augment/rules/00-mcp-routing.md (Always):

---
type: always_apply
---

## MCP Routing Strategy (Always)
- If the user prompt or current task involves **planning**, **architecture**, **trade-offs**, or any **/speckit.plan / /speckit.tasks / /speckit.clarify / /speckit.analyze** activity, prefer tools from **mcp-reasoner** and run structured search before proposing decisions.
- If the prompt involves **implementation, refactor, debugging, tests, or /speckit.implement**, prefer tools from **code-reasoning** to execute step-by-step code reasoning with branching and revision.
- Never run both servers in the same turn unless explicitly asked; choose one primary engine and summarize why.

Create .augment/rules/10-planning-with-mcp-reasoner.md (Auto):

---
type: agent_requested
description: "Planning & architecture & trade-offs; Spec Kit plan/tasks/clarify/analyze phases; large refactors; multi-path evaluation"
---

## Planning & Architecture Rule (MCP Reasoner)
When this rule is attached, prefer **mcp-reasoner** tools to explore multiple solution paths before committing:
- Start with **beam search** (e.g., beamWidth≈4) to surface competing approaches; if ambiguity remains, escalate to **MCTS** (e.g., numSimulations≈80–120) and explain the exploration outcome.
- Output should map directly to Spec Kit artifacts: update or propose `spec.md` (requirements), `plan.md` (architecture & decisions), and `tasks.md` (independent, testable tasks with dependencies).
- Produce a clear **decision record**: alternatives considered, criteria, chosen approach, risks, and fallback.
- Keep costs bounded: limit deep search passes unless the plan quality is still below "good enough".

Create .augment/rules/20-coding-with-code-reasoning.md (Auto):

---
type: agent_requested
description: "Implementation, refactor, debugging, tests; Spec Kit implement phase; code surgery; tight feedback loops"
---

## Implementation Rule (Code Reasoning)
When this rule is attached, prefer **code-reasoning** tools to execute code changes with structured steps:
- Do a quick read of `plan.md` and `tasks.md`; confirm scope & acceptance criteria.
- Use **thought branching & revision** to propose the minimal, correct change; stop after ~20 steps or sooner if done.
- Always produce: patch (diff), updated tests, and a short rationale linked back to tasks.
- If a task seems underspecified, bounce once to **mcp-reasoner** to refine just that task, then resume coding here.

Why this works in Augment: rules live in .augment/rules/ and can be Always or Auto; Auto rules attach based on the description field and context. You can also manage rules from Settings → User Guidelines and Rules.  ￼

⸻

3) How this maps to Spec Kit

Use Spec Kit’s phases/commands and let the rules do the routing:
	•	/speckit.plan, /speckit.tasks, /speckit.clarify, /speckit.analyze → Auto-attach Planning Rule → mcp-reasoner (beam→MCTS).  ￼
	•	/speckit.implement → Auto-attach Implementation Rule → code-reasoning (branch/revise; safety-capped steps).  ￼

Spec Kit’s README documents these commands and the plan→tasks→implement flow.  ￼

⸻

4) Optional: VS Code workspace MCP (non-Augment fallback)

If you also want a repo-local MCP for other clients, add .vscode/mcp.json:

{
  "servers": {
    "code-reasoning": { "command": "npx", "args": ["-y", "@mettamatt/code-reasoning"] },
    "mcp-reasoner":   { "command": "node", "args": ["/ABSOLUTE/PATH/TO/mcp-reasoner/dist/index.js"] }
  }
}

This is the VS Code MCP format (separate from Augment’s importer).  ￼

⸻

Quick sanity checks
	•	In Augment, confirm both servers appear under Settings → MCP and can be test-started.  ￼
	•	Kick off planning with: "/speckit.plan …" and watch Augment auto-attach the Planning rule (you’ll see it listed). Then implement with "/speckit.implement" and verify the Implementation rule attaches.  ￼

If you want, I can compress those three rule files into a single router.md--but keeping them separate tends to be easier to tune (you like tight, testable levers).