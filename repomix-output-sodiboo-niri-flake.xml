This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    cachix.yml
    check.yml
    update.yml
  mergify.yml
.envrc
.gitattributes
.gitignore
default-config.kdl.nix
docs.md
fetch-refs.nix
flake.lock
flake.nix
generate-docs.nix
generate-html-docs.nix
justfile
kdl.nix
LICENSE
memo-binds.nix
parse-binds.nix
post-commit
pre-commit
README.md
refs.nix
settings.nix
shell.nix
stylix.nix
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/cachix.yml">
name: "cachix"
on:
  push:
  pull_request:
jobs:
  nixos-unstable:
    name: build
    runs-on: ubuntu-latest
    steps:
    - name: Free Disk Space (Ubuntu)
      uses: jlumbroso/free-disk-space@v1.3.1
    - uses: actions/checkout@v4
    - uses: cachix/install-nix-action@v31
      with:
        nix_path: nixpkgs=channel:nixos-unstable
    - uses: cachix/cachix-action@v14
      with:
        name: niri
        authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'
    - name: Build packages and push to cachix
      run: nix build .#checks.x86_64-linux.cached-packages
</file>

<file path=".github/workflows/check.yml">
name: "check"
on:
  push:
  pull_request:
jobs:
  fmt:
    name: "nix fmt"
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: cachix/install-nix-action@v31
      with:
        nix_path: nixpkgs=channel:nixos-unstable
    - run: nix fmt $(find ./ -regex './[^.]*\.nix') -- --check
  check:
    name: "nix flake check"
    runs-on: ubuntu-latest
    steps:
    - name: Free Disk Space (Ubuntu)
      uses: jlumbroso/free-disk-space@v1.3.1
    - uses: actions/checkout@v4
    - uses: cachix/install-nix-action@v31
      with:
        nix_path: nixpkgs=channel:nixos-unstable
    - uses: cachix/cachix-action@v14
      with:
        name: niri
    - run: nix flake check
  check-docs:
    name: "generated docs match"
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: cachix/install-nix-action@v31
      with:
        nix_path: nixpkgs=channel:nixos-unstable
    - uses: cachix/cachix-action@v14
      with:
        name: niri
    - run: |
        # note: docs really do exceed the default call depth limit. as a workaround, increase it.
        export NIX_CONFIG="max-call-depth = 20000"

        nix eval --raw .#lib.internal.docs-markdown > docs.fresh.md

        # this to print the full docs in the logs so we can easier see what's going on
        cat docs.fresh.md
        cat docs.md

        diff docs.md docs.fresh.md
</file>

<file path=".github/workflows/update.yml">
name: Update flake.lock
on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *' # Hourly. We want it to run frequently.

jobs:
  lockfile:
    runs-on: ubuntu-latest
    steps:
      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v16
      - uses: cachix/cachix-action@v14
        with:
          name: niri
          authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'
      - name: Update flake.lock
        id: update
        uses: DeterminateSystems/update-flake-lock@v23
        with:
          commit-msg: "Update flake.lock"
          pr-title: "Update flake.lock"
          pr-body: |
            ```
            {{ env.GIT_COMMIT_MESSAGE }}
            ```

            sodiboo will now force-push my branch in order for the cachix action to run. This is also an automated action.
          pr-labels: |
            dependencies
            automated


        # This is workaround to force the cachix action to run after the update-flake-lock action.
        # Normally, it does not occur because the PR is created by github-actions[bot]
        # But here, we force push it with my own token, so the action runs after a push "by me".
      - name: Checkout repository as sodiboo
        if: ${{ steps.update.outputs.pull-request-number }}
        uses: actions/checkout@v4
        with:
            token: '${{ secrets.UPDATE_TOKEN }}'
      - name: Checkout CI branch
        run: git checkout update_flake_lock_action
        if: ${{ steps.update.outputs.pull-request-number }}


      - name: Build niri-unstable ahead of time
        run: nix-store --query --requisites $(nix-store --query --deriver $(nix build --print-out-paths .#niri-unstable)) | cachix push niri
        if: ${{ steps.update.outputs.pull-request-number }}

      - name: Amend commit with human committer; ensure CI will run
        run: git commit --amend --no-edit
        if: ${{ steps.update.outputs.pull-request-number }}
      - name: Update docs via post-commit
        run: bash ./post-commit
        if: ${{ steps.update.outputs.pull-request-number }}
      - name: Force push changes to CI branch
        run: git push origin update_flake_lock_action --force
        if: ${{ steps.update.outputs.pull-request-number }}
</file>

<file path=".github/mergify.yml">
pull_request_rules:
  - name: "merge when finished building"
    conditions:
      - "author=github-actions[bot]"
    actions:
      merge:
        method: rebase
</file>

<file path=".envrc">
use nix
</file>

<file path=".gitattributes">
# This file is generated entirely from documentation already included in nix files. Changes to such documentation does need to show up twice in diffs.
docs.md linguist-generated
</file>

<file path=".gitignore">
.direnv
result*
</file>

<file path="default-config.kdl.nix">
# This config is structured as KDL.
# This means, that the document is a tree of nodes.
#
# At the top of the config is a list of nodes. Each node has:
# - exactly one name, which is a string
# - zero or more ordered arguments, which are scalars
# - zero or more unordered properties, which are attrsets of scalars
# - zero or more ordered children, which are nodes
#
# KDL also permits "type names", but niri does not use them.
#
# Scalars are strings, integers, floats, booleans, or null.
#
# This default config uses the kdl library from https://github.com/sodiboo/niri-flake/blob/main/kdl.nix.
# It provides a set of functions to declare KDL documents.
#
# The fundamental function is `kdl.node`, which takes a name, a list of arguments, and a list of children.
# To declare properties, you should pass an attrset to `kdl.node` as the last argument.
#
# For your convenience, the following transformations are applied to the given parameters:
#
# - The arguments, if not a list, are wrapped in a list.
#   - This means that you can pass a single argument without wrapping it in a list.
#   - You can also pass properties directly, if there are no arguments.
#
# - The children are flattened, and any nulls are removed.
#   - This means that you can call functions directly in the children list.
#   - You can also create "conditional" nodes by setting them to null.
#   - You can see this feature used to the fullest at https://github.com/sodiboo/niri-flake/blob/main/settings.nix
#   - This transformation is also applied at the top-level.
#
# Additionally, kdl.nix provides some shorthand functions to omit the arguments list, children list, or both:
# - `kdl.plain` for nodes with no arguments
# - `kdl.leaf` for nodes with no children
# - `kdl.flag` for nodes with no arguments or children
#
# With that out of the way, here's the nixfied default config for niri.

inputs: # This is your flake inputs. It contains the `niri` flake (github:sodiboo/niri)

# This is a home-manager module.
{
  pkgs,
  config,
  lib,
  ...
}: let
  inherit (inputs.niri.lib.kdl) node plain leaf flag;
in {
  programs.niri.config = [
    (plain "input" [
      (plain "keyboard" [
        (plain "xkb" [
          # You can set rules, model, layout, variant and options.
          # For more information, see xkeyboard-config(7).

          # For example:
          # (leaf "layout" "us,ru")
          # (leaf "options" "grp:win_space_toggle,compose:ralt,ctrl:nocaps")
        ])

        # You can set the keyboard repeat parameters. The defaults match wlroots and sway.
        # Delay is in milliseconds before the repeat starts. Rate is in characters per second.
        # (leaf "repeat-delay" 600)
        # (leaf "repeat-rate" 25)

        # Niri can remember the keyboard layout globally (the default) or per-window.
        # - "global" - layout change is global for all windows.
        # - "window" - layout is tracked for each window individually.
        # (leaf "track-layout" "global")
      ])

      # Next sections include libinput settings.
      # Omitting settings disables them, or leaves them at their default values.
      (plain "touchpad" [
        (flag "tap")
        # (flag "dwt")
        # (flag "dwtp")
        (flag "natural-scroll")
        # (leaf "accel-speed" 0.2)
        # (leaf "accel-profile" "flat")
        # (leaf "tap-button-map" "left-middle-right")
      ])

      (plain "mouse" [
        # (flag "natural-scroll")
        # (leaf "accel-speed" 0.2)
        # (leaf "accel-profile" "flat")
      ])

      (plain "trackpoint" [
        # (flag "natural-scroll")
        # (leaf "accel-speed" 0.2)
        # (leaf "accel-profile" "flat")
      ])

      (plain "tablet" [
        # Set the name of the output (see below) which the tablet will map to.
        # If this is unset or the output doesn't exist, the tablet maps to one of the
        # existing outputs.
        (leaf "map-to-output" "eDP-1")
      ])

      (plain "touch" [
        # Set the name of the output (see below) which touch input will map to.
        # If this is unset or the output doesn't exist, touch input maps to one of the
        # existing outputs.
        (leaf "map-to-output" "eDP-1")
      ])

      # By default, niri will take over the power button to make it sleep
      # instead of power off.
      # Uncomment this if you would like to configure the power button elsewhere
      # (i.e. logind.conf).
      # (flag "disable-power-key-handling")
    ])

    # You can configure outputs by their name, which you can find
    # by running `niri msg outputs` while inside a niri instance.
    # The built-in laptop monitor is usually called "eDP-1".
    (node "output" "eDP-1" [
      # Uncomment this line to disable this output.
      # (flag "off")

      # Scale is a floating-point number, but at the moment only integer values work.
      (leaf "scale" 2.0)

      # Transform allows to rotate the output counter-clockwise, valid values are:
      # normal, 90, 180, 270, flipped, flipped-90, flipped-180 and flipped-270.
      (leaf "transform" "normal")

      # Resolution and, optionally, refresh rate of the output.
      # The format is "<width>x<height>" or "<width>x<height>@<refresh rate>".
      # If the refresh rate is omitted, niri will pick the highest refresh rate
      # for the resolution.
      # If the mode is omitted altogether or is invalid, niri will pick one automatically.
      # Run `niri msg outputs` while inside a niri instance to list all outputs and their modes.
      (leaf "mode" "1920x1080@120.030")

      # Position of the output in the global coordinate space.
      # This affects directional monitor actions like "focus-monitor-left", and cursor movement.
      # The cursor can only move between directly adjacent outputs.
      # Output scale has to be taken into account for positioning:
      # outputs are sized in logical, or scaled, pixels.
      # For example, a 3840×2160 output with scale 2.0 will have a logical size of 1920×1080,
      # so to put another output directly adjacent to it on the right, set its x to 1920.
      # It the position is unset or results in an overlap, the output is instead placed
      # automatically.
      (leaf "position" { x=1280; y=0; })
    ])

    (plain "layout" [
      # By default focus ring and border are rendered as a solid background rectangle
      # behind windows. That is, they will show up through semitransparent windows.
      # This is because windows using client-side decorations can have an arbitrary shape.
      #
      # If you don't like that, you should uncomment `prefer-no-csd` below.
      # Niri will draw focus ring and border *around* windows that agree to omit their
      # client-side decorations.

      # You can change how the focus ring looks.
      (plain "focus-ring" [
        # Uncomment this line to disable the focus ring.
        # (flag "off")

        # How many logical pixels the ring extends out from the windows.
        (leaf "width" 4)

        # Colors can be set in a variety of ways:
        # - CSS named colors: "red"
        # - RGB hex: "#rgb", "#rgba", "#rrggbb", "#rrggbbaa"
        # - CSS-like notation: "rgb(255, 127, 0)", rgba(), hsl() and a few others.

        # Color of the ring on the active monitor.
        (leaf "active-color" "#7fc8ff")

        # Color of the ring on inactive monitors.
        (leaf "inactive-color" "#505050")

        # Additionally, there's a legacy RGBA syntax:
        # (leaf "active-color" [ 127 200 255 255 ])

        # You can also use gradients. They take precedence over solid colors.
        # Gradients are rendered the same as CSS linear-gradient(angle, from, to).
        # The angle is the same as in linear-gradient, and is optional,
        # defaulting to 180 (top-to-bottom gradient).
        # You can use any CSS linear-gradient tool on the web to set these up.
        #
        # (leaf "active-gradient" { from="#80c8ff"; to="#bbddff"; angle=45; })

        # You can also color the gradient relative to the entire view
        # of the workspace, rather than relative to just the window itself.
        # To do that, set relative-to="workspace-view";
        #
        # (leaf "inactive-gradient" { from="#505050"; to="#808080"; angle=45; relative-to="workspace-view"; })
      ])

      # You can also add a border. It's similar to the focus ring, but always visible.
      (plain "border" [
        # The settings are the same as for the focus ring.
        # If you enable the border, you probably want to disable the focus ring.
        (flag "off")

        (leaf "width" 4)
        (leaf "active-color" "#ffc87f")
        (leaf "inactive-color" "#505050")

        # (leaf "active-gradient" { from="#ffbb66"; to="#ffc880"; angle=45; relative-to="workspace-view"; })
        # (leaf "inactive-gradient" { from="#505050"; to="#808080"; angle=45; relative-to="workspace-view"; })
      ])

      # You can customize the widths that "switch-preset-column-width" (Mod+R) toggles between.
      (plain "preset-column-widths" [
        # Proportion sets the width as a fraction of the output width, taking gaps into account.
        # For example, you can perfectly fit four windows sized "proportion 0.25" on an output.
        # The default preset widths are 1/3, 1/2 and 2/3 of the output.
        (leaf "proportion" (1.0 / 3.0))
        (leaf "proportion" (1.0 / 2.0))
        (leaf "proportion" (2.0 / 3.0))

        # Fixed sets the width in logical pixels exactly.
        # (leaf "fixed" 1920)
      ])

      # You can change the default width of the new windows.
      (plain "default-column-width" [
        (leaf "proportion" 0.5)
      ])
      # If you leave the children empty, the windows themselves will decide their initial width.
      # (plain "default-column-width" [])

      # Set gaps around windows in logical pixels.
      (leaf "gaps" 16)

      # Struts shrink the area occupied by windows, similarly to layer-shell panels.
      # You can think of them as a kind of outer gaps. They are set in logical pixels.
      # Left and right struts will cause the next window to the side to always be visible.
      # Top and bottom struts will simply add outer gaps in addition to the area occupied by
      # layer-shell panels and regular gaps.
      (plain "struts" [
        # (leaf "left" 64)
        # (leaf "right" 64)
        # (leaf "top" 64)
        # (leaf "bottom" 64)
      ])

      # When to center a column when changing focus, options are:
      # - "never", default behavior, focusing an off-screen column will keep at the left
      #   or right edge of the screen.
      # - "on-overflow", focusing a column will center it if it doesn't fit
      #   together with the previously focused column.
      # - "always", the focused column will always be centered.
      (leaf "center-focused-column" "never")
    ])

    # Add lines like this to spawn processes at startup.
    # Note that running niri as a session supports xdg-desktop-autostart,
    # which may be more convenient to use.
    # (leaf "spawn-at-startup" [ "alacritty" "-e" "fish" ])

    # You can override environment variables for processes spawned by niri.
    (plain "environment" [
      # Set a variable like this:
      # (leaf "QT_QPA_PLATFORM" "wayland")

      # Remove a variable by using null as the value:
      # (leaf "DISPLAY" null)
    ])

    (plain "cursor" [
      # Change the theme and size of the cursor as well as set the
      # `XCURSOR_THEME` and `XCURSOR_SIZE` env variables.
      # (leaf "xcursor-theme" "default")
      # (leaf "xcursor-size" 24)
    ])

    # Uncomment this line to ask the clients to omit their client-side decorations if possible.
    # If the client will specifically ask for CSD, the request will be honored.
    # Additionally, clients will be informed that they are tiled, removing some rounded corners.
    # (flag "prefer-no-csd")

    # You can change the path where screenshots are saved.
    # A ~ at the front will be expanded to the home directory.
    # The path is formatted with strftime(3) to give you the screenshot date and time.
    (leaf "screenshot-path" "~/Pictures/Screenshots/Screenshot from %Y-%m-%d %H-%M-%S.png")

    # You can also set this to null to disable saving screenshots to disk.
    # (leaf "screenshot-path" null)

    # Settings for the "Important Hotkeys" overlay.
    (plain "hotkey-overlay" [
      # Uncomment this line if you don't want to see the hotkey help at niri startup.
      # (flag "skip-at-startup")
    ])

    # Animation settings.
    (plain "animations" [
      # Uncomment to turn off all animations.
      # (flag "off")

      # Slow down all animations by this factor. Values below 1 speed them up instead.
      # (leaf "slowdown" 3.0)

      # You can configure all individual animations.
      # Available settings are the same for all of them.
      # - off disables the animation.
      #
      # Niri supports two animation types: easing and spring.
      # You can set properties for only ONE of them.
      #
      # Easing has the following settings:
      # - duration-ms sets the duration of the animation in milliseconds.
      # - curve sets the easing curve. Currently, available curves
      #   are "ease-out-cubic" and "ease-out-expo".
      #
      # Spring animations work better with touchpad gestures, because they
      # take into account the velocity of your fingers as you release the swipe.
      # The parameters are less obvious and generally should be tuned
      # with trial and error. Notably, you cannot directly set the duration.
      # You can use this app to help visualize how the spring parameters
      # change the animation: https://flathub.org/apps/app.drey.Elastic
      #
      # A spring animation is configured like this:
      # - (leaf "spring" { damping-ratio=1.0; stiffness=1000; epsilon=0.0001; })
      #
      # The damping ratio goes from 0.1 to 10.0 and has the following properties:
      # - below 1.0: underdamped spring, will oscillate in the end.
      # - above 1.0: overdamped spring, won't oscillate.
      # - 1.0: critically damped spring, comes to rest in minimum possible time
      #    without oscillations.
      #
      # However, even with damping ratio = 1.0 the spring animation may oscillate
      # if "launched" with enough velocity from a touchpad swipe.
      #
      # Lower stiffness will result in a slower animation more prone to oscillation.
      #
      # Set epsilon to a lower value if the animation "jumps" in the end.
      #
      # The spring mass is hardcoded to 1.0 and cannot be changed. Instead, change
      # stiffness proportionally. E.g. increasing mass by 2x is the same as
      # decreasing stiffness by 2x.

      # Animation when switching workspaces up and down,
      # including after the touchpad gesture.
      (plain "workspace-switch" [
        # (flag "off")
        # (leaf "spring" { damping-ratio=1.0; stiffness=1000; epsilon=0.0001; })
      ])

      # All horizontal camera view movement:
      # - When a window off-screen is focused and the camera scrolls to it.
      # - When a new window appears off-screen and the camera scrolls to it.
      # - When a window resizes bigger and the camera scrolls to show it in full.
      # - And so on.
      (plain "horizontal-view-movement" [
        # (flag "off")
        # (leaf "spring" { damping-ratio=1.0; stiffness=800; epsilon=0.0001; })
      ])

      # Window opening animation. Note that this one has different defaults.
      (plain "window-open" [
        # (flag "off")
        # (leaf "duration-ms" 150)
        # (leaf "curve" "ease-out-expo")

        # Example for a slightly bouncy window opening:
        # (leaf "spring" { damping-ratio=0.8; stiffness=1000; epsilon=0.0001; })
      ])

      # Config parse error and new default config creation notification
      # open/close animation.
      (plain "config-notification-open-close" [
        # (flag "off")
        # (leaf "spring" { damping-ratio=0.6; stiffness=1000; epsilon=0.001; })
      ])
    ])

    # Window rules let you adjust behavior for individual windows.
    # They are processed in order of appearance in this file.
    (plain "window-rule" [
      # Match directives control which windows this rule will apply to.
      # You can match by app-id and by title.
      # The window must match all properties of the match directive.
      (leaf "match" { app-id="org.myapp.MyApp"; title="My Cool App"; })

      # There can be multiple match directives. A window must match any one
      # of the rule's match directives.
      #
      # If there are no match directives, any window will match the rule.
      (leaf "match" { title="Second App"; })

      # You can also add exclude directives which have the same properties.
      # If a window matches any exclude directive, it won't match this rule.
      #
      # Both app-id and title are regular expressions.
      # Literal nix strings can be helpful here.
      (leaf "exclude" { app-id=''\.unwanted\.''; })

      # Here are the properties that you can set on a window rule.
      # You can override the default column width.
      (plain "default-column-width" [
        (leaf "proportion" 0.75)
      ])

      # You can set the output that this window will initially open on.
      # If such an output does not exist, it will open on the currently
      # focused output as usual.
      (leaf "open-on-output" "eDP-1")

      # Make this window open as a maximized column.
      (leaf "open-maximized" true)

      # Make this window open fullscreen.
      (leaf "open-fullscreen" true)
      # You can also set this to false to prevent a window from opening fullscreen.
      # (leaf "open-fullscreen" false)
    ])

    # Here's a useful example. Work around WezTerm's initial configure bug
    # by setting an empty default-column-width.
    (plain "window-rule" [
      # This regular expression is intentionally made as specific as possible,
      # since this is the default config, and we want no false positives.
      # You can get away with just app-id="wezterm" if you want.
      # The regular expression can match anywhere in the string.
      (leaf "match" { app-id=''^org\.wezfurlong\.wezterm$''; })
      (plain "default-column-width" [])
    ])

    (plain "binds" [
      # Keys consist of modifiers separated by + signs, followed by an XKB key name
      # in the end. To find an XKB name for a particular key, you may use a program
      # like wev.
      #
      # "Mod" is a special modifier equal to Super when running on a TTY, and to Alt
      # when running as a winit window.
      #
      # Most actions that you can bind here can also be invoked programmatically with
      # `niri msg action do-something`.

      # Mod-Shift-/, which is usually the same as Mod-?,
      # shows a list of important hotkeys.
      (plain "Mod+Shift+Slash" [(flag "show-hotkey-overlay")])

      # Suggested binds for running programs: terminal, app launcher, screen locker.
      (plain "Mod+T" [(leaf "spawn" ["alacritty"])])
      (plain "Mod+D" [(leaf "spawn" ["fuzzel"])])
      (plain "Super+Alt+L" [(leaf "spawn" ["swaylock"])])

      # You can also use a shell:
      # (plain "Mod+T" [(leaf "spawn" [ "bash" "-c" "notify-send hello && exec alacritty" ])])

      # Example volume keys mappings for PipeWire & WirePlumber.
      (plain "XF86AudioRaiseVolume" [(leaf "spawn" ["wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1+"])])
      (plain "XF86AudioLowerVolume" [(leaf "spawn" ["wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1-"])])

      (plain "Mod+Q" [(flag "close-window")])

      (plain "Mod+Left"   [(flag "focus-column-left")])
      (plain "Mod+Down"   [(flag "focus-window-down")])
      (plain "Mod+Up"     [(flag "focus-window-up")])
      (plain "Mod+Right"  [(flag "focus-column-right")])
      (plain "Mod+H"      [(flag "focus-column-left")])
      (plain "Mod+J"      [(flag "focus-window-down")])
      (plain "Mod+K"      [(flag "focus-window-up")])
      (plain "Mod+L"      [(flag "focus-column-right")])

      (plain "Mod+Ctrl+Left"  [(flag "move-column-left")])
      (plain "Mod+Ctrl+Down"  [(flag "move-window-down")])
      (plain "Mod+Ctrl+Up"    [(flag "move-window-up")])
      (plain "Mod+Ctrl+Right" [(flag "move-column-right")])
      (plain "Mod+Ctrl+H"     [(flag "move-column-left")])
      (plain "Mod+Ctrl+J"     [(flag "move-window-down")])
      (plain "Mod+Ctrl+K"     [(flag "move-window-up")])
      (plain "Mod+Ctrl+L"     [(flag "move-column-right")])

      # Alternative commands that move across workspaces when reaching
      # the first or last window in a column.
      # (plain "Mod+J"      [(flag "focus-window-or-workspace-down")])
      # (plain "Mod+K"      [(flag "focus-window-or-workspace-up")])
      # (plain "Mod+Ctrl+J" [(flag "move-window-down-or-to-workspace-down")])
      # (plain "Mod+Ctrl+K" [(flag "move-window-up-or-to-workspace-up")])

      (plain "Mod+Home"       [(flag "focus-column-first")])
      (plain "Mod+End"        [(flag "focus-column-last")])
      (plain "Mod+Ctrl+Home"  [(flag "move-column-to-first")])
      (plain "Mod+Ctrl+End"   [(flag "move-column-to-last")])

      (plain "Mod+Shift+Left"   [(flag "focus-monitor-left")])
      (plain "Mod+Shift+Down"   [(flag "focus-monitor-down")])
      (plain "Mod+Shift+Up"     [(flag "focus-monitor-up")])
      (plain "Mod+Shift+Right"  [(flag "focus-monitor-right")])
      (plain "Mod+Shift+H"      [(flag "focus-monitor-left")])
      (plain "Mod+Shift+J"      [(flag "focus-monitor-down")])
      (plain "Mod+Shift+K"      [(flag "focus-monitor-up")])
      (plain "Mod+Shift+L"      [(flag "focus-monitor-right")])

      (plain "Mod+Shift+Ctrl+Left"  [(flag "move-column-to-monitor-left")])
      (plain "Mod+Shift+Ctrl+Down"  [(flag "move-column-to-monitor-down")])
      (plain "Mod+Shift+Ctrl+Up"    [(flag "move-column-to-monitor-up")])
      (plain "Mod+Shift+Ctrl+Right" [(flag "move-column-to-monitor-right")])
      (plain "Mod+Shift+Ctrl+H"     [(flag "move-column-to-monitor-left")])
      (plain "Mod+Shift+Ctrl+J"     [(flag "move-column-to-monitor-down")])
      (plain "Mod+Shift+Ctrl+K"     [(flag "move-column-to-monitor-up")])
      (plain "Mod+Shift+Ctrl+L"     [(flag "move-column-to-monitor-right")])

      # Alternatively, there are commands to move just a single window:
      # (plain "Mod+Shift+Ctrl+Left" [(flag "move-window-to-monitor-left")])
      # ...

      # And you can also move a whole workspace to another monitor:
      # (plain "Mod+Shift+Ctrl+Left" [(flag "move-workspace-to-monitor-left")])
      # ...

      (plain "Mod+Page_Down"      [(flag "focus-workspace-down")])
      (plain "Mod+Page_Up"        [(flag "focus-workspace-up")])
      (plain "Mod+U"              [(flag "focus-workspace-down")])
      (plain "Mod+I"              [(flag "focus-workspace-up")])
      (plain "Mod+Ctrl+Page_Down" [(flag "move-column-to-workspace-down")])
      (plain "Mod+Ctrl+Page_Up"   [(flag "move-column-to-workspace-up")])
      (plain "Mod+Ctrl+U"         [(flag "move-column-to-workspace-down")])
      (plain "Mod+Ctrl+I"         [(flag "move-column-to-workspace-up")])

      # Alternatively, there are commands to move just a single window:
      # (plain "Mod+Ctrl+Page_Down" [(flag "move-window-to-workspace-down")])
      # ...

      (plain "Mod+Shift+Page_Down"  [(flag "move-workspace-down")])
      (plain "Mod+Shift+Page_Up"    [(flag "move-workspace-up")])
      (plain "Mod+Shift+U"          [(flag "move-workspace-down")])
      (plain "Mod+Shift+I"          [(flag "move-workspace-up")])

      # You can refer to workspaces by index. However, keep in mind that
      # niri is a dynamic workspace system, so these commands are kind of
      # "best effort". Trying to refer to a workspace index bigger than
      # the current workspace count will instead refer to the bottommost
      # (empty) workspace.
      #
      # For example, with 2 workspaces + 1 empty, indices 3, 4, 5 and so on
      # will all refer to the 3rd workspace.
      (plain "Mod+1" [(leaf "focus-workspace" 1)])
      (plain "Mod+2" [(leaf "focus-workspace" 2)])
      (plain "Mod+3" [(leaf "focus-workspace" 3)])
      (plain "Mod+4" [(leaf "focus-workspace" 4)])
      (plain "Mod+5" [(leaf "focus-workspace" 5)])
      (plain "Mod+6" [(leaf "focus-workspace" 6)])
      (plain "Mod+7" [(leaf "focus-workspace" 7)])
      (plain "Mod+8" [(leaf "focus-workspace" 8)])
      (plain "Mod+9" [(leaf "focus-workspace" 9)])
      (plain "Mod+Ctrl+1" [(leaf "move-column-to-workspace" 1)])
      (plain "Mod+Ctrl+2" [(leaf "move-column-to-workspace" 2)])
      (plain "Mod+Ctrl+3" [(leaf "move-column-to-workspace" 3)])
      (plain "Mod+Ctrl+4" [(leaf "move-column-to-workspace" 4)])
      (plain "Mod+Ctrl+5" [(leaf "move-column-to-workspace" 5)])
      (plain "Mod+Ctrl+6" [(leaf "move-column-to-workspace" 6)])
      (plain "Mod+Ctrl+7" [(leaf "move-column-to-workspace" 7)])
      (plain "Mod+Ctrl+8" [(leaf "move-column-to-workspace" 8)])
      (plain "Mod+Ctrl+9" [(leaf "move-column-to-workspace" 9)])

      # Alternatively, there are commands to move just a single window:
      # (plain "Mod+Ctrl+1" [(leaf "move-window-to-workspace" 1)])

      (plain "Mod+Comma"  [(flag "consume-window-into-column")])
      (plain "Mod+Period" [(flag "expel-window-from-column")])

      # There are also commands that consume or expel a single window to the side.
      # (plain "Mod+BracketLeft"  [(flag "consume-or-expel-window-left")])
      # (plain "Mod+BracketRight" [(flag "consume-or-expel-window-right")])

      (plain "Mod+R" [(flag "switch-preset-column-width")])
      (plain "Mod+F" [(flag "maximize-column")])
      (plain "Mod+Shift+F" [(flag "fullscreen-window")])
      (plain "Mod+C" [(flag "center-column")])

      # Finer width adjustments.
      # This command can also:
      # * set width in pixels: "1000"
      # * adjust width in pixels: "-5" or "+5"
      # * set width as a percentage of screen width: "25%"
      # * adjust width as a percentage of screen width: "-10%" or "+10%"
      # Pixel sizes use logical, or scaled, pixels. I.e. on an output with scale 2.0,
      # (leaf "set-column-width" "100") will make the column occupy 200 physical screen pixels.
      (plain "Mod+Minus" [(leaf "set-column-width" "-10%")])
      (plain "Mod+Equal" [(leaf "set-column-width" "+10%")])

      # Finer height adjustments when in column with other windows.
      (plain "Mod+Shift+Minus" [(leaf "set-window-height" "-10%")])
      (plain "Mod+Shift+Equal" [(leaf "set-window-height" "+10%")])

      # Actions to switch layouts.
      # Note: if you uncomment these, make sure you do NOT have
      # a matching layout switch hotkey configured in xkb options above.
      # Having both at once on the same hotkey will break the switching,
      # since it will switch twice upon pressing the hotkey (once by xkb, once by niri).
      # (plain "Mod+Space"       [(leaf "switch-layout" "next")])
      # (plain "Mod+Shift+Space" [(leaf "switch-layout" "prev")])

      (plain "Print" [(flag "screenshot")])
      (plain "Ctrl+Print" [(flag "screenshot-screen")])
      (plain "Alt+Print" [(flag "screenshot-window")])

      # The quit action will show a confirmation dialog to avoid accidental exits.
      # If you want to skip the confirmation dialog, set the flag like so:
      # (plain "Mod+Shift+E" [(leaf "quit" { skip-confirmation=true; })])
      (plain "Mod+Shift+E" [(flag "quit")])

      (plain "Mod+Shift+P" [(flag "power-off-monitors")])

      # This debug bind will tint all surfaces green, unless they are being
      # directly scanned out. It's therefore useful to check if direct scanout
      # is working.
      # (plain "Mod+Shift+Ctrl+T" [(flag "toggle-debug-tint")])
    ])

    # Settings for debugging. Not meant for normal use.
    # These can change or stop working at any point with little notice.
    (plain "debug" [
      # Make niri take over its DBus services even if it's not running as a session.
      # Useful for testing screen recording changes without having to relogin.
      # The main niri instance will *not* currently take back the services; so you will
      # need to relogin in the end.
      # (flag "dbus-interfaces-in-non-session-instances")

      # Wait until every frame is done rendering before handing it over to DRM.
      # (flag "wait-for-frame-completion-before-queueing")

      # Enable direct scanout into overlay planes.
      # May cause frame drops during some animations on some hardware.
      # (flag "enable-overlay-planes")

      # Disable the use of the cursor plane.
      # The cursor will be rendered together with the rest of the frame.
      # (flag "disable-cursor-plane")

      # Override the DRM device that niri will use for all rendering.
      # (leaf "render-drm-device" "/dev/dri/renderD129")

      # Enable the color-transformations capability of the Smithay renderer.
      # May cause a slight decrease in rendering performance.
      # (flag "enable-color-transformations-capability")

      # Emulate zero (unknown) presentation time returned from DRM.
      # This is a thing on NVIDIA proprietary drivers, so this flag can be
      # used to test that we don't break too hard on those systems.
      # (flag "emulate-zero-presentation-time")
    ])
  ];
}
</file>

<file path="docs.md">
# Packages provided by this flake

## `packages.<system>.<name>`

(where `<system>` is one of: `x86_64-linux`, `aarch64-linux`)

> [!important]
> Packages for `aarch64-linux` are untested. They might work, but i can't guarantee it.

You should preferably not be using these outputs directly. Instead, you should use [`overlays.niri`](#overlaysniri).



## `packages.<system>.niri-stable`

The latest stable tagged version of niri, along with potential patches.

Currently, this is release [`25.08`](https://github.com/YaLTeR/niri/releases/tag/25.08) with no additional patches.




To access this package under `pkgs.niri-stable`, you should use [`overlays.niri`](#overlaysniri).



## `packages.<system>.niri-unstable`

The latest commit to the development branch of niri.

Currently, this is exactly commit [`e837e39`](https://github.com/YaLTeR/niri/tree/e837e39623457dc5ad29c34a5ce4d4616e5fbf1e) which was authored on `2025-09-24 05:31:01`.

> [!warning]
> `niri-unstable` is not a released version, there are no stability guarantees, and it may break your workflow from itme to time.
>
> The specific package provided by this flake is automatically updated without any testing. The only guarantee is that it builds.


To access this package under `pkgs.niri-unstable`, you should use [`overlays.niri`](#overlaysniri).



## `overlays.niri`

A nixpkgs overlay that provides `niri-stable` and `niri-unstable`.

It is recommended to use this overlay over directly accessing the outputs. This is because the overlay ensures that the dependencies match your system's nixpkgs version, which is most important for `mesa`. If `mesa` doesn't match, niri will be unable to run in a TTY.

You can enable this overlay by adding this line to your configuration:

```nix
{
  nixpkgs.overlays = [ niri.overlays.niri ];
}
```

You can then access the packages via `pkgs.niri-stable` and `pkgs.niri-unstable` as if they were part of nixpkgs.



# `nixosModules.niri`

The full NixOS module for niri.

By default, this module does the following:

- It will enable a binary cache managed by me, sodiboo. This helps you avoid building niri from source, which can take a long time in release mode.
- If you have home-manager installed in your NixOS configuration (rather than as a standalone program), this module will automatically import [`homeModules.config`](#homemodulesconfig) for all users and give it the correct package to use for validation.
- If you have home-manager and stylix installed in your NixOS configuration, this module will also automatically import [`homeModules.stylix`](#homemodulesstylix) for all users.



## `programs.niri.enable`

- type: `boolean`
- default: `false`

Whether to install and enable niri.

This also enables the necessary system components for niri to function properly, such as desktop portals and polkit.



## `programs.niri.package`

- type: `package`
- default: [`pkgs.niri-stable`](#packagessystemniri-stable)

The package that niri will use.

You may wish to set it to the following values:

- [`pkgs.niri`](https://search.nixos.org/packages?channel=unstable&show=niri)
- [`pkgs.niri-stable`](#packagessystemniri-stable)
- [`pkgs.niri-unstable`](#packagessystemniri-unstable)



## `niri-flake.cache.enable`

- type: `boolean`
- default: `true`

Whether or not to enable the binary cache [`niri.cachix.org`](https://niri.cachix.org/) in your nix configuration.

Using a binary cache can save you time, by avoiding redundant rebuilds.

This cache is managed by me, sodiboo, and i use GitHub Actions to automaticaly upload builds of [`pkgs.niri-stable`](#packagessystemniri-stable) and [`pkgs.niri-unstable`](#packagessystemniri-unstable) (for nixpkgs unstable and stable). By using it, you are trusting me to not upload malicious builds, and as such you may disable it.

If you do not wish to use this cache, then you may wish to set [`programs.niri.package`](#programsniripackage) to [`pkgs.niri`](https://search.nixos.org/packages?channel=unstable&show=niri), in order to take advantage of the NixOS cache.



# `homeModules.niri`

The full home-manager module for niri.

By default, this module does nothing. It will import [`homeModules.config`](#homemodulesconfig), which provides many configuration options, and it also provides some options to install niri.



## `programs.niri.enable`

- type: `boolean`
- default: `false`

Whether to install and enable niri.

This also enables the necessary system components for niri to function properly, such as desktop portals and polkit.



## `programs.niri.package`

- type: `package`
- default: [`pkgs.niri-stable`](#packagessystemniri-stable)

The package that niri will use.

You may wish to set it to the following values:

- [`pkgs.niri`](https://search.nixos.org/packages?channel=unstable&show=niri)
- [`pkgs.niri-stable`](#packagessystemniri-stable)
- [`pkgs.niri-unstable`](#packagessystemniri-unstable)



# `homeModules.stylix`

Stylix integration. It provides a target to enable niri.

This module is automatically imported if you have home-manager and stylix installed in your NixOS configuration.

If you use standalone home-manager, you must import it manually if you wish to use stylix with niri. (since it can't be automatically imported in that case)



## `stylix.targets.niri.enable`

- type: `boolean`
- default: [`stylix.autoEnable`](https://danth.github.io/stylix/options/hm.html#stylixautoenable)

Whether to style niri according to your stylix config.

Note that enabling this stylix target will cause a config file to be generated, even if you don't set [`programs.niri.config`](#programsniriconfig).

This also means that, with stylix installed, having everything set to default *does* generate an actual config file.



# `homeModules.config`

Configuration options for niri. This module is automatically imported by [`nixosModules.niri`](#nixosmodulesniri) and [`homeModules.niri`](#homemodulesniri).

By default, this module does nothing. It provides many configuration options for niri, such as keybindings, animations, and window rules.

When its options are set, it generates `$XDG_CONFIG_HOME/niri/config.kdl` for the user. This is the default path for niri's config file.

It will also validate the config file with the `niri validate` command before committing that config. This ensures that the config file is always valid, else your system will fail to build. When using [`programs.niri.settings`](#programsnirisettings) to configure niri, that's not necessary, because it will always generate a valid config file. But, if you set [`programs.niri.config`](#programsniriconfig) directly, then this is very useful.



## type: `variant of`

Some of the options below make use of a "variant" type.

This is a type that behaves similarly to a submodule, except you can only set *one* of its suboptions.

An example of this usage is in [`animations.<name>`](#programsnirisettingsanimationsname), where each event can have either an easing animation or a spring animation. \
You cannot set parameters for both, so `variant` is used here.


## `programs.niri.package`

- type: `package`
- default: [`pkgs.niri-stable`](#packagessystemniri-stable)

The `niri` package that the config is validated against. This cannot be modified if you set the identically-named option in [`nixosModules.niri`](#nixosmodulesniri) or [`homeModules.niri`](#homemodulesniri).



## `programs.niri.config`
- type: `null or string or kdl document`

The niri config file.

- When this is null, no config file is generated.
- When this is a string, it is assumed to be the config file contents.
- When this is kdl document, it is serialized to a string before being used as the config file contents.

By default, this is a KDL document that reflects the settings in [`programs.niri.settings`](#programsnirisettings).


## `programs.niri.finalConfig`
- type: `null or string`

The final niri config file contents.

This is a string that reflects the document stored in [`programs.niri.config`](#programsniriconfig).

It is exposed mainly for debugging purposes, such as when you need to inspect how a certain option affects the resulting config file.


## `programs.niri.settings`
- type: `null or (submodule)`
- default: `null`

Nix-native settings for niri.

By default, when this is null, no config file is generated.

Beware that setting [`programs.niri.config`](#programsniriconfig) completely overrides everything under this option.


## `programs.niri.settings.binds`
- type: `attribute set of (niri keybind)`


## `programs.niri.settings.binds.<name>.action`
- type: `niri action`, which is a `kdl leaf`

An action is represented as an attrset with a single key, being the name, and a value that is a list of its arguments. For example, to represent a spawn action, you could do this:

```nix
{
  programs.niri.settings.binds = {
    "XF86AudioRaiseVolume".action.spawn = ["wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1+"];
    "XF86AudioLowerVolume".action.spawn = ["wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1-"];
  };
}
```


If there is only a single argument, you can pass it directly. It will be implicitly converted to a list in that case.

```nix
{
  programs.niri.settings.binds = {
    "Mod+D".action.spawn = "fuzzel";
    "Mod+1".action.focus-workspace = 1;
  };
}
```


For actions taking properties (named arguments), you can pass an attrset.

```nix
{
  programs.niri.settings.binds = {
    "Mod+Shift+E".action.quit.skip-confirmation = true;
  };
}
```


There is also a set of functions available under `config.lib.niri.actions`.

Usage is like so:

```nix
{
  programs.niri.settings.binds = with config.lib.niri.actions; {
    "XF86AudioRaiseVolume".action = spawn "wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1+";
    "XF86AudioLowerVolume".action = spawn "wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1-";

    "Mod+D".action = spawn "fuzzel";
    "Mod+1".action = focus-workspace 1;

    "Mod+Shift+E".action = quit;
    "Mod+Ctrl+Shift+E".action = quit { skip-confirmation=true; };

    "Mod+Plus".action = set-column-width "+10%";
  }
}
```


Keep in mind that each one of these attributes (i.e. the nix bindings) are actually identical functions with different node names, and they can take arbitrarily many arguments. The documentation here is based on the *real* acceptable arguments for these actions, but the nix bindings do not enforce this. If you pass the wrong arguments, niri will reject the config file, but evaluation will proceed without problems.

For actions that don't take any arguments, just use the corresponding attribute from `config.lib.niri.actions`. They are listed as `action-name`. For actions that *do* take arguments, they are notated like so: `λ action-name :: <args>`, to clarify that they "should" be used as functions. Hopefully, `<args>` will be clear enough in most cases, but it's worth noting some nontrivial kinds of arguments:

- `size-change`: This is a special argument type used for some actions by niri. It's a string. \
  It can take either a fixed size as an integer number of logical pixels (`"480"`, `"1200"`) or a proportion of your screen as a percentage (`"30%"`, `"70%"`) \
  Additionally, it can either be an absolute change (setting the new size of the window), or a relative change (adding or subtracting from its size). \
  Relative size changes are written with a `+`/`-` prefix, and absolute size changes have no prefix.
- `{ field :: type }`: This means that the action takes a named argument (in kdl, we call it a property). \
  To pass such an argument, you should pass an attrset with the key and value. You can pass many properties in one attrset, or you can pass several attrsets with different properties. \
  Required fields are marked with `*` before their name, and if no fields are required, you can use the action without any arguments too (see `quit` in the example above). \
  If a field is marked with `?`, then omitting it is meaningful. (without `?`, it will have a default value)
- `[type]`: This means that the action takes several arguments as a list. Although you can pass a list directly, it's more common to pass them as separate arguments. \
  `spawn ["foo" "bar" "baz"]` is equivalent to `spawn "foo" "bar" "baz"`.


> [!tip]
> You can use partial application to create a spawn command with full support for shell syntax:
> ```nix
> {
>   programs.niri.settings.binds = with config.lib.niri.actions; let
>     sh = spawn "sh" "-c";
>   in {
>     "Print".action = sh ''grim -g "$(slurp)" - | wl-copy'';
>   };
> }
> ```


- `λ quit :: { skip-confirmation :: bool }`
- `suspend`
- `power-off-monitors`
- `power-on-monitors`
- `toggle-debug-tint`
- `debug-toggle-opaque-regions`
- `debug-toggle-damage`
- `λ spawn :: [string]`
- `λ spawn-sh :: string`
- `λ do-screen-transition :: { delay-ms? :: u16 }`
- `λ screenshot :: { show-pointer :: bool }`
- `λ screenshot-window :: { write-to-disk :: bool }`
- `toggle-keyboard-shortcuts-inhibit`
- `close-window`
- `fullscreen-window`
- `toggle-windowed-fullscreen`
- `λ focus-window-in-column :: u8`
- `focus-window-previous`
- `focus-column-left`
- `focus-column-right`
- `focus-column-first`
- `focus-column-last`
- `focus-column-right-or-first`
- `focus-column-left-or-last`
- `λ focus-column :: usize`
- `focus-window-or-monitor-up`
- `focus-window-or-monitor-down`
- `focus-column-or-monitor-left`
- `focus-column-or-monitor-right`
- `focus-window-down`
- `focus-window-up`
- `focus-window-down-or-column-left`
- `focus-window-down-or-column-right`
- `focus-window-up-or-column-left`
- `focus-window-up-or-column-right`
- `focus-window-or-workspace-down`
- `focus-window-or-workspace-up`
- `focus-window-top`
- `focus-window-bottom`
- `focus-window-down-or-top`
- `focus-window-up-or-bottom`
- `move-column-left`
- `move-column-right`
- `move-column-to-first`
- `move-column-to-last`
- `move-column-left-or-to-monitor-left`
- `move-column-right-or-to-monitor-right`
- `λ move-column-to-index :: usize`
- `move-window-down`
- `move-window-up`
- `move-window-down-or-to-workspace-down`
- `move-window-up-or-to-workspace-up`
- `consume-or-expel-window-left`
- `consume-or-expel-window-right`
- `consume-window-into-column`
- `expel-window-from-column`
- `swap-window-left`
- `swap-window-right`
- `toggle-column-tabbed-display`
- `λ set-column-display :: string`
- `center-column`
- `center-window`
- `center-visible-columns`
- `focus-workspace-down`
- `focus-workspace-up`
- `λ focus-workspace :: u8 | string`
- `focus-workspace-previous`
- `λ move-window-to-workspace-down :: { focus :: bool }`
- `λ move-window-to-workspace-up :: { focus :: bool }`
- `λ move-column-to-workspace-down :: { focus :: bool }`
- `λ move-column-to-workspace-up :: { focus :: bool }`
- `move-workspace-down`
- `move-workspace-up`
- `λ move-workspace-to-index :: usize`
- `λ move-workspace-to-monitor :: string`
- `λ set-workspace-name :: string`
- `unset-workspace-name`
- `focus-monitor-left`
- `focus-monitor-right`
- `focus-monitor-down`
- `focus-monitor-up`
- `focus-monitor-previous`
- `focus-monitor-next`
- `λ focus-monitor :: string`
- `move-window-to-monitor-left`
- `move-window-to-monitor-right`
- `move-window-to-monitor-down`
- `move-window-to-monitor-up`
- `move-window-to-monitor-previous`
- `move-window-to-monitor-next`
- `λ move-window-to-monitor :: string`
- `move-column-to-monitor-left`
- `move-column-to-monitor-right`
- `move-column-to-monitor-down`
- `move-column-to-monitor-up`
- `move-column-to-monitor-previous`
- `move-column-to-monitor-next`
- `λ move-column-to-monitor :: string`
- `λ set-window-width :: size-change`
- `λ set-window-height :: size-change`
- `reset-window-height`
- `switch-preset-column-width`
- `switch-preset-column-width-back`
- `switch-preset-window-width`
- `switch-preset-window-width-back`
- `switch-preset-window-height`
- `switch-preset-window-height-back`
- `maximize-column`
- `λ set-column-width :: size-change`
- `expand-column-to-available-width`
- `λ switch-layout :: "next" | "prev"`
- `show-hotkey-overlay`
- `move-workspace-to-monitor-left`
- `move-workspace-to-monitor-right`
- `move-workspace-to-monitor-down`
- `move-workspace-to-monitor-up`
- `move-workspace-to-monitor-previous`
- `move-workspace-to-monitor-next`
- `toggle-window-floating`
- `move-window-to-floating`
- `move-window-to-tiling`
- `focus-floating`
- `focus-tiling`
- `switch-focus-between-floating-and-tiling`
- `toggle-window-rule-opacity`
- `set-dynamic-cast-window`
- `λ set-dynamic-cast-monitor :: unknown`
  
    The code that generates this documentation does not know how to parse the definition:
    ```rs
    SetDynamicCastMonitor(#[knuffel(argument)] Option<String>)
    ```
- `clear-dynamic-cast-target`
- `toggle-overview`
- `open-overview`
- `close-overview`



## `programs.niri.settings.binds.<name>.allow-inhibiting`
- type: `boolean`
- default: `true`

When a surface is inhibiting keyboard shortcuts, this option dictates wether *this* keybind will be inhibited as well.

By default it is true for all keybinds, meaning an application can block this keybind from being triggered, and the application will receive the key event instead.

When false, this keybind will always be triggered, even if an application is inhibiting keybinds. There is no way for a client to observe this keypress.

Has no effect when `action` is `toggle-keyboard-shortcuts-inhibit`. In that case, this value is implicitly false, no matter what you set it to. (note that the value reported in the nix config may be inaccurate in that case; although hopefully you're not relying on the values of specific keybinds for the rest of your config?)


## `programs.niri.settings.binds.<name>.allow-when-locked`
- type: `boolean`
- default: `false`

Whether this keybind should be allowed when the screen is locked.

This is only applicable for `spawn` keybinds.


## `programs.niri.settings.binds.<name>.cooldown-ms`
- type: `null or signed integer`
- default: `null`

The minimum cooldown before a keybind can be triggered again, in milliseconds.

This is mostly useful for binds on the mouse wheel, where you might not want to activate an action several times in quick succession. You can use it for any bind, though.


## `programs.niri.settings.binds.<name>.hotkey-overlay`
- type: `attribute-tagged union`
- default:
  ```nix
  {
    hidden = false;
  }
  ```


How this keybind should be displayed in the hotkey overlay.

- By default, `{hidden = false;}` maps to omitting this from the KDL config; the default title of the action will be used.
- `{hidden = true;}` will emit `hotkey-overlay-title=null` in the KDL config, and the hotkey overlay will not contain this keybind at all.
- `{title = "foo";}` will emit `hotkey-overlay-title="foo"` in the KDL config, and the hotkey overlay will show "foo" as the title of this keybind.



## `programs.niri.settings.binds.<name>.hotkey-overlay.hidden`
- type: `boolean`

When `true`, the hotkey overlay will not contain this keybind at all. When `false`, it will show the default title of the action.


## `programs.niri.settings.binds.<name>.hotkey-overlay.title`
- type: `string`

The title of this keybind in the hotkey overlay. [Pango markup](https://docs.gtk.org/Pango/pango_markup.html) is supported.


## `programs.niri.settings.binds.<name>.repeat`
- type: `boolean`
- default: `true`

Whether this keybind should trigger repeatedly when held down.


<!-- programs.niri.settings.switch-events -->

## `programs.niri.settings.switch-events.lid-close`
- type: `null or`[`<switch-bind>`](#switch-bind)
- default: `null`


## `programs.niri.settings.switch-events.lid-open`
- type: `null or`[`<switch-bind>`](#switch-bind)
- default: `null`


## `programs.niri.settings.switch-events.tablet-mode-off`
- type: `null or`[`<switch-bind>`](#switch-bind)
- default: `null`


## `programs.niri.settings.switch-events.tablet-mode-on`
- type: `null or`[`<switch-bind>`](#switch-bind)
- default: `null`


## `<switch-bind>`
- type: `niri switch bind`

<!--
This description doesn't matter to the docs, but is necessary to make this header actually render so the above types can link to it.
-->


## `<switch-bind>.action`
- type: `niri switch action`, which is a `kdl leaf`

A switch action is represented as an attrset with a single key, being the name, and a value that is a list of its arguments.

See also [`binds.<name>.action`](#programsnirisettingsbindsnameaction) for more information on how this works, it has the exact same option type. Beware that switch binds are not the same as regular binds, and the actions they take are different. Currently, they can only accept spawn binds. Correct usage is like so:

```nix
{
  programs.niri.settings.switch-events = {
    tablet-mode-on.action.spawn = ["gsettings" "set" "org.gnome.desktop.a11y.applications" "screen-keyboard-enabled" "true"];
    tablet-mode-off.action.spawn = ["gsettings" "set" "org.gnome.desktop.a11y.applications" "screen-keyboard-enabled" "false"];
  };
}
```



## `programs.niri.settings.screenshot-path`
- type: `null or string`
- default: `"~/Pictures/Screenshots/Screenshot from %Y-%m-%d %H-%M-%S.png"`

The path to save screenshots to.

If this is null, then no screenshots will be saved.

If the path starts with a `~`, then it will be expanded to the user's home directory.

The path is then passed to [`strftime(3)`](https://man7.org/linux/man-pages/man3/strftime.3.html) with the current time, and the result is used as the final path.


## `programs.niri.settings.hotkey-overlay.hide-not-bound`
- type: `boolean`
- default: `false`

By default, niri has a set of important keybinds that are always shown in the hotkey overlay, even if they are not bound to any key.
In particular, this helps new users discover important keybinds, especially if their config has no keybinds at all.

You can disable this behaviour by setting this option to `true`. Then, niri will only show keybinds that are actually bound to a key.


## `programs.niri.settings.hotkey-overlay.skip-at-startup`
- type: `boolean`
- default: `false`

Whether to skip the hotkey overlay shown when niri starts.


## `programs.niri.settings.config-notification.disable-failed`
- type: `boolean`
- default: `false`

Disable the notification that the config file failed to load.


## `programs.niri.settings.clipboard.disable-primary`
- type: `boolean`
- default: `false`

The "primary selection" is a special clipboard that contains the text that was last selected with the mouse, and can usually be pasted with the middle mouse button.

This is a feature that is not inherently part of the core Wayland protocol, but [a widely supported protocol extension](https://wayland.app/protocols/primary-selection-unstable-v1#compositor-support) enables support for it anyway.

This functionality was inherited from X11, is not necessarily intuitive to many users; especially those coming from other operating systems that do not have this feature (such as Windows, where the middle mouse button is used for scrolling).

If you don't want to have a primary selection, you can disable it with this option. Doing so will prevent niri from adveritising support for the primary selection protocol.

Note that this option has nothing to do with the "clipboard" that is commonly invoked with `Ctrl+C` and `Ctrl+V`.


## `programs.niri.settings.prefer-no-csd`
- type: `boolean`
- default: `false`

Whether to prefer server-side decorations (SSD) over client-side decorations (CSD).


## `programs.niri.settings.spawn-at-startup`
- type: `list of attribute-tagged union`

A list of commands to run when niri starts.

Each command can be represented as its raw arguments, or as a shell invocation.

When niri is built with the `systemd` feature (on by default), commands spawned this way (or with the `spawn` and `spawn-sh` actions) will be put in a transient systemd unit, which separates the process from niri and prevents e.g. OOM situations from killing the entire session.


## `programs.niri.settings.spawn-at-startup.*.argv`
- type: `list of string`

Almost raw process arguments to spawn, without shell syntax.

A leading tilde in the zeroth argument will be expanded to the user's home directory. No other preprocessing is applied.

Usage is like so:

```nix
{
  programs.niri.settings.spawn-at-startup = [
    { argv = ["waybar"]; }
    { argv = ["swaybg" "--image" "/path/to/wallpaper.jpg"]; }
    { argv = ["~/.config/niri/scripts/startup.sh"]; }
  ];
}
```



## `programs.niri.settings.spawn-at-startup.*.sh`
- type: `string`

A shell command to spawn. Run wild with POSIX syntax.

```nix
{
  programs.niri.settings.spawn-at-startup = [
    { sh = "echo $NIRI_SOCKET > ~/.niri-socket"; }
  ];
}
```


Note that `{ sh = "foo"; }` is exactly equivalent to `{ argv = [ "sh" "-c" "foo" ]; }`.


## `programs.niri.settings.workspaces`
- type: `attribute set of (submodule)`

Declare named workspaces.

Named workspaces are similar to regular, dynamic workspaces, except they can be
referred to by name, and they are persistent, they do not close when there are
no more windows left on them.

Usage is like so:

```nix
{
  programs.niri.settings.workspaces."name" = {};
  programs.niri.settings.workspaces."01-another-one" = {
    open-on-output = "DP-1";
    name = "another-one";
  };
}
```


Unless a `name` is declared, the workspace will use the attribute key as the name.

Workspaces will be created in a specific order: sorted by key. If you do not care
about the order of named workspaces, you can skip using the `name` attribute, and
use the key instead. If you do care about it, you can use the key to order them,
and a `name` attribute to have a friendlier name.


## `programs.niri.settings.workspaces.<name>.name`
- type: `string`
- default: `the key of the workspace`

The name of the workspace. You set this manually if you want the keys to be ordered in a specific way.


## `programs.niri.settings.workspaces.<name>.open-on-output`
- type: `null or string`
- default: `null`

The name of the output the workspace should be assigned to.


## `programs.niri.settings.overview.backdrop-color`
- type: `null or string`
- default: `null`

Set the backdrop color behind workspaces in the overview. The backdrop is also visible between workspaces when switching.

The alpha channel for this color will be ignored.


## `programs.niri.settings.overview.workspace-shadow.color`
- type: `null or string`
- default: `null`


## `programs.niri.settings.overview.workspace-shadow.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.overview.workspace-shadow.offset`
- type: `null or (submodule)`
- default: `null`

The offset of the shadow from the window, measured in logical pixels.

This behaves like a [CSS box-shadow offset](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.overview.workspace-shadow.offset.x`
- type: `floating point number or signed integer`
- default: `0.000000`


## `programs.niri.settings.overview.workspace-shadow.offset.y`
- type: `floating point number or signed integer`
- default: `5.000000`


## `programs.niri.settings.overview.workspace-shadow.softness`
- type: `null or floating point number or signed integer`
- default: `null`

The softness/size of the shadow, measured in logical pixels.

This behaves like a [CSS box-shadow blur radius](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.overview.workspace-shadow.spread`
- type: `null or floating point number or signed integer`
- default: `null`

The spread of the shadow, measured in logical pixels.

This behaves like a [CSS box-shadow spread radius](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.overview.zoom`
- type: `null or floating point number or signed integer`
- default: `null`

Control how much the workspaces zoom out in the overview. zoom ranges from 0 to 0.75 where lower values make everything smaller.


## `programs.niri.settings.input.focus-follows-mouse.enable`
- type: `boolean`
- default: `false`

Whether to focus the window under the mouse when the mouse moves.


## `programs.niri.settings.input.focus-follows-mouse.max-scroll-amount`
- type: `null or string`
- default: `null`

The maximum proportion of the screen to scroll at a time


## `programs.niri.settings.input.keyboard.numlock`
- type: `boolean`
- default: `false`

Enable numlock by default


## `programs.niri.settings.input.keyboard.repeat-delay`
- type: `signed integer`
- default: `600`

The delay in milliseconds before a key starts repeating.


## `programs.niri.settings.input.keyboard.repeat-rate`
- type: `signed integer`
- default: `25`

The rate in characters per second at which a key repeats.


## `programs.niri.settings.input.keyboard.track-layout`
- type: `one of "global", "window"`
- default: `"global"`

The keyboard layout can be remembered per `"window"`, such that when you switch to a window, the keyboard layout is set to the one that was last used in that window.

By default, there is only one `"global"` keyboard layout and changing it in any window will affect the keyboard layout used in all other windows too.


## `programs.niri.settings.input.keyboard.xkb`


Parameters passed to libxkbcommon, which handles the keyboard in niri.

Further reading:
- [`smithay::wayland::seat::XkbConfig`](https://docs.rs/smithay/latest/smithay/wayland/seat/struct.XkbConfig.html)



## `programs.niri.settings.input.keyboard.xkb.file`
- type: `null or string`
- default: `null`

Path to a `.xkb` keymap file. If set, this file will be used to configure libxkbcommon, and all other options will be ignored.


## `programs.niri.settings.input.keyboard.xkb.layout`
- type: `string`
- default: `""`

A comma-separated list of layouts (languages) to include in the keymap.

See [`xkeyboard-config(7)`](https://man.archlinux.org/man/xkeyboard-config.7#LAYOUTS) for a list of available layouts and their variants.

If this is set to an empty string, the layout will be read from the `XKB_DEFAULT_LAYOUT` environment variable.



## `programs.niri.settings.input.keyboard.xkb.model`
- type: `string`
- default: `""`

The keyboard model by which to interpret keycodes and LEDs

See [`xkeyboard-config(7)`](https://man.archlinux.org/man/xkeyboard-config.7#MODELS) for a list of available models.

If this is set to an empty string, the model will be read from the `XKB_DEFAULT_MODEL` environment variable.



## `programs.niri.settings.input.keyboard.xkb.options`
- type: `null or string`
- default: `null`

A comma separated list of options, through which the user specifies non-layout related preferences, like which key combinations are used for switching layouts, or which key is the Compose key.

See [`xkeyboard-config(7)`](https://man.archlinux.org/man/xkeyboard-config.7#OPTIONS) for a list of available options.

If this is set to an empty string, no options will be used.

If this is set to null, the options will be read from the `XKB_DEFAULT_OPTIONS` environment variable.



## `programs.niri.settings.input.keyboard.xkb.rules`
- type: `string`
- default: `""`

The rules file to use.

The rules file describes how to interpret the values of the model, layout, variant and options fields.

If this is set to an empty string, the rules will be read from the `XKB_DEFAULT_RULES` environment variable.



## `programs.niri.settings.input.keyboard.xkb.variant`
- type: `string`
- default: `""`

A comma separated list of variants, one per layout, which may modify or augment the respective layout in various ways.

See [`xkeyboard-config(7)`](https://man.archlinux.org/man/xkeyboard-config.7#LAYOUTS) for a list of available variants for each layout.

If this is set to an empty string, the variant will be read from the `XKB_DEFAULT_VARIANT` environment variable.



## `programs.niri.settings.input.mod-key`
- type: `null or string`
- default: `null`


## `programs.niri.settings.input.mod-key-nested`
- type: `null or string`
- default: `null`


## `programs.niri.settings.input.mouse.accel-profile`
- type: `null or one of "adaptive", "flat"`
- default: `null`

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/pointer-acceleration.html#pointer-acceleration-profiles



## `programs.niri.settings.input.mouse.accel-speed`
- type: `null or floating point number or signed integer`
- default: `null`

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#pointer-acceleration



## `programs.niri.settings.input.mouse.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.input.mouse.left-handed`
- type: `boolean`
- default: `false`

Whether to accomodate left-handed usage for this device.
This varies based on the exact device, but will for example swap left/right mouse buttons.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#left-handed-mode



## `programs.niri.settings.input.mouse.middle-emulation`
- type: `boolean`
- default: `false`

Whether a middle mouse button press should be sent when you press the left and right mouse buttons

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#middle-button-emulation
- https://wayland.freedesktop.org/libinput/doc/latest/middle-button-emulation.html#middle-button-emulation



## `programs.niri.settings.input.mouse.natural-scroll`
- type: `boolean`
- default: `false`

Whether scrolling should move the content in the scrolled direction (as opposed to moving the viewport)

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#scrolling
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#natural-scrolling-vs-traditional-scrolling



## `programs.niri.settings.input.mouse.scroll-button`
- type: `null or signed integer`
- default: `null`

When `scroll-method = "on-button-down"`, this is the button that will be used to enable scrolling. This button must be on the same physical device as the pointer, according to libinput docs. The type is a button code, as defined in [`input-event-codes.h`](https://github.com/torvalds/linux/blob/e42b1a9a2557aa94fee47f078633677198386a52/include/uapi/linux/input-event-codes.h#L355-L363). Most commonly, this will be set to `BTN_LEFT`, `BTN_MIDDLE`, or `BTN_RIGHT`, or at least some mouse button, but any button from that file is a valid value for this option (though, libinput may not necessarily do anything useful with most of them)

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#on-button-scrolling



## `programs.niri.settings.input.mouse.scroll-button-lock`
- type: `boolean`
- default: `false`

When this is false, `scroll-button` needs to be held down for pointer motion to be converted to scrolling. When this is true, `scroll-button` can be pressed and released to "lock" the device into this state, until it is pressed and released a second time.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#on-button-scrolling



## `programs.niri.settings.input.mouse.scroll-factor`
- type: `null or floating point number or signed integer or (submodule)`
- default: `null`

For all scroll events triggered by a wheel source, the scroll distance is multiplied by this factor.

This is not a libinput property, but rather a niri-specific one.


## `programs.niri.settings.input.mouse.scroll-method`
- type: `null or one of "no-scroll", "two-finger", "edge", "on-button-down"`
- default: `null`

When to convert motion events to scrolling events.
The default and supported values vary based on the device type.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#scrolling



## `programs.niri.settings.input.power-key-handling.enable`
- type: `boolean`
- default: `true`

By default, niri will take over the power button to make it sleep instead of power off.

You can disable this behaviour if you prefer to configure the power button elsewhere.


## `programs.niri.settings.input.tablet.calibration-matrix`
- type: `null or (2x3 matrix)`
- default: `null`

An augmented calibration matrix for the tablet.

This is represented in Nix as a 2-list of 3-lists of floats.

For example:
```nix
{
  # 90 degree rotation clockwise
  calibration-matrix = [
    [ 0.0 -1.0 1.0 ]
    [ 1.0  0.0 0.0 ]
  ];
}
```


Further reading:
- [`libinput_device_config_calibration_get_default_matrix()`](https://wayland.freedesktop.org/libinput/doc/1.8.2/group__config.html#ga3d9f1b9be10e804e170c4ea455bd1f1b)
- [`libinput_device_config_calibration_set_matrix()`](https://wayland.freedesktop.org/libinput/doc/1.8.2/group__config.html#ga09a798f58cc601edd2797780096e9804)
- [rustdoc because libinput's web docs are an eyesore](https://smithay.github.io/smithay/input/struct.Device.html#method.config_calibration_set_matrix)



## `programs.niri.settings.input.tablet.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.input.tablet.left-handed`
- type: `boolean`
- default: `false`

Whether to accomodate left-handed usage for this device.
This varies based on the exact device, but will for example swap left/right mouse buttons.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#left-handed-mode



## `programs.niri.settings.input.tablet.map-to-output`
- type: `null or string`
- default: `null`


## `programs.niri.settings.input.touch.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.input.touch.map-to-output`
- type: `null or string`
- default: `null`


## `programs.niri.settings.input.touchpad.accel-profile`
- type: `null or one of "adaptive", "flat"`
- default: `null`

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/pointer-acceleration.html#pointer-acceleration-profiles



## `programs.niri.settings.input.touchpad.accel-speed`
- type: `null or floating point number or signed integer`
- default: `null`

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#pointer-acceleration



## `programs.niri.settings.input.touchpad.click-method`
- type: `null or one of "button-areas", "clickfinger"`
- default: `null`

Method to determine which mouse button is pressed when you click the touchpad.

- `"button-areas"`: [Software button areas](https://wayland.freedesktop.org/libinput/doc/latest/clickpad-softbuttons.html#software-button-areas) \
  The button is determined by which part of the touchpad was clicked.
- `"clickfinger"`: [Clickfinger behavior](https://wayland.freedesktop.org/libinput/doc/latest/clickpad-softbuttons.html#clickfinger-behavior) \
  The button is determined by how many fingers clicked.


Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#click-method
- https://wayland.freedesktop.org/libinput/doc/latest/clickpad-softbuttons.html#clickpad-software-button-behavior



## `programs.niri.settings.input.touchpad.disabled-on-external-mouse`
- type: `boolean`
- default: `false`

Whether to disable the touchpad when an external mouse is plugged in.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#send-events-mode



## `programs.niri.settings.input.touchpad.drag`
- type: `null or boolean`
- default: `null`

On most touchpads, "tap and drag" is enabled by default. This option allows you to explicitly enable or disable it.

Tap and drag means that to drag an item, you tap the touchpad with some amount of fingers to decide what kind of button press is emulated, but don't hold those fingers, and then you immediately start dragging with one finger.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/tapping.html#tap-and-drag



## `programs.niri.settings.input.touchpad.drag-lock`
- type: `boolean`
- default: `false`

By default, a "tap and drag" gesture is terminated by releasing the finger that is dragging.

Drag lock means that the drag gesture is not terminated when the finger is released, but only when the finger is tapped again, or after a timeout (unless sticky mode is enabled). This allows you to reset your finger position without losing the drag gesture.

Drag lock is only applicable when tap and drag is enabled.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/tapping.html#tap-and-drag



## `programs.niri.settings.input.touchpad.dwt`
- type: `boolean`
- default: `false`

Whether to disable the touchpad while typing.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#disable-while-typing
- https://wayland.freedesktop.org/libinput/doc/latest/palm-detection.html#disable-while-typing



## `programs.niri.settings.input.touchpad.dwtp`
- type: `boolean`
- default: `false`

Whether to disable the touchpad while the trackpoint is in use.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#disable-while-trackpointing
- https://wayland.freedesktop.org/libinput/doc/latest/palm-detection.html#disable-while-trackpointing



## `programs.niri.settings.input.touchpad.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.input.touchpad.left-handed`
- type: `boolean`
- default: `false`

Whether to accomodate left-handed usage for this device.
This varies based on the exact device, but will for example swap left/right mouse buttons.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#left-handed-mode



## `programs.niri.settings.input.touchpad.middle-emulation`
- type: `boolean`
- default: `false`

Whether a middle mouse button press should be sent when you press the left and right mouse buttons

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#middle-button-emulation
- https://wayland.freedesktop.org/libinput/doc/latest/middle-button-emulation.html#middle-button-emulation



## `programs.niri.settings.input.touchpad.natural-scroll`
- type: `boolean`
- default: `true`

Whether scrolling should move the content in the scrolled direction (as opposed to moving the viewport)

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#scrolling
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#natural-scrolling-vs-traditional-scrolling



## `programs.niri.settings.input.touchpad.scroll-button`
- type: `null or signed integer`
- default: `null`

When `scroll-method = "on-button-down"`, this is the button that will be used to enable scrolling. This button must be on the same physical device as the pointer, according to libinput docs. The type is a button code, as defined in [`input-event-codes.h`](https://github.com/torvalds/linux/blob/e42b1a9a2557aa94fee47f078633677198386a52/include/uapi/linux/input-event-codes.h#L355-L363). Most commonly, this will be set to `BTN_LEFT`, `BTN_MIDDLE`, or `BTN_RIGHT`, or at least some mouse button, but any button from that file is a valid value for this option (though, libinput may not necessarily do anything useful with most of them)

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#on-button-scrolling



## `programs.niri.settings.input.touchpad.scroll-button-lock`
- type: `boolean`
- default: `false`

When this is false, `scroll-button` needs to be held down for pointer motion to be converted to scrolling. When this is true, `scroll-button` can be pressed and released to "lock" the device into this state, until it is pressed and released a second time.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#on-button-scrolling



## `programs.niri.settings.input.touchpad.scroll-factor`
- type: `null or floating point number or signed integer or (submodule)`
- default: `null`

For all scroll events triggered by a finger source, the scroll distance is multiplied by this factor.

This is not a libinput property, but rather a niri-specific one.


## `programs.niri.settings.input.touchpad.scroll-method`
- type: `null or one of "no-scroll", "two-finger", "edge", "on-button-down"`
- default: `null`

When to convert motion events to scrolling events.
The default and supported values vary based on the device type.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#scrolling



## `programs.niri.settings.input.touchpad.tap`
- type: `boolean`
- default: `true`

Whether to enable tap-to-click.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#tap-to-click
- https://wayland.freedesktop.org/libinput/doc/latest/tapping.html#tap-to-click-behaviour



## `programs.niri.settings.input.touchpad.tap-button-map`
- type: `null or one of "left-middle-right", "left-right-middle"`
- default: `null`

The mouse button to register when tapping with 1, 2, or 3 fingers, when [`input.touchpad.tap`](#programsnirisettingsinputtouchpadtap) is enabled.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#tap-to-click



## `programs.niri.settings.input.trackball.accel-profile`
- type: `null or one of "adaptive", "flat"`
- default: `null`

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/pointer-acceleration.html#pointer-acceleration-profiles



## `programs.niri.settings.input.trackball.accel-speed`
- type: `null or floating point number or signed integer`
- default: `null`

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#pointer-acceleration



## `programs.niri.settings.input.trackball.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.input.trackball.left-handed`
- type: `boolean`
- default: `false`

Whether to accomodate left-handed usage for this device.
This varies based on the exact device, but will for example swap left/right mouse buttons.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#left-handed-mode



## `programs.niri.settings.input.trackball.middle-emulation`
- type: `boolean`
- default: `false`

Whether a middle mouse button press should be sent when you press the left and right mouse buttons

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#middle-button-emulation
- https://wayland.freedesktop.org/libinput/doc/latest/middle-button-emulation.html#middle-button-emulation



## `programs.niri.settings.input.trackball.natural-scroll`
- type: `boolean`
- default: `false`

Whether scrolling should move the content in the scrolled direction (as opposed to moving the viewport)

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#scrolling
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#natural-scrolling-vs-traditional-scrolling



## `programs.niri.settings.input.trackball.scroll-button`
- type: `null or signed integer`
- default: `null`

When `scroll-method = "on-button-down"`, this is the button that will be used to enable scrolling. This button must be on the same physical device as the pointer, according to libinput docs. The type is a button code, as defined in [`input-event-codes.h`](https://github.com/torvalds/linux/blob/e42b1a9a2557aa94fee47f078633677198386a52/include/uapi/linux/input-event-codes.h#L355-L363). Most commonly, this will be set to `BTN_LEFT`, `BTN_MIDDLE`, or `BTN_RIGHT`, or at least some mouse button, but any button from that file is a valid value for this option (though, libinput may not necessarily do anything useful with most of them)

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#on-button-scrolling



## `programs.niri.settings.input.trackball.scroll-button-lock`
- type: `boolean`
- default: `false`

When this is false, `scroll-button` needs to be held down for pointer motion to be converted to scrolling. When this is true, `scroll-button` can be pressed and released to "lock" the device into this state, until it is pressed and released a second time.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#on-button-scrolling



## `programs.niri.settings.input.trackball.scroll-method`
- type: `null or one of "no-scroll", "two-finger", "edge", "on-button-down"`
- default: `null`

When to convert motion events to scrolling events.
The default and supported values vary based on the device type.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#scrolling



## `programs.niri.settings.input.trackpoint.accel-profile`
- type: `null or one of "adaptive", "flat"`
- default: `null`

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/pointer-acceleration.html#pointer-acceleration-profiles



## `programs.niri.settings.input.trackpoint.accel-speed`
- type: `null or floating point number or signed integer`
- default: `null`

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#pointer-acceleration



## `programs.niri.settings.input.trackpoint.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.input.trackpoint.left-handed`
- type: `boolean`
- default: `false`

Whether to accomodate left-handed usage for this device.
This varies based on the exact device, but will for example swap left/right mouse buttons.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#left-handed-mode



## `programs.niri.settings.input.trackpoint.middle-emulation`
- type: `boolean`
- default: `false`

Whether a middle mouse button press should be sent when you press the left and right mouse buttons

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#middle-button-emulation
- https://wayland.freedesktop.org/libinput/doc/latest/middle-button-emulation.html#middle-button-emulation



## `programs.niri.settings.input.trackpoint.natural-scroll`
- type: `boolean`
- default: `false`

Whether scrolling should move the content in the scrolled direction (as opposed to moving the viewport)

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/configuration.html#scrolling
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#natural-scrolling-vs-traditional-scrolling



## `programs.niri.settings.input.trackpoint.scroll-button`
- type: `null or signed integer`
- default: `null`

When `scroll-method = "on-button-down"`, this is the button that will be used to enable scrolling. This button must be on the same physical device as the pointer, according to libinput docs. The type is a button code, as defined in [`input-event-codes.h`](https://github.com/torvalds/linux/blob/e42b1a9a2557aa94fee47f078633677198386a52/include/uapi/linux/input-event-codes.h#L355-L363). Most commonly, this will be set to `BTN_LEFT`, `BTN_MIDDLE`, or `BTN_RIGHT`, or at least some mouse button, but any button from that file is a valid value for this option (though, libinput may not necessarily do anything useful with most of them)

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#on-button-scrolling



## `programs.niri.settings.input.trackpoint.scroll-button-lock`
- type: `boolean`
- default: `false`

When this is false, `scroll-button` needs to be held down for pointer motion to be converted to scrolling. When this is true, `scroll-button` can be pressed and released to "lock" the device into this state, until it is pressed and released a second time.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#on-button-scrolling



## `programs.niri.settings.input.trackpoint.scroll-method`
- type: `null or one of "no-scroll", "two-finger", "edge", "on-button-down"`
- default: `null`

When to convert motion events to scrolling events.
The default and supported values vary based on the device type.

Further reading:
- https://wayland.freedesktop.org/libinput/doc/latest/scrolling.html#scrolling



## `programs.niri.settings.input.warp-mouse-to-focus`


Whether to warp the mouse to the focused window when switching focus.


## `programs.niri.settings.input.warp-mouse-to-focus.enable`
- type: `boolean`
- default: `false`


## `programs.niri.settings.input.warp-mouse-to-focus.mode`
- type: `null or string`
- default: `null`


## `programs.niri.settings.input.workspace-auto-back-and-forth`
- type: `boolean`
- default: `false`

When invoking `focus-workspace` to switch to a workspace by index, if the workspace is already focused, usually nothing happens. When this option is enabled, the workspace will cycle back to the previously active workspace.

Of note is that it does not switch to the previous *index*, but the previous *workspace*. That means you can reorder workspaces inbetween these actions, and it will still take you to the actual same workspace you came from.


## `programs.niri.settings.outputs`
- type: `attribute set of (submodule)`


## `programs.niri.settings.outputs.<name>.backdrop-color`
- type: `null or string`
- default: `null`

The backdrop color that niri draws for this output. This is visible between workspaces or in the overview.


## `programs.niri.settings.outputs.<name>.background-color`
- type: `null or string`
- default: `null`

The background color of this output. This is equivalent to launching `swaybg -c <color>` on that output, but is handled by the compositor itself for solid colors.


## `programs.niri.settings.outputs.<name>.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.outputs.<name>.focus-at-startup`
- type: `boolean`
- default: `false`

Focus this output by default when niri starts.

If multiple outputs with `focus-at-startup` are connected, then the one with the key that sorts first will be focused. You can change the key to affect the sorting order, and set [`outputs.<name>.name`](#programsnirisettingsoutputsnamename) to be the actual name of the output.

When none of the connected outputs are explicitly focus-at-startup, niri will focus the first one sorted by name (same output sorting as used elsewhere in niri).


## `programs.niri.settings.outputs.<name>.mode`
- type: `null or (submodule)`
- default: `null`

The resolution and refresh rate of this display.

By default, when this is null, niri will automatically pick a mode for you.

If this is set to an invalid mode (i.e unsupported by this output), niri will act as if it is unset and pick one for you.


## `programs.niri.settings.outputs.<name>.mode.height`
- type: `signed integer`


## `programs.niri.settings.outputs.<name>.mode.refresh`
- type: `null or floating point number`
- default: `null`

The refresh rate of this output. When this is null, but the resolution is set, niri will automatically pick the highest available refresh rate.


## `programs.niri.settings.outputs.<name>.mode.width`
- type: `signed integer`


## `programs.niri.settings.outputs.<name>.name`
- type: `string`
- default: `the key of the output`

The name of the output. You set this manually if you want the outputs to be ordered in a specific way.


## `programs.niri.settings.outputs.<name>.position`
- type: `null or (submodule)`
- default: `null`

Position of the output in the global coordinate space.

This affects directional monitor actions like "focus-monitor-left", and cursor movement.

The cursor can only move between directly adjacent outputs.

Output scale has to be taken into account for positioning, because outputs are sized in logical pixels.

For example, a 3840x2160 output with scale 2.0 will have a logical size of 1920x1080, so to put another output directly adjacent to it on the right, set its x to 1920.

If the position is unset or multiple outputs overlap, niri will instead place the output automatically.


## `programs.niri.settings.outputs.<name>.position.x`
- type: `signed integer`


## `programs.niri.settings.outputs.<name>.position.y`
- type: `signed integer`


## `programs.niri.settings.outputs.<name>.scale`
- type: `null or floating point number or signed integer`
- default: `null`

The scale of this output, which represents how many physical pixels fit in one logical pixel.

If this is null, niri will automatically pick a scale for you.


## `programs.niri.settings.outputs.<name>.transform.flipped`
- type: `boolean`
- default: `false`

Whether to flip this output vertically.


## `programs.niri.settings.outputs.<name>.transform.rotation`
- type: `one of 0, 90, 180, 270`
- default: `0`

Counter-clockwise rotation of this output in degrees.


## `programs.niri.settings.outputs.<name>.variable-refresh-rate`
- type: `one of false, "on-demand", true`
- default: `false`

Whether to enable variable refresh rate (VRR) on this output.

VRR is also known as Adaptive Sync, FreeSync, and G-Sync.

Setting this to `"on-demand"` will enable VRR only when a window with [`window-rules.*.variable-refresh-rate`](#programsnirisettingswindow-rulesvariable-refresh-rate) is present on this output.


<!-- programs.niri.settings.cursor -->

## `programs.niri.settings.cursor.hide-after-inactive-ms`
- type: `null or signed integer`
- default: `null`

If set, the cursor will automatically hide once this number of milliseconds passes since the last cursor movement.


## `programs.niri.settings.cursor.hide-when-typing`
- type: `boolean`
- default: `false`

Whether to hide the cursor when typing.


## `programs.niri.settings.cursor.size`
- type: `signed integer`
- default: `24`

The size of the cursor in logical pixels.

This will also set the XCURSOR_SIZE environment variable for all spawned processes.


## `programs.niri.settings.cursor.theme`
- type: `string`
- default: `"default"`

The name of the xcursor theme to use.

This will also set the XCURSOR_THEME environment variable for all spawned processes.


<!-- programs.niri.settings.layout -->

## `programs.niri.settings.layout.border`


The border is a decoration drawn *inside* every window in the layout. It will take space away from windows. That is, if you have a border of 8px, then each window will be 8px smaller on each edge than if you had no border.

The currently focused window, i.e. the window that can receive keyboard input, will be drawn according to [`layout.border.active`](#programsnirisettingslayoutborderactive), and all other windows will be drawn according to [`layout.border.inactive`](#programsnirisettingslayoutborderinactive).

If you have [`layout.focus-ring`](#programsnirisettingslayoutfocus-ring) enabled, the border will be drawn inside (and over) the focus ring.


## `programs.niri.settings.layout.border.enable`
- type: `boolean`
- default: `false`

Whether to enable the border.


## `programs.niri.settings.layout.border.width`
- type: `floating point number or signed integer`
- default: `4`

The width of the border drawn around each window.


## `programs.niri.settings.layout.border.active`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the border for the window that has keyboard focus.


## `programs.niri.settings.layout.border.inactive`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the border for windows that do not have keyboard focus.


## `programs.niri.settings.layout.border.urgent`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the border for windows that are requesting attention.


## `programs.niri.settings.layout.focus-ring`


The focus ring is a decoration drawn *around* the last focused window on each monitor. It takes no space away from windows. If you have insufficient gaps, the focus ring can be drawn over adjacent windows, but it will never affect the layout of windows.

The focused window of the currently focused monitor, i.e. the window that can receive keyboard input, will be drawn according to [`layout.focus-ring.active`](#programsnirisettingslayoutfocus-ringactive), and the last focused window on all other monitors will be drawn according to [`layout.focus-ring.inactive`](#programsnirisettingslayoutfocus-ringinactive).

If you have [`layout.border`](#programsnirisettingslayoutborder) enabled, the focus ring will be drawn around (and under) the border.


## `programs.niri.settings.layout.focus-ring.enable`
- type: `boolean`
- default: `true`

Whether to enable the focus ring.


## `programs.niri.settings.layout.focus-ring.width`
- type: `floating point number or signed integer`
- default: `4`

The width of the focus ring drawn around each focused window.


## `programs.niri.settings.layout.focus-ring.active`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the focus ring for the window that has keyboard focus.


## `programs.niri.settings.layout.focus-ring.inactive`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the focus ring for windows that do not have keyboard focus.


## `programs.niri.settings.layout.focus-ring.urgent`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the focus ring for windows that are requesting attention.


<!-- programs.niri.settings.layout.shadow -->

## `programs.niri.settings.layout.shadow.color`
- type: `string`
- default: `"#00000070"`


## `programs.niri.settings.layout.shadow.draw-behind-window`
- type: `boolean`
- default: `false`


## `programs.niri.settings.layout.shadow.enable`
- type: `boolean`
- default: `false`


## `programs.niri.settings.layout.shadow.inactive-color`
- type: `null or string`
- default: `null`


## `programs.niri.settings.layout.shadow.offset`


The offset of the shadow from the window, measured in logical pixels.

This behaves like a [CSS box-shadow offset](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.layout.shadow.offset.x`
- type: `floating point number or signed integer`
- default: `0.000000`


## `programs.niri.settings.layout.shadow.offset.y`
- type: `floating point number or signed integer`
- default: `5.000000`


## `programs.niri.settings.layout.shadow.softness`
- type: `floating point number or signed integer`
- default: `30.000000`

The softness/size of the shadow, measured in logical pixels.

This behaves like a [CSS box-shadow blur radius](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.layout.shadow.spread`
- type: `floating point number or signed integer`
- default: `5.000000`

The spread of the shadow, measured in logical pixels.

This behaves like a [CSS box-shadow spread radius](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.layout.insert-hint`


The insert hint is a decoration drawn *between* windows during an interactive move operation. It is drawn in the gap where the window will be inserted when you release the window. It does not occupy any space in the gap, and the insert hint extends onto the edges of adjacent windows. When you release the moved window, the windows that are covered by the insert hint will be pushed aside to make room for the moved window.


## `programs.niri.settings.layout.insert-hint.enable`
- type: `boolean`
- default: `true`

Whether to enable the insert hint.


## `programs.niri.settings.layout.insert-hint.display`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the insert hint.


## `<decoration>`
- type: `attribute-tagged union`

A decoration is drawn around a surface, adding additional elements that are not necessarily part of an application, but are part of what we think of as a "window".

This type specifically represents decorations drawn by niri: that is, [`layout.focus-ring`](#programsnirisettingslayoutfocus-ring) and/or [`layout.border`](#programsnirisettingslayoutborder).


## `<decoration>.color`
- type: `string`

A solid color to use for the decoration.

This is a CSS [`<color>`](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) value, like `"rgb(255 0 0)"`, `"#C0FFEE"`, or `"sandybrown"`.

The specific crate that niri uses to parse this also supports some nonstandard color functions, like `hwba()`, `hsv()`, `hsva()`. See [`csscolorparser`](https://crates.io/crates/csscolorparser) for details.


## `<decoration>.gradient`
- type: `gradient`

A linear gradient to use for the decoration.

This is meant to approximate the CSS [`linear-gradient()`](https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient) function, but niri does not fully support all the same parameters. Only an angle in degrees is supported.


## `<decoration>.gradient.angle`
- type: `signed integer`
- default: `180`

The angle of the gradient, in degrees, measured clockwise from a gradient that starts at the bottom and ends at the top.

This is the same as the angle parameter in the CSS [`linear-gradient()`](https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient) function, except you can only express it in degrees.


## `<decoration>.gradient.from`
- type: `string`

The starting [`<color>`](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) of the gradient.

For more details, see [`<decoration>.color`](#decorationcolor).


## `<decoration>.gradient.in'`
- type: `null or one of "srgb", "srgb-linear", "oklab", "oklch shorter hue", "oklch longer hue", "oklch increasing hue", "oklch decreasing hue"`
- default: `null`

The colorspace to interpolate the gradient in. This option is named `in'` because `in` is a reserved keyword in Nix.

This is a subset of the [`<color-interpolation-method>`](https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method) values in CSS.


## `<decoration>.gradient.relative-to`
- type: `one of "window", "workspace-view"`
- default: `"window"`

The rectangle that this gradient is contained within.

If a gradient is `relative-to` the `"window"`, then the gradient will start and stop at the window bounds. If you have many windows, then the gradients will have many starts and stops.

![four windows arranged in two columns; a big window to the left of three stacked windows.
a gradient is drawn from the bottom left corner of each window, which is yellow, transitioning to red at the top right corner of each window.
the three vertical windows look identical, with a yellow and red corner, and the other two corners are slightly different shades of orange.
the big window has a yellow and red corner, with the top left corner being a very red orange orange, and the bottom right corner being a very yellow orange.
the top edge of the top stacked window has a noticeable transition from a yellowish orange to completely red.
](/assets/relative-to-window.png "behaviour of relative-to=\"window\"")


If the gradient is instead `relative-to` the `"workspace-view"`, then the gradient will start and stop at the bounds of your view. Windows decorations will take on the color values from just the part of the screen that they occupy

![four windows arranged in two columns; a big window to the left of three stacked windows.
a gradient is drawn from the bottom left corner of the workspace view, which is yellow, transitioning to red at the top right corner of the workspace view.
it looks like the gradient starts in the bottom left of the big window, and ends in the top right of the upper stacked window.
the bottom left corner of the top stacked window is a red orange color, and the bottom left corner of the middle stacked window is a more neutral orange color.
the bottom edge of the big window is almost entirely yellow, and the top edge of the top stacked window is almost entirely red.
](/assets/relative-to-workspace-view.png "behaviour of relative-to=\"workspace-view\"")


these beautiful images are sourced from the release notes for [`v0.1.3`](https://github.com/YaLTeR/niri/releases/tag/v0.1.3)


## `<decoration>.gradient.to`
- type: `string`

The ending [`<color>`](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) of the gradient.

For more details, see [`<decoration>.color`](#decorationcolor).


## `programs.niri.settings.layout.background-color`
- type: `null or string`
- default: `null`

The default background color that niri draws for workspaces. This is visible when you're not using any background tools like swaybg.


## `programs.niri.settings.layout.preset-column-widths`
- type: `list of attribute-tagged union`

The widths that `switch-preset-column-width` will cycle through.

Each width can either be a fixed width in logical pixels, or a proportion of the screen's width.

Example:

```nix
{
  programs.niri.settings.layout.preset-column-widths = [
    { proportion = 1. / 3.; }
    { proportion = 1. / 2.; }
    { proportion = 2. / 3.; }

    # { fixed = 1920; }
  ];
}
```



## `programs.niri.settings.layout.preset-column-widths.*.fixed`
- type: `signed integer`

The width of the column in logical pixels


## `programs.niri.settings.layout.preset-column-widths.*.proportion`
- type: `floating point number`

The width of the column as a proportion of the screen's width


## `programs.niri.settings.layout.preset-window-heights`
- type: `list of attribute-tagged union`

The heights that `switch-preset-window-height` will cycle through.

Each height can either be a fixed height in logical pixels, or a proportion of the screen's height.

Example:

```nix
{
  programs.niri.settings.layout.preset-window-heights = [
    { proportion = 1. / 3.; }
    { proportion = 1. / 2.; }
    { proportion = 2. / 3.; }

    # { fixed = 1080; }
  ];
}
```



## `programs.niri.settings.layout.preset-window-heights.*.fixed`
- type: `signed integer`

The height of the window in logical pixels


## `programs.niri.settings.layout.preset-window-heights.*.proportion`
- type: `floating point number`

The height of the window as a proportion of the screen's height


## `programs.niri.settings.layout.always-center-single-column`
- type: `boolean`
- default: `false`

This is like `center-focused-column = "always";`, but only for workspaces with a single column. Changes nothing if `center-focused-column` is set to `"always"`. Has no effect if more than one column is present.


## `programs.niri.settings.layout.center-focused-column`
- type: `one of "never", "always", "on-overflow"`
- default: `"never"`

When changing focus, niri can automatically center the focused column.

- `"never"`: If the focused column doesn't fit, it will be aligned to the edges of the screen.
- `"on-overflow"`: if the focused column doesn't fit, it will be centered on the screen.
- `"always"`: the focused column will always be centered, even if it was already fully visible.



## `programs.niri.settings.layout.default-column-display`
- type: `one of "normal", "tabbed"`
- default: `"normal"`

How windows in columns should be displayed by default.

- `"normal"`: Windows are arranged vertically, spread across the working area height.
- `"tabbed"`: Windows are arranged in tabs, with only the focused window visible, taking up the full height of the working area.


Note that you can override this for a given column at any time. Every column remembers its own display mode, independent from this setting. This setting controls the default value when a column is *created*.

Also, since a newly created column always contains a single window, you can override this default value with [`window-rules.*.default-column-display`](#programsnirisettingswindow-rulesdefault-column-display).


## `programs.niri.settings.layout.default-column-width`
- type: `{} or attribute-tagged union`

The default width for new columns.

When this is set to an empty attrset `{}`, windows will get to decide their initial width. This is not null, such that it can be distinguished from window rules that don't touch this

See [`layout.preset-column-widths`](#programsnirisettingslayoutpreset-column-widths) for more information.

You can override this for specific windows using [`window-rules.*.default-column-width`](#programsnirisettingswindow-rulesdefault-column-width)


## `programs.niri.settings.layout.default-column-width.fixed`
- type: `signed integer`

The width of the column in logical pixels


## `programs.niri.settings.layout.default-column-width.proportion`
- type: `floating point number`

The width of the column as a proportion of the screen's width


## `programs.niri.settings.layout.tab-indicator`
- type: `null or (submodule)`
- default: `null`


## `programs.niri.settings.layout.tab-indicator.corner-radius`
- type: `floating point number or signed integer`
- default: `0.000000`


## `programs.niri.settings.layout.tab-indicator.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.layout.tab-indicator.gap`
- type: `floating point number or signed integer`
- default: `5.000000`


## `programs.niri.settings.layout.tab-indicator.gaps-between-tabs`
- type: `floating point number or signed integer`
- default: `0.000000`


## `programs.niri.settings.layout.tab-indicator.hide-when-single-tab`
- type: `boolean`
- default: `false`


## `programs.niri.settings.layout.tab-indicator.length.total-proportion`
- type: `floating point number`
- default: `0.500000`


## `programs.niri.settings.layout.tab-indicator.place-within-column`
- type: `boolean`
- default: `false`


## `programs.niri.settings.layout.tab-indicator.position`
- type: `one of "left", "right", "top", "bottom"`
- default: `"left"`


## `programs.niri.settings.layout.tab-indicator.width`
- type: `floating point number or signed integer`
- default: `4.000000`


## `programs.niri.settings.layout.tab-indicator.active`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the tab indicator for the window that has keyboard focus.


## `programs.niri.settings.layout.tab-indicator.inactive`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the tab indicator for windows that do not have keyboard focus.


## `programs.niri.settings.layout.tab-indicator.urgent`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the tab indicator for windows that are requesting attention.


## `programs.niri.settings.layout.empty-workspace-above-first`
- type: `boolean`
- default: `false`

Normally, niri has a dynamic amount of workspaces, with one empty workspace at the end. The first workspace really is the first workspace, and you cannot go past it, but going past the last workspace puts you on the empty workspace.

When this is enabled, there will be an empty workspace above the first workspace, and you can go past the first workspace to get to an empty workspace, just as in the other direction. This makes workspace navigation symmetric in all ways except indexing.


## `programs.niri.settings.layout.gaps`
- type: `floating point number or signed integer`
- default: `16`

The gap between windows in the layout, measured in logical pixels.


## `programs.niri.settings.layout.struts`


The distances from the edges of the screen to the eges of the working area.

The top and bottom struts are absolute gaps from the edges of the screen. If you set a bottom strut of 64px and the scale is 2.0, then the output will have 128 physical pixels under the scrollable working area where it only shows the wallpaper.

Struts are computed in addition to layer-shell surfaces. If you have a waybar of 32px at the top, and you set a top strut of 16px, then you will have 48 logical pixels from the actual edge of the display to the top of the working area.

The left and right structs work in a similar way, except the padded space is not empty. The horizontal struts are used to constrain where focused windows are allowed to go. If you define a left strut of 64px and go to the first window in a workspace, that window will be aligned 64 logical pixels from the left edge of the output, rather than snapping to the actual edge of the screen. If another window exists to the left of this window, then you will see 64px of its right edge (if you have zero borders and gaps)


## `programs.niri.settings.layout.struts.bottom`
- type: `floating point number or signed integer`
- default: `0`


## `programs.niri.settings.layout.struts.left`
- type: `floating point number or signed integer`
- default: `0`


## `programs.niri.settings.layout.struts.right`
- type: `floating point number or signed integer`
- default: `0`


## `programs.niri.settings.layout.struts.top`
- type: `floating point number or signed integer`
- default: `0`


<!-- programs.niri.settings.animations -->

## `programs.niri.settings.animations.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.slowdown`
- type: `null or floating point number or signed integer`
- default: `null`


<!-- programs.niri.settings.animations.config-notification-open-close -->

## `programs.niri.settings.animations.config-notification-open-close.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.config-notification-open-close.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


<!-- programs.niri.settings.animations.exit-confirmation-open-close -->

## `programs.niri.settings.animations.exit-confirmation-open-close.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.exit-confirmation-open-close.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


<!-- programs.niri.settings.animations.horizontal-view-movement -->

## `programs.niri.settings.animations.horizontal-view-movement.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.horizontal-view-movement.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


<!-- programs.niri.settings.animations.overview-open-close -->

## `programs.niri.settings.animations.overview-open-close.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.overview-open-close.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


<!-- programs.niri.settings.animations.screenshot-ui-open -->

## `programs.niri.settings.animations.screenshot-ui-open.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.screenshot-ui-open.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


<!-- programs.niri.settings.animations.window-close -->

## `programs.niri.settings.animations.window-close.custom-shader`
- type: `null or string`
- default: `null`

Source code for a GLSL shader to use for this animation.

For example, set it to `builtins.readFile ./window-close.glsl` to use a shader from the same directory as your configuration file.

See: https://github.com/YaLTeR/niri/wiki/Configuration:-Animations#custom-shader


## `programs.niri.settings.animations.window-close.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.window-close.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


<!-- programs.niri.settings.animations.window-movement -->

## `programs.niri.settings.animations.window-movement.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.window-movement.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


<!-- programs.niri.settings.animations.window-open -->

## `programs.niri.settings.animations.window-open.custom-shader`
- type: `null or string`
- default: `null`

Source code for a GLSL shader to use for this animation.

For example, set it to `builtins.readFile ./window-open.glsl` to use a shader from the same directory as your configuration file.

See: https://github.com/YaLTeR/niri/wiki/Configuration:-Animations#custom-shader


## `programs.niri.settings.animations.window-open.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.window-open.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


<!-- programs.niri.settings.animations.window-resize -->

## `programs.niri.settings.animations.window-resize.custom-shader`
- type: `null or string`
- default: `null`

Source code for a GLSL shader to use for this animation.

For example, set it to `builtins.readFile ./window-resize.glsl` to use a shader from the same directory as your configuration file.

See: https://github.com/YaLTeR/niri/wiki/Configuration:-Animations#custom-shader


## `programs.niri.settings.animations.window-resize.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.window-resize.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


<!-- programs.niri.settings.animations.workspace-switch -->

## `programs.niri.settings.animations.workspace-switch.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.animations.workspace-switch.kind`
- type: `null or`[`<animation-kind>`](#animation-kind)
- default: `null`


## `<animation-kind>`
- type: `attribute-tagged union`


<!-- <animation-kind>.easing -->

## `<animation-kind>.easing.curve`
- type: `one of "linear", "ease-out-quad", "ease-out-cubic", "ease-out-expo", "cubic-bezier"`

The curve to use for the easing function.


## `<animation-kind>.easing.curve-args`
- type: `list of (null or string or signed integer or floating point number or boolean)`

Arguments to the easing curve. `cubic-bezier` requires 4 arguments, all others don't allow arguments.


## `<animation-kind>.easing.duration-ms`
- type: `signed integer`


<!-- <animation-kind>.spring -->

## `<animation-kind>.spring.damping-ratio`
- type: `floating point number`


## `<animation-kind>.spring.epsilon`
- type: `floating point number`


## `<animation-kind>.spring.stiffness`
- type: `signed integer`


## `programs.niri.settings.gestures.dnd-edge-view-scroll`


When dragging a window to the left or right edge of the screen, the view will start scrolling in that direction.


## `programs.niri.settings.gestures.dnd-edge-view-scroll.delay-ms`
- type: `null or signed integer`
- default: `null`

The delay in milliseconds before the view starts scrolling.


## `programs.niri.settings.gestures.dnd-edge-view-scroll.max-speed`
- type: `null or floating point number or signed integer`
- default: `null`

When the cursor is at boundary of the trigger width, the view will not be scrolling. Moving the mouse further away from the boundary and closer to the egde will linearly increase the scrolling speed, until the mouse is pressed against the edge of the screen, at which point the view will scroll at this speed. The speed is measured in logical pixels per second.


## `programs.niri.settings.gestures.dnd-edge-view-scroll.trigger-width`
- type: `null or floating point number or signed integer`
- default: `null`

The width of the edge of the screen where dragging a window will scroll the view.


## `programs.niri.settings.gestures.dnd-edge-workspace-switch`


In the overview, when dragging a window to the top or bottom edge of the screen, view will start scrolling in that direction.

This does not happen when the overview is not open.


## `programs.niri.settings.gestures.dnd-edge-workspace-switch.delay-ms`
- type: `null or signed integer`
- default: `null`

The delay in milliseconds before the view starts scrolling.


## `programs.niri.settings.gestures.dnd-edge-workspace-switch.max-speed`
- type: `null or floating point number or signed integer`
- default: `null`

When the cursor is at boundary of the trigger height, the view will not be scrolling. Moving the mouse further away from the boundary and closer to the egde will linearly increase the scrolling speed, until the mouse is pressed against the edge of the screen, at which point the view will scroll at this speed. The speed is measured in logical pixels per second.


## `programs.niri.settings.gestures.dnd-edge-workspace-switch.trigger-height`
- type: `null or floating point number or signed integer`
- default: `null`

The height of the edge of the screen where dragging a window will scroll the view.


## `programs.niri.settings.gestures.hot-corners.enable`
- type: `boolean`
- default: `true`

Put your mouse at the very top-left corner of a monitor to toggle the overview. Also works during drag-and-dropping something.


## `programs.niri.settings.environment`
- type: `attribute set of (null or string)`

Environment variables to set for processes spawned by niri.

If an environment variable is already set in the environment, then it will be overridden by the value set here.

If a value is null, then the environment variable will be unset, even if it already existed.

Examples:

```nix
{
  programs.niri.settings.environment = {
    QT_QPA_PLATFORM = "wayland";
    DISPLAY = null;
  };
}
```



## `programs.niri.settings.window-rules`
- type: `list of (window rule)`

Window rules.

A window rule will match based on [`window-rules.*.matches`](#programsnirisettingswindow-rulesmatches) and [`window-rules.*.excludes`](#programsnirisettingswindow-rulesexcludes). Both of these are lists of "match rules".

A given match rule can match based on one of several fields. For a given match rule to "match" a window, it must match on all fields.

- The `title` field, when non-null, is a regular expression. It will match a window if the client has set a title and its title matches the regular expression.
- The `app-id` field, when non-null, is a regular expression. It will match a window if the client has set an app id and its app id matches the regular expression.
- The `at-startup` field, when non-null, will match a window based on whether it was opened within the first 60 seconds of niri starting up.
- If a field is null, it will always match.


For a given window rule to match a window, the above logic is employed to determine whether any given match rule matches, and the interactions between the match rules decide whether the window rule as a whole will match. For a given window rule:

- A given window is "considered" if any of the match rules in [`window-rules.*.matches`](#programsnirisettingswindow-rulesmatches) successfully match this window. If all of the match rules do not match this window, then that window will never match this window rule.
- If [`window-rules.*.matches`](#programsnirisettingswindow-rulesmatches) contains no match rules, it will match any window and "consider" it for this window rule.
- If a given window is "considered" for this window rule according to the above rules, the selection can be further refined with [`window-rules.*.excludes`](#programsnirisettingswindow-rulesexcludes). If any of the match rules in `excludes` match this window, it will be rejected and this window rule will not match the given window.


That is, a given window rule will apply to a given window if any of the entries in [`window-rules.*.matches`](#programsnirisettingswindow-rulesmatches) match that window (or there are none), AND none of the entries in [`window-rules.*.excludes`](#programsnirisettingswindow-rulesexcludes) match that window.

All fields of a window rule can be set to null, which represents that the field shall have no effect on the window (and in general, the client is allowed to choose the initial value).

To compute the final set of window rules that apply to a given window, each window rule in this list is consdered in order.

At first, every field is set to null.

Then, for each applicable window rule:

- If a given field is null on this window rule, it has no effect. It does nothing and "inherits" the value from the previous rule.
- If the given field is not null, it will overwrite the value from any previous rule.


The "final value" of a field is simply its value at the end of this process. That is, the final value of a field is the one from the *last* window rule that matches the given window rule (not considering null entries, unless there are no non-null entries)

If the final value of a given field is null, then it usually means that the client gets to decide. For more information, see the documentation for each field.


## `programs.niri.settings.window-rules.*.matches`
- type: `list of (match rule)`

A list of rules to match windows.

If any of these rules match a window (or there are none), that window rule will be considered for this window. It can still be rejected by [`window-rules.*.excludes`](#programsnirisettingswindow-rulesexcludes)

If all of the rules do not match a window, then this window rule will not apply to that window.


## `programs.niri.settings.window-rules.*.matches.*.app-id`
- type: `null or regular expression` (where `regular expression` is a `string`)
- default: `null`

A regular expression to match against the app id of the window.

When non-null, for this field to match a window, a client must set the app id of its window and the app id must match this regex.


## `programs.niri.settings.window-rules.*.matches.*.title`
- type: `null or regular expression` (where `regular expression` is a `string`)
- default: `null`

A regular expression to match against the title of the window.

When non-null, for this field to match a window, a client must set the title of its window and the title must match this regex.


## `programs.niri.settings.window-rules.*.matches.*.is-active`
- type: `null or boolean`
- default: `null`

When non-null, for this field to match a window, the value must match whether the window is active or not.

Every monitor has up to one active window, and `is-active=true` will match the active window on each monitor. A monitor can have zero active windows if no windows are open on it. There can never be more than one active window on a monitor.


## `programs.niri.settings.window-rules.*.matches.*.is-active-in-column`
- type: `null or boolean`
- default: `null`

When non-null, for this field to match a window, the value must match whether the window is active in its column or not.

Every column has exactly one active-in-column window. If it is the active column, this window is also the active window. A column may not have zero active-in-column windows, or more than one active-in-column window.

The active-in-column window is the window that was last focused in that column. When you switch focus to a column, the active-in-column window will be the new focused window.


## `programs.niri.settings.window-rules.*.matches.*.is-floating`
- type: `null or boolean`
- default: `null`

When not-null, for this field to match a window, the value must match whether the window is floating (true) or tiled (false).


## `programs.niri.settings.window-rules.*.matches.*.is-focused`
- type: `null or boolean`
- default: `null`

When non-null, for this field to match a window, the value must match whether the window has keyboard focus or not.

A note on terminology used here: a window is actually a toplevel surface, and a surface just refers to any rectangular region that a client can draw to. A toplevel surface is just a surface with additional capabilities and properties (e.g. "fullscreen", "resizable", "min size", etc)

For a window to be focused, its surface must be focused. There is up to one focused surface, and it is the surface that can receive keyboard input. There can never be more than one focused surface. There can be zero focused surfaces if and only if there are zero surfaces. The focused surface does *not* have to be a toplevel surface. It can also be a layer-shell surface. In that case, there is a surface with keyboard focus but no *window* with keyboard focus.


## `programs.niri.settings.window-rules.*.matches.*.is-urgent`
- type: `null or boolean`
- default: `null`

When non-null, for this field to match a window, the value must match whether the window is in the urgent state or not.

A window can request attention by sending an XDG activation request. Such a request can be associated with an input event (e.g. in response to you clicking a notification), in which case it will be focused right away. It can also request attention without an input event, in which case it will simply be marked as "urgent". An urgent state doesn't do anything by itself, but it can be matched on to apply a window rule only to such windows.


## `programs.niri.settings.window-rules.*.matches.*.is-window-cast-target`
- type: `null or boolean`
- default: `null`

When non-null, matches based on whether the window is being targeted by a window cast.


## `programs.niri.settings.window-rules.*.matches.*.at-startup`
- type: `null or boolean`
- default: `null`

When true, this rule will match windows opened within the first 60 seconds of niri starting up. When false, this rule will match windows opened *more than* 60 seconds after niri started up. This is useful for applying different rules to windows opened from [`spawn-at-startup`](#programsnirisettingsspawn-at-startup) versus those opened later.


## `programs.niri.settings.window-rules.*.excludes`
- type: `list of (match rule)`

A list of rules to exclude windows.

If any of these rules match a window, then this window rule will not apply to that window, even if it matches one of the rules in [`window-rules.*.matches`](#programsnirisettingswindow-rulesmatches)

If none of these rules match a window, then this window rule will not be rejected. It will apply to that window if and only if it matches one of the rules in [`window-rules.*.matches`](#programsnirisettingswindow-rulesmatches)


## `programs.niri.settings.window-rules.*.excludes.*.app-id`
- type: `null or regular expression` (where `regular expression` is a `string`)
- default: `null`

A regular expression to match against the app id of the window.

When non-null, for this field to match a window, a client must set the app id of its window and the app id must match this regex.


## `programs.niri.settings.window-rules.*.excludes.*.title`
- type: `null or regular expression` (where `regular expression` is a `string`)
- default: `null`

A regular expression to match against the title of the window.

When non-null, for this field to match a window, a client must set the title of its window and the title must match this regex.


## `programs.niri.settings.window-rules.*.excludes.*.is-active`
- type: `null or boolean`
- default: `null`

When non-null, for this field to match a window, the value must match whether the window is active or not.

Every monitor has up to one active window, and `is-active=true` will match the active window on each monitor. A monitor can have zero active windows if no windows are open on it. There can never be more than one active window on a monitor.


## `programs.niri.settings.window-rules.*.excludes.*.is-active-in-column`
- type: `null or boolean`
- default: `null`

When non-null, for this field to match a window, the value must match whether the window is active in its column or not.

Every column has exactly one active-in-column window. If it is the active column, this window is also the active window. A column may not have zero active-in-column windows, or more than one active-in-column window.

The active-in-column window is the window that was last focused in that column. When you switch focus to a column, the active-in-column window will be the new focused window.


## `programs.niri.settings.window-rules.*.excludes.*.is-floating`
- type: `null or boolean`
- default: `null`

When not-null, for this field to match a window, the value must match whether the window is floating (true) or tiled (false).


## `programs.niri.settings.window-rules.*.excludes.*.is-focused`
- type: `null or boolean`
- default: `null`

When non-null, for this field to match a window, the value must match whether the window has keyboard focus or not.

A note on terminology used here: a window is actually a toplevel surface, and a surface just refers to any rectangular region that a client can draw to. A toplevel surface is just a surface with additional capabilities and properties (e.g. "fullscreen", "resizable", "min size", etc)

For a window to be focused, its surface must be focused. There is up to one focused surface, and it is the surface that can receive keyboard input. There can never be more than one focused surface. There can be zero focused surfaces if and only if there are zero surfaces. The focused surface does *not* have to be a toplevel surface. It can also be a layer-shell surface. In that case, there is a surface with keyboard focus but no *window* with keyboard focus.


## `programs.niri.settings.window-rules.*.excludes.*.is-urgent`
- type: `null or boolean`
- default: `null`

When non-null, for this field to match a window, the value must match whether the window is in the urgent state or not.

A window can request attention by sending an XDG activation request. Such a request can be associated with an input event (e.g. in response to you clicking a notification), in which case it will be focused right away. It can also request attention without an input event, in which case it will simply be marked as "urgent". An urgent state doesn't do anything by itself, but it can be matched on to apply a window rule only to such windows.


## `programs.niri.settings.window-rules.*.excludes.*.is-window-cast-target`
- type: `null or boolean`
- default: `null`

When non-null, matches based on whether the window is being targeted by a window cast.


## `programs.niri.settings.window-rules.*.excludes.*.at-startup`
- type: `null or boolean`
- default: `null`

When true, this rule will match windows opened within the first 60 seconds of niri starting up. When false, this rule will match windows opened *more than* 60 seconds after niri started up. This is useful for applying different rules to windows opened from [`spawn-at-startup`](#programsnirisettingsspawn-at-startup) versus those opened later.


## `programs.niri.settings.window-rules.*.default-column-display`
- type: `null or one of "normal", "tabbed"`
- default: `null`

When this window is inserted into the tiling layout such that a new column is created (e.g. when it is first opened, when it is expelled from an existing column, when it's moved to a new workspace, etc), this setting controls the default display mode of the column.

If the final value of this field is null, then the default display mode is taken from [`layout.default-column-display`](#programsnirisettingslayoutdefault-column-display).


## `programs.niri.settings.window-rules.*.default-column-width`
- type: `null or {} or attribute-tagged union`
- default: `null`

The default width for new columns.

If the final value of this option is null, it default to [`layout.default-column-width`](#programsnirisettingslayoutdefault-column-width)

If the final value option is not null, then its value will take priority over [`layout.default-column-width`](#programsnirisettingslayoutdefault-column-width) for windows matching this rule.

An empty attrset `{}` is not the same as null. When this is set to an empty attrset `{}`, windows will get to decide their initial width. When set to null, it represents that this particular window rule has no effect on the default width (and it should instead be taken from an earlier rule or the global default).



## `programs.niri.settings.window-rules.*.default-column-width.fixed`
- type: `signed integer`

The width of the column in logical pixels


## `programs.niri.settings.window-rules.*.default-column-width.proportion`
- type: `floating point number`

The width of the column as a proportion of the screen's width


## `programs.niri.settings.window-rules.*.default-window-height`
- type: `null or {} or attribute-tagged union`
- default: `null`

The default height for new floating windows.

This does nothing if the window is not floating when it is created.

There is no global default option for this in the layout section like for the column width. If the final value of this option is null, then it defaults to the empty attrset `{}`.

If this is set to an empty attrset `{}`, then it effectively "unsets" the default height for this window rule evaluation, as opposed to `null` which doesn't change the value at all. Future rules may still set it to a value and unset it again as they wish.

If the final value of this option is an empty attrset `{}`, then the client gets to decide the height of the window.

If the final value of this option is not an empty attrset `{}`, and the window spawns as floating, then the window will be created with the specified height.


## `programs.niri.settings.window-rules.*.default-window-height.fixed`
- type: `signed integer`

The height of the window in logical pixels


## `programs.niri.settings.window-rules.*.default-window-height.proportion`
- type: `floating point number`

The height of the window as a proportion of the screen's height


## `programs.niri.settings.window-rules.*.open-floating`
- type: `null or boolean`
- default: `null`

Whether to open this window as floating.

If the final value of this field is true, then this window will always be forced to open as floating.

If the final value of this field is false, then this window is never allowed to open as floating.

If the final value of this field is null, then niri will decide whether to open the window as floating or as tiled.


## `programs.niri.settings.window-rules.*.open-focused`
- type: `null or boolean`
- default: `null`

Whether to focus this window when it is opened.

If the final value of this field is null, then the window will be focused based on several factors:

- If it provided a valid activation token that hasn't expired, it will be focused.
- If the strict activation policy is enabled (not by default), the procedure ends here. It will be focused if and only if the activation token is valid.
- Otherwise, if no valid activation token was presented, but the window is a dialog, it will open next to its parent and be focused anyways.
- If the window is not a dialog, it will be focused if there is no fullscreen window; we don't want to steal its focus unless a dialog belongs to it.


(a dialog here means a toplevel surface that has a non-null parent)

If the final value of this field is not null, all of the above is ignored. Whether the window provides an activation token or not, doesn't matter. The window will be focused if and only if this field is true. If it is false, the window will not be focused, even if it provides a valid activation token.


## `programs.niri.settings.window-rules.*.open-fullscreen`
- type: `null or boolean`
- default: `null`

Whether to open this window in fullscreen.

If the final value of this field is true, then this window will always be forced to open in fullscreen.

If the final value of this field is false, then this window is never allowed to open in fullscreen, even if it requests to do so.

If the final value of this field is null, then the client gets to decide if this window will open in fullscreen.


## `programs.niri.settings.window-rules.*.open-maximized`
- type: `null or boolean`
- default: `null`

Whether to open this window in a maximized column.

If the final value of this field is null or false, then the window will not open in a maximized column.

If the final value of this field is true, then the window will open in a maximized column.


## `programs.niri.settings.window-rules.*.open-on-output`
- type: `null or string`
- default: `null`

The output to open this window on.

If final value of this field is an output that exists, the new window will open on that output.

If the final value is an output that does not exist, or it is null, then the window opens on the currently focused output.


## `programs.niri.settings.window-rules.*.open-on-workspace`
- type: `null or string`
- default: `null`

The workspace to open this window on.

If the final value of this field is a named workspace that exists, the window will open on that workspace.

If the final value of this is a named workspace that does not exist, or it is null, the window opens on the currently focused workspace.


## `programs.niri.settings.window-rules.*.block-out-from`
- type: `null or one of "screencast", "screen-capture"`
- default: `null`

Whether to block out this window from screen captures. When the final value of this field is null, it is not blocked out from screen captures.

This is useful to protect sensitive information, like the contents of password managers or private chats. It is very important to understand the implications of this option, as described below, **especially if you are a streamer or content creator**.

Some of this may be obvious, but in general, these invariants *should* hold true:
- a window is never meant to be blocked out from the actual physical screen (otherwise you wouldn't be able to see it at all)
- a `block-out-from` window *is* meant to be always blocked out from screencasts (as they are often used for livestreaming etc)
- a `block-out-from` window is *not* supposed to be blocked from screenshots (because usually these are not broadcasted live, and you generally know what you're taking a screenshot of)


There are three methods of screencapture in niri:

1. The `org.freedesktop.portal.ScreenCast` interface, which is used by tools like OBS primarily to capture video. When `block-out-from = "screencast";` or `block-out-from = "screen-capture";`, this window is blocked out from the screencast portal, and will not be visible to screencasting software making use of the screencast portal.
1. The `wlr-screencopy` protocol, which is used by tools like `grim` primarily to capture screenshots. When `block-out-from = "screencast";`, this protocol is not affected and tools like `grim` can still capture the window just fine. This is because you may still want to take a screenshot of such windows. However, some screenshot tools display a fullscreen overlay with a frozen image of the screen, and then capture that. This overlay is *not* blocked out in the same way, and may leak the window contents to an active screencast. When `block-out-from = "screen-capture";`, this window is blocked out from `wlr-screencopy` and thus will never leak in such a case, but of course it will always be blocked out from screenshots and (sometimes) the physical screen.
1. The built in `screenshot` action, implemented in niri itself. This tool works similarly to those based on `wlr-screencopy`, but being a part of the compositor gets superpowers regarding secrecy of window contents. Its frozen overlay will never leak window contents to an active screencast, because information of blocked windows and can be distinguished for the physical output and screencasts. `block-out-from` does not affect the built in screenshot tool at all, and you can always take a screenshot of any window.


| `block-out-from` | can `ScreenCast`? | can `screencopy`? | can `screenshot`? |
| --- | :---: | :---: | :---: |
| `null` | yes | yes | yes |
| `"screencast"` | no | yes | yes |
| `"screen-capture"` | no | no | yes |


> [!caution]
> **Streamers: Do not accidentally leak window contents via screenshots.**
> 
> For windows where `block-out-from = "screencast";`, contents of a window may still be visible in a screencast, if the window is indirectly displayed by a tool using `wlr-screencopy`.
> 
> If you are a streamer, either:
> - make sure not to use `wlr-screencopy` tools that display a preview during your stream, or
> - **set `block-out-from = "screen-capture";` to ensure that the window is never visible in a screencast.**


> [!caution]
> **Do not let malicious `wlr-screencopy` clients capture your top secret windows.**
> 
> (and don't let malicious software run on your system in the first place, you silly goose)
> 
> For windows where `block-out-from = "screencast";`, contents of a window will still be visible to any application using `wlr-screencopy`, even if you did not consent to this application capturing your screen.
> 
> Note that sandboxed clients restricted via security context (i.e. Flatpaks) do not have access to `wlr-screencopy` at all, and are not a concern.
> 
> **If a window's contents are so secret that they must never be captured by any (non-sandboxed) application, set `block-out-from = "screen-capture";`.**


Essentially, use `block-out-from = "screen-capture";` if you want to be sure that the window is never visible to any external tool no matter what; or use `block-out-from = "screencast";` if you want to be able to capture screenshots of the window without its contents normally being visible in a screencast. (at the risk of some tools still leaking the window contents, see above)


## `programs.niri.settings.window-rules.*.border`


See [`layout.border`](#programsnirisettingslayoutborder).


## `programs.niri.settings.window-rules.*.border.enable`
- type: `null or boolean`
- default: `null`

Whether to enable the border.


## `programs.niri.settings.window-rules.*.border.width`
- type: `null or floating point number or signed integer`
- default: `null`

The width of the border drawn around each matched window.


## `programs.niri.settings.window-rules.*.border.active`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the border for the window that has keyboard focus.


## `programs.niri.settings.window-rules.*.border.inactive`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the border for windows that do not have keyboard focus.


## `programs.niri.settings.window-rules.*.border.urgent`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the border for windows that are requesting attention.


## `programs.niri.settings.window-rules.*.clip-to-geometry`
- type: `null or boolean`
- default: `null`

Whether to clip the window to its visual geometry, i.e. whether the corner radius should be applied to the window surface itself or just the decorations.


## `programs.niri.settings.window-rules.*.draw-border-with-background`
- type: `null or boolean`
- default: `null`

Whether to draw the focus ring and border with a background.

Normally, for windows with server-side decorations, niri will draw an actual border around them, because it knows they will be rectangular.

Because client-side decorations can take on arbitrary shapes, most notably including rounded corners, niri cannot really know the "correct" place to put a border, so for such windows it will draw a solid rectangle behind them instead.

For most windows, this looks okay. At worst, you have some uneven/jagged borders, instead of a gaping hole in the region outside of the corner radius of the window but inside its bounds.

If you wish to make windows sucha s your terminal transparent, and they use CSD, this is very undesirable. Instead of showing your wallpaper, you'll get a solid rectangle.

You can set this option per window to override niri's default behaviour, and instruct it to omit the border background for CSD windows. You can also explicitly enable it for SSD windows.


## `programs.niri.settings.window-rules.*.focus-ring`


See [`layout.focus-ring`](#programsnirisettingslayoutfocus-ring).


## `programs.niri.settings.window-rules.*.focus-ring.enable`
- type: `null or boolean`
- default: `null`

Whether to enable the focus ring.


## `programs.niri.settings.window-rules.*.focus-ring.width`
- type: `null or floating point number or signed integer`
- default: `null`

The width of the focus ring drawn around each matched window with focus.


## `programs.niri.settings.window-rules.*.focus-ring.active`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the focus ring for the window that has keyboard focus.


## `programs.niri.settings.window-rules.*.focus-ring.inactive`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the focus ring for windows that do not have keyboard focus.


## `programs.niri.settings.window-rules.*.focus-ring.urgent`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

The color of the focus ring for windows that are requesting attention.


## `programs.niri.settings.window-rules.*.geometry-corner-radius`
- type: `null or (submodule)`
- default: `null`

The corner radii of the window decorations (border, focus ring, and shadow) in logical pixels.

By default, the actual window surface will be unaffected by this.

Set [`window-rules.*.clip-to-geometry`](#programsnirisettingswindow-rulesclip-to-geometry) to true to clip the window to its visual geometry, i.e. apply the corner radius to the window surface itself.


## `programs.niri.settings.window-rules.*.geometry-corner-radius.bottom-left`
- type: `floating point number`


## `programs.niri.settings.window-rules.*.geometry-corner-radius.bottom-right`
- type: `floating point number`


## `programs.niri.settings.window-rules.*.geometry-corner-radius.top-left`
- type: `floating point number`


## `programs.niri.settings.window-rules.*.geometry-corner-radius.top-right`
- type: `floating point number`


## `programs.niri.settings.window-rules.*.opacity`
- type: `null or floating point number`
- default: `null`

The opacity of the window, ranging from 0 to 1.

If the final value of this field is null, niri will fall back to a value of 1.

Note that this is applied in addition to the opacity set by the client. Setting this to a semitransparent value on a window that is already semitransparent will make it even more transparent.


<!-- programs.niri.settings.window-rules.*.shadow -->

## `programs.niri.settings.window-rules.*.shadow.color`
- type: `null or string`
- default: `null`


## `programs.niri.settings.window-rules.*.shadow.draw-behind-window`
- type: `null or boolean`
- default: `null`


## `programs.niri.settings.window-rules.*.shadow.enable`
- type: `null or boolean`
- default: `null`


## `programs.niri.settings.window-rules.*.shadow.inactive-color`
- type: `null or string`
- default: `null`


## `programs.niri.settings.window-rules.*.shadow.offset`
- type: `null or (submodule)`
- default: `null`

The offset of the shadow from the window, measured in logical pixels.

This behaves like a [CSS box-shadow offset](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.window-rules.*.shadow.offset.x`
- type: `floating point number or signed integer`


## `programs.niri.settings.window-rules.*.shadow.offset.y`
- type: `floating point number or signed integer`


## `programs.niri.settings.window-rules.*.shadow.softness`
- type: `null or floating point number or signed integer`
- default: `null`

The softness/size of the shadow, measured in logical pixels.

This behaves like a [CSS box-shadow blur radius](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.window-rules.*.shadow.spread`
- type: `null or floating point number or signed integer`
- default: `null`

The spread of the shadow, measured in logical pixels.

This behaves like a [CSS box-shadow spread radius](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


<!-- programs.niri.settings.window-rules.*.tab-indicator -->

## `programs.niri.settings.window-rules.*.tab-indicator.active`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

See [`layout.tab-indicator.active`](#programsnirisettingslayouttab-indicatoractive).


## `programs.niri.settings.window-rules.*.tab-indicator.inactive`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

See [`layout.tab-indicator.inactive`](#programsnirisettingslayouttab-indicatorinactive).


## `programs.niri.settings.window-rules.*.tab-indicator.urgent`
- type: `null or`[`<decoration>`](#decoration)
- default: `null`

See [`layout.tab-indicator.urgent`](#programsnirisettingslayouttab-indicatorurgent).


## `programs.niri.settings.window-rules.*.max-height`
- type: `null or signed integer`
- default: `null`

Sets the maximum height (in logical pixels) that niri will ever ask this window for.

Keep in mind that the window itself always has a final say in its size, and may not respect the maximum height set by this option.


Also, note that the maximum height is not taken into account when automatically sizing columns. That is, when a column is created normally, windows in it will be "automatically sized" to fill the vertical space. This algorithm will respect a minimum height, and not make windows any smaller than that, but the max height is only taken into account if it is equal to the min height. In other words, it will only accept a "fixed height" or a "minimum height". In practice, most windows do not set a max size unless it is equal to their min size, so this is usually not a problem without window rules.

If you manually change the window heights, then max-height will be taken into account and restrict you from making it any taller, as you'd intuitively expect.


## `programs.niri.settings.window-rules.*.max-width`
- type: `null or signed integer`
- default: `null`

Sets the maximum width (in logical pixels) that niri will ever ask this window for.

Keep in mind that the window itself always has a final say in its size, and may not respect the maximum width set by this option.


## `programs.niri.settings.window-rules.*.min-height`
- type: `null or signed integer`
- default: `null`

Sets the minimum height (in logical pixels) that niri will ever ask this window for.

Keep in mind that the window itself always has a final say in its size, and may not respect the minimum height set by this option.


## `programs.niri.settings.window-rules.*.min-width`
- type: `null or signed integer`
- default: `null`

Sets the minimum width (in logical pixels) that niri will ever ask this window for.

Keep in mind that the window itself always has a final say in its size, and may not respect the minimum width set by this option.


## `programs.niri.settings.window-rules.*.baba-is-float`
- type: `null or boolean`
- default: `null`

Makes your window FLOAT up and down, like in the game Baba Is You.

Made for April Fools 2025.


## `programs.niri.settings.window-rules.*.default-floating-position`
- type: `null or (submodule)`
- default: `null`

The default position for this window when it enters the floating layout.

If a window is created as floating, it will be placed at this position.

If a window is created as tiling, then later made floating, it will be placed at this position.

If a window has already been placed as floating through one of the above methods, and moved back to the tiling layout, then this option has no effect the next time it enters the floating layout. It will be placed at the same position it was last time.

The `x` and `y` fields are the distances from the edge of the screen to the edge of the window, in logical pixels. The `relative-to` field determines which two edges of the window and screen that these distances are measured from.


## `programs.niri.settings.window-rules.*.default-floating-position.relative-to`
- type: `one of "top-left", "top-right", "bottom-left", "bottom-right", "top", "bottom", "left", "right"`


## `programs.niri.settings.window-rules.*.default-floating-position.x`
- type: `floating point number or signed integer`


## `programs.niri.settings.window-rules.*.default-floating-position.y`
- type: `floating point number or signed integer`


## `programs.niri.settings.window-rules.*.variable-refresh-rate`
- type: `null or boolean`
- default: `null`

Takes effect only when the window is on an output with [`outputs.<name>.variable-refresh-rate`](#programsnirisettingsoutputsnamevariable-refresh-rate) set to `"on-demand"`. If the final value of this field is true, then the output will enable variable refresh rate when this window is present on it.


## `programs.niri.settings.window-rules.*.scroll-factor`
- type: `null or floating point number or signed integer`
- default: `null`


## `programs.niri.settings.window-rules.*.tiled-state`
- type: `null or boolean`
- default: `null`


## `programs.niri.settings.layer-rules`
- type: `list of (layer rule)`

Layer rules.

A layer rule will match based on [`layer-rules.*.matches`](#programsnirisettingslayer-rulesmatches) and [`layer-rules.*.excludes`](#programsnirisettingslayer-rulesexcludes). Both of these are lists of "match rules".

A given match rule can match based on one of several fields. For a given match rule to "match" a layer surface, it must match on all fields.

- The `namespace` field, when non-null, is a regular expression. It will match a layer surface for which the client has set a namespace that matches the regular expression.
- The `at-startup` field, when non-null, will match a layer surface based on whether it was opened within the first 60 seconds of niri starting up.
- If a field is null, it will always match.


For a given layer rule to match a layer surface, the above logic is employed to determine whether any given match rule matches, and the interactions between the match rules decide whether the layer rule as a whole will match. For a given layer rule:

- A given layer surface is "considered" if any of the match rules in [`layer-rules.*.matches`](#programsnirisettingslayer-rulesmatches) successfully match this layer surface. If all of the match rules do not match this layer surface, then that layer surface will never match this layer rule.
- If [`layer-rules.*.matches`](#programsnirisettingslayer-rulesmatches) contains no match rules, it will match any layer surface and "consider" it for this layer rule.
- If a given layer surface is "considered" for this layer rule according to the above rules, the selection can be further refined with [`layer-rules.*.excludes`](#programsnirisettingslayer-rulesexcludes). If any of the match rules in `excludes` match this layer surface, it will be rejected and this layer rule will not match the given layer surface.


That is, a given layer rule will apply to a given layer surface if any of the entries in [`layer-rules.*.matches`](#programsnirisettingslayer-rulesmatches) match that layer surface (or there are none), AND none of the entries in [`layer-rules.*.excludes`](#programsnirisettingslayer-rulesexcludes) match that layer surface.

All fields of a layer rule can be set to null, which represents that the field shall have no effect on the layer surface (and in general, the client is allowed to choose the initial value).

To compute the final set of layer rules that apply to a given layer surface, each layer rule in this list is consdered in order.

At first, every field is set to null.

Then, for each applicable layer rule:

- If a given field is null on this layer rule, it has no effect. It does nothing and "inherits" the value from the previous rule.
- If the given field is not null, it will overwrite the value from any previous rule.


The "final value" of a field is simply its value at the end of this process. That is, the final value of a field is the one from the *last* layer rule that matches the given layer rule (not considering null entries, unless there are no non-null entries)

If the final value of a given field is null, then it usually means that the client gets to decide. For more information, see the documentation for each field.


## `programs.niri.settings.layer-rules.*.matches`
- type: `list of (match rule)`

A list of rules to match layer surfaces.

If any of these rules match a layer surface (or there are none), that layer rule will be considered for this layer surface. It can still be rejected by [`layer-rules.*.excludes`](#programsnirisettingslayer-rulesexcludes)

If all of the rules do not match a layer surface, then this layer rule will not apply to that layer surface.


## `programs.niri.settings.layer-rules.*.matches.*.namespace`
- type: `null or regular expression` (where `regular expression` is a `string`)
- default: `null`

A regular expression to match against the namespace of the layer surface.

All layer surfaces have a namespace set once at creation. When this rule is non-null, the regex must match the namespace of the layer surface for this rule to match.


## `programs.niri.settings.layer-rules.*.matches.*.at-startup`
- type: `null or boolean`
- default: `null`

When true, this rule will match layer surfaces opened within the first 60 seconds of niri starting up. When false, this rule will match layer surfaces opened *more than* 60 seconds after niri started up. This is useful for applying different rules to layer surfaces opened from [`spawn-at-startup`](#programsnirisettingsspawn-at-startup) versus those opened later.


## `programs.niri.settings.layer-rules.*.excludes`
- type: `list of (match rule)`

A list of rules to exclude layer surfaces.

If any of these rules match a layer surface, then this layer rule will not apply to that layer surface, even if it matches one of the rules in [`layer-rules.*.matches`](#programsnirisettingslayer-rulesmatches)

If none of these rules match a layer surface, then this layer rule will not be rejected. It will apply to that layer surface if and only if it matches one of the rules in [`layer-rules.*.matches`](#programsnirisettingslayer-rulesmatches)


## `programs.niri.settings.layer-rules.*.excludes.*.namespace`
- type: `null or regular expression` (where `regular expression` is a `string`)
- default: `null`

A regular expression to match against the namespace of the layer surface.

All layer surfaces have a namespace set once at creation. When this rule is non-null, the regex must match the namespace of the layer surface for this rule to match.


## `programs.niri.settings.layer-rules.*.excludes.*.at-startup`
- type: `null or boolean`
- default: `null`

When true, this rule will match layer surfaces opened within the first 60 seconds of niri starting up. When false, this rule will match layer surfaces opened *more than* 60 seconds after niri started up. This is useful for applying different rules to layer surfaces opened from [`spawn-at-startup`](#programsnirisettingsspawn-at-startup) versus those opened later.


## `programs.niri.settings.layer-rules.*.block-out-from`
- type: `null or one of "screencast", "screen-capture"`
- default: `null`

Whether to block out this layer surface from screen captures. When the final value of this field is null, it is not blocked out from screen captures.

This is useful to protect sensitive information, like the contents of password managers or private chats. It is very important to understand the implications of this option, as described below, **especially if you are a streamer or content creator**.

Some of this may be obvious, but in general, these invariants *should* hold true:
- a layer surface is never meant to be blocked out from the actual physical screen (otherwise you wouldn't be able to see it at all)
- a `block-out-from` layer surface *is* meant to be always blocked out from screencasts (as they are often used for livestreaming etc)
- a `block-out-from` layer surface is *not* supposed to be blocked from screenshots (because usually these are not broadcasted live, and you generally know what you're taking a screenshot of)


There are three methods of screencapture in niri:

1. The `org.freedesktop.portal.ScreenCast` interface, which is used by tools like OBS primarily to capture video. When `block-out-from = "screencast";` or `block-out-from = "screen-capture";`, this layer surface is blocked out from the screencast portal, and will not be visible to screencasting software making use of the screencast portal.
1. The `wlr-screencopy` protocol, which is used by tools like `grim` primarily to capture screenshots. When `block-out-from = "screencast";`, this protocol is not affected and tools like `grim` can still capture the layer surface just fine. This is because you may still want to take a screenshot of such layer surfaces. However, some screenshot tools display a fullscreen overlay with a frozen image of the screen, and then capture that. This overlay is *not* blocked out in the same way, and may leak the layer surface contents to an active screencast. When `block-out-from = "screen-capture";`, this layer surface is blocked out from `wlr-screencopy` and thus will never leak in such a case, but of course it will always be blocked out from screenshots and (sometimes) the physical screen.
1. The built in `screenshot` action, implemented in niri itself. This tool works similarly to those based on `wlr-screencopy`, but being a part of the compositor gets superpowers regarding secrecy of layer surface contents. Its frozen overlay will never leak layer surface contents to an active screencast, because information of blocked layer surfaces and can be distinguished for the physical output and screencasts. `block-out-from` does not affect the built in screenshot tool at all, and you can always take a screenshot of any layer surface.


| `block-out-from` | can `ScreenCast`? | can `screencopy`? | can `screenshot`? |
| --- | :---: | :---: | :---: |
| `null` | yes | yes | yes |
| `"screencast"` | no | yes | yes |
| `"screen-capture"` | no | no | yes |


> [!caution]
> **Streamers: Do not accidentally leak layer surface contents via screenshots.**
> 
> For layer surfaces where `block-out-from = "screencast";`, contents of a layer surface may still be visible in a screencast, if the layer surface is indirectly displayed by a tool using `wlr-screencopy`.
> 
> If you are a streamer, either:
> - make sure not to use `wlr-screencopy` tools that display a preview during your stream, or
> - **set `block-out-from = "screen-capture";` to ensure that the layer surface is never visible in a screencast.**


> [!caution]
> **Do not let malicious `wlr-screencopy` clients capture your top secret layer surfaces.**
> 
> (and don't let malicious software run on your system in the first place, you silly goose)
> 
> For layer surfaces where `block-out-from = "screencast";`, contents of a layer surface will still be visible to any application using `wlr-screencopy`, even if you did not consent to this application capturing your screen.
> 
> Note that sandboxed clients restricted via security context (i.e. Flatpaks) do not have access to `wlr-screencopy` at all, and are not a concern.
> 
> **If a layer surface's contents are so secret that they must never be captured by any (non-sandboxed) application, set `block-out-from = "screen-capture";`.**


Essentially, use `block-out-from = "screen-capture";` if you want to be sure that the layer surface is never visible to any external tool no matter what; or use `block-out-from = "screencast";` if you want to be able to capture screenshots of the layer surface without its contents normally being visible in a screencast. (at the risk of some tools still leaking the layer surface contents, see above)


## `programs.niri.settings.layer-rules.*.opacity`
- type: `null or floating point number`
- default: `null`

The opacity of the layer surface, ranging from 0 to 1.

If the final value of this field is null, niri will fall back to a value of 1.

Note that this is applied in addition to the opacity set by the client. Setting this to a semitransparent value on a layer surface that is already semitransparent will make it even more transparent.


## `programs.niri.settings.layer-rules.*.geometry-corner-radius`
- type: `null or (submodule)`
- default: `null`

The corner radii of the surface decorations (shadow) in logical pixels.


## `programs.niri.settings.layer-rules.*.geometry-corner-radius.bottom-left`
- type: `floating point number`


## `programs.niri.settings.layer-rules.*.geometry-corner-radius.bottom-right`
- type: `floating point number`


## `programs.niri.settings.layer-rules.*.geometry-corner-radius.top-left`
- type: `floating point number`


## `programs.niri.settings.layer-rules.*.geometry-corner-radius.top-right`
- type: `floating point number`


<!-- programs.niri.settings.layer-rules.*.shadow -->

## `programs.niri.settings.layer-rules.*.shadow.color`
- type: `null or string`
- default: `null`


## `programs.niri.settings.layer-rules.*.shadow.draw-behind-window`
- type: `null or boolean`
- default: `null`


## `programs.niri.settings.layer-rules.*.shadow.enable`
- type: `null or boolean`
- default: `null`


## `programs.niri.settings.layer-rules.*.shadow.inactive-color`
- type: `null or string`
- default: `null`


## `programs.niri.settings.layer-rules.*.shadow.offset`
- type: `null or (submodule)`
- default: `null`

The offset of the shadow from the window, measured in logical pixels.

This behaves like a [CSS box-shadow offset](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.layer-rules.*.shadow.offset.x`
- type: `floating point number or signed integer`


## `programs.niri.settings.layer-rules.*.shadow.offset.y`
- type: `floating point number or signed integer`


## `programs.niri.settings.layer-rules.*.shadow.softness`
- type: `null or floating point number or signed integer`
- default: `null`

The softness/size of the shadow, measured in logical pixels.

This behaves like a [CSS box-shadow blur radius](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.layer-rules.*.shadow.spread`
- type: `null or floating point number or signed integer`
- default: `null`

The spread of the shadow, measured in logical pixels.

This behaves like a [CSS box-shadow spread radius](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax)


## `programs.niri.settings.layer-rules.*.baba-is-float`
- type: `null or boolean`
- default: `null`

Make your layer surfaces FLOAT up and down.

This is a natural extension of the April Fools' 2025 feature.


## `programs.niri.settings.layer-rules.*.place-within-backdrop`
- type: `null or boolean`
- default: `null`

Set to `true` to place the surface into the backdrop visible in the Overview and between workspaces.
This will only work for background layer surfaces that ignore exclusive zones (typical for wallpaper tools). Layers within the backdrop will ignore all input.


## `programs.niri.settings.xwayland-satellite`


Xwayland-satellite integration. Requires unstable niri and unstable xwayland-satellite.


## `programs.niri.settings.xwayland-satellite.enable`
- type: `boolean`
- default: `true`


## `programs.niri.settings.xwayland-satellite.path`
- type: `null or string`
- default: `null`

Path to the xwayland-satellite binary.

Set it to something like `lib.getExe pkgs.xwayland-satellite-unstable`.


## `programs.niri.settings.debug`
- type: `attribute set of kdl arguments`

Debug options for niri.

`kdl arguments` in the type refers to a list of arguments passed to a node under the `debug` section. This is a way to pass arbitrary KDL-valid data to niri. See [`binds.<name>.action`](#programsnirisettingsbindsnameaction) for more information on all the ways you can use this.

Note that for no-argument nodes, there is no special way to define them here. You can't pass them as just a "string" because that makes no sense here. You must pass it an empty array of arguments.

Here's an example of how to use this:

```nix
{
  programs.niri.settings.debug = {
    disable-cursor-plane = [];
    render-drm-device = "/dev/dri/renderD129";
  };
}
```


This option is, just like [`binds.<name>.action`](#programsnirisettingsbindsnameaction), not verified by the nix module. But, it will be validated by niri before committing the config.

Additionally, i don't guarantee stability of the debug options. They may change at any time without prior notice, either because of niri changing the available options, or because of me changing this to a more reasonable schema.
</file>

<file path="fetch-refs.nix">
with builtins;
let
  fetch =
    repo:
    foldl' (x: f: f x) "https://api.github.com/repos/${repo}/git/refs/tags" [
      fetchurl
      readFile
      fromJSON

      (map (
        y:
        if y.object.type == "tag" then
          # on basically all releases, the ref points to a tag
          # this is neat, because it wraps the commit hash in a `tag` name.
          foldl' (x: f: f x) y.object.url [
            fetchurl
            readFile
            fromJSON
          ]
        else
          let
            startsWith = prefix: string: substring 0 (stringLength prefix) string == prefix;
            removePrefix =
              prefix: string:
              assert startsWith prefix string;
              substring (stringLength prefix) (stringLength string) string;
          in
          # but on some releases, the ref directly points to the commit
          # then we have to manually extract the ""tag"" name (not a real tag; but to humans there is no difference)
          y // { tag = removePrefix "refs/tags/" y.ref; }
      ))

      (filter (x: x.object.type == "commit"))

      (map (x: ''"${x.object.sha}" = "${x.tag}";''))

      (concatStringsSep "\n  ")
    ];
in
''
  # This file is generated automatically by fetch-refs.nix
  # Do not edit it manually, your changes will be lost.
  #
  # Both niri and xwayland-satellite are listed.
  # This is because commit hashes are globally unique.
  {
    # niri
    ${fetch "YaLTeR/niri"}
    # xwayland-satellite
    ${fetch "Supreeeme/xwayland-satellite"}
  }
''
</file>

<file path="flake.lock">
{
  "nodes": {
    "niri-stable": {
      "flake": false,
      "locked": {
        "lastModified": 1756556321,
        "narHash": "sha256-RLD89dfjN0RVO86C/Mot0T7aduCygPGaYbog566F0Qo=",
        "owner": "YaLTeR",
        "repo": "niri",
        "rev": "01be0e65f4eb91a9cd624ac0b76aaeab765c7294",
        "type": "github"
      },
      "original": {
        "owner": "YaLTeR",
        "ref": "v25.08",
        "repo": "niri",
        "type": "github"
      }
    },
    "niri-unstable": {
      "flake": false,
      "locked": {
        "lastModified": 1758691861,
        "narHash": "sha256-CYgoGrY/Fx+hjzp8graTxJw1M7mn1f2jBkK26M04T0s=",
        "owner": "YaLTeR",
        "repo": "niri",
        "rev": "e837e39623457dc5ad29c34a5ce4d4616e5fbf1e",
        "type": "github"
      },
      "original": {
        "owner": "YaLTeR",
        "repo": "niri",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1758427187,
        "narHash": "sha256-pHpxZ/IyCwoTQPtFIAG2QaxuSm8jWzrzBGjwQZIttJc=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "554be6495561ff07b6c724047bdd7e0716aa7b46",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs-stable": {
      "locked": {
        "lastModified": 1758589230,
        "narHash": "sha256-zMTCFGe8aVGTEr2RqUi/QzC1nOIQ0N1HRsbqB4f646k=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "d1d883129b193f0b495d75c148c2c3a7d95789a0",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-25.05",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "niri-stable": "niri-stable",
        "niri-unstable": "niri-unstable",
        "nixpkgs": "nixpkgs",
        "nixpkgs-stable": "nixpkgs-stable",
        "xwayland-satellite-stable": "xwayland-satellite-stable",
        "xwayland-satellite-unstable": "xwayland-satellite-unstable"
      }
    },
    "xwayland-satellite-stable": {
      "flake": false,
      "locked": {
        "lastModified": 1755491097,
        "narHash": "sha256-m+9tUfsmBeF2Gn4HWa6vSITZ4Gz1eA1F5Kh62B0N4oE=",
        "owner": "Supreeeme",
        "repo": "xwayland-satellite",
        "rev": "388d291e82ffbc73be18169d39470f340707edaa",
        "type": "github"
      },
      "original": {
        "owner": "Supreeeme",
        "ref": "v0.7",
        "repo": "xwayland-satellite",
        "type": "github"
      }
    },
    "xwayland-satellite-unstable": {
      "flake": false,
      "locked": {
        "lastModified": 1758577423,
        "narHash": "sha256-sB2GAOjhjoWnjU6A/uHNJiY6O3UeztV5pJAN2g1FkXU=",
        "owner": "Supreeeme",
        "repo": "xwayland-satellite",
        "rev": "03368548ba745e17a85bd631613a59cb2d8469a4",
        "type": "github"
      },
      "original": {
        "owner": "Supreeeme",
        "repo": "xwayland-satellite",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  description = "A scrollable-tiling Wayland compositor.";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    nixpkgs-stable.url = "github:NixOS/nixpkgs/nixos-25.05";

    niri-stable.url = "github:YaLTeR/niri/v25.08";
    niri-unstable.url = "github:YaLTeR/niri";

    xwayland-satellite-stable.url = "github:Supreeeme/xwayland-satellite/v0.7";
    xwayland-satellite-unstable.url = "github:Supreeeme/xwayland-satellite";

    # they do all have flakes, but we specifically want just the Rust sources and no flakes.
    niri-stable.flake = false;
    niri-unstable.flake = false;
    xwayland-satellite-stable.flake = false;
    xwayland-satellite-unstable.flake = false;
  };

  outputs =
    inputs@{
      self,
      nixpkgs,
      nixpkgs-stable,
      ...
    }:
    let
      call = nixpkgs.lib.flip import {
        inherit
          inputs
          kdl
          docs
          binds
          settings
          ;
        inherit (nixpkgs) lib;
      };
      kdl = call ./kdl.nix;
      binds = call ./parse-binds.nix;
      docs = call ./generate-docs.nix;
      html-docs = call ./generate-html-docs.nix;
      settings = call ./settings.nix;
      stylix-module = call ./stylix.nix;

      stable-revs = import ./refs.nix;

      date = {
        year = builtins.substring 0 4;
        month = builtins.substring 4 2;
        day = builtins.substring 6 2;
        hour = builtins.substring 8 2;
        minute = builtins.substring 10 2;
        second = builtins.substring 12 2;
      };

      fmt-date = raw: "${date.year raw}-${date.month raw}-${date.day raw}";
      fmt-time = raw: "${date.hour raw}:${date.minute raw}:${date.second raw}";

      version-string =
        src:
        if stable-revs ? ${src.rev} then
          "stable ${stable-revs.${src.rev}} (commit ${src.rev})"
        else
          "unstable ${fmt-date src.lastModifiedDate} (commit ${src.rev})";

      package-version =
        src:
        if stable-revs ? ${src.rev} then
          nixpkgs.lib.removePrefix "v" stable-revs.${src.rev}
        else
          "unstable-${fmt-date src.lastModifiedDate}-${src.shortRev}";

      make-niri =
        {
          src,
          patches ? [ ],
          rustPlatform,
          pkg-config,
          installShellFiles,
          wayland,
          systemdLibs,
          eudev,
          pipewire,
          libgbm,
          libglvnd,
          seatd,
          libinput,
          libxkbcommon,
          libdisplay-info,
          pango,
          withDbus ? true,
          withDinit ? false,
          withScreencastSupport ? true,
          withSystemd ? true,
          fetchzip,
          runCommand,
        }:
        rustPlatform.buildRustPackage {
          pname = "niri";
          version = package-version src;
          src = src;
          inherit patches;
          cargoLock = {
            lockFile = "${src}/Cargo.lock";
            allowBuiltinFetchGit = true;
          };
          nativeBuildInputs = [
            pkg-config
            rustPlatform.bindgenHook
            installShellFiles
          ];

          buildInputs = [
            wayland
            libgbm
            libglvnd
            seatd
            libinput
            libdisplay-info
            libxkbcommon
            pango
          ]
          ++ nixpkgs.lib.optional withScreencastSupport pipewire
          ++ nixpkgs.lib.optional withSystemd systemdLibs # we only need udev, really.
          ++ nixpkgs.lib.optional (!withSystemd) eudev; # drop-in replacement for systemd-udev

          checkFlags = [
            # Some tests require surfaceless OpenGL displays. The "surfaceless" part means we don't need a Wayland or Xorg server;
            # but they still fundamentally require GPU drivers, which are only (sometimes) present at runtime.
            "--skip=::egl"
          ];

          buildNoDefaultFeatures = true;
          buildFeatures =
            nixpkgs.lib.optional withDbus "dbus"
            ++ nixpkgs.lib.optional withDinit "dinit"
            ++ nixpkgs.lib.optional withScreencastSupport "xdp-gnome-screencast"
            ++ nixpkgs.lib.optional withSystemd "systemd";

          passthru.providedSessions = [ "niri" ];

          # we want backtraces to be readable
          dontStrip = true;

          RUSTFLAGS = [
            "-C link-arg=-Wl,--push-state,--no-as-needed"
            "-C link-arg=-lEGL"
            "-C link-arg=-lwayland-client"
            "-C link-arg=-Wl,--pop-state"

            "-C debuginfo=line-tables-only"
          ];

          NIRI_BUILD_VERSION_STRING = version-string src;

          outputs = [
            "out"
            "doc"
          ];

          # previously, the second line was part of RUSTFLAGS above
          # but i noticed it stopped working? because it doesn't interpolate the env var anymore.
          #
          # i don't know when or why it stopped working. but moving it here fixes it.
          # the first line was unnecessary previously because this should be the default
          # https://github.com/NixOS/nixpkgs/blob/11cf80ae321c35132c1aff950f026e9783f06fec/pkgs/build-support/rust/build-rust-crate/build-crate.nix#L19
          # but for some reason it isn't. so i'm doing it manually.
          #
          # the purpose is to make backtraces more readable. the first line strips the useless `/build` prefix
          # and the second line makes niri-related paths more obvious as if they were based on pwd with `cargo run`
          postPatch = ''
            export RUSTFLAGS="$RUSTFLAGS --remap-path-prefix $NIX_BUILD_TOP=/"
            export RUSTFLAGS="$RUSTFLAGS --remap-path-prefix $NIX_BUILD_TOP/source=./"

            patchShebangs resources/niri-session
          '';

          postInstall =
            # niri.desktop calls `niri-session` and that executable only works with systemd or dinit
            nixpkgs.lib.optionalString (withSystemd || withDinit) ''
              install -Dm0755 resources/niri-session -t $out/bin
              install -Dm0644 resources/niri.desktop -t $out/share/wayland-sessions
            ''
            # any of these features will enable dbus support
            + nixpkgs.lib.optionalString (withDbus || withScreencastSupport || withSystemd) ''
              install -Dm0644 resources/niri-portals.conf -t $out/share/xdg-desktop-portal
            ''
            + nixpkgs.lib.optionalString withSystemd ''
              install -Dm0644 resources/niri{-shutdown.target,.service} -t $out/lib/systemd/user
            ''
            + nixpkgs.lib.optionalString withDinit ''
              install -Dm0644 resources/dinit/niri{,-shutdown} -t $out/lib/dinit.d/user
            ''
            # TODO: add nushell after nixos-25.11
            + ''
              installShellCompletion --cmd niri \
                --bash <($out/bin/niri completions bash) \
                --zsh <($out/bin/niri completions zsh) \
                --fish <($out/bin/niri completions fish)

              install -Dm0644 README.md resources/default-config.kdl -t $doc/share/doc/niri
              mv docs/wiki $doc/share/doc/niri/wiki
            '';

          postFixup = ''
            substituteInPlace $out/lib/systemd/user/niri.service --replace-fail /usr/bin $out/bin
          '';

          meta = {
            description = "Scrollable-tiling Wayland compositor";
            homepage = "https://github.com/YaLTeR/niri";
            license = nixpkgs.lib.licenses.gpl3Only;
            maintainers = with nixpkgs.lib.maintainers; [ sodiboo ];
            mainProgram = "niri";
            platforms = nixpkgs.lib.platforms.linux;
          };
        };

      validated-config-for =
        pkgs: package: config:
        pkgs.runCommand "config.kdl"
          {
            inherit config;
            passAsFile = [ "config" ];
            buildInputs = [ package ];
          }
          ''
            niri validate -c $configPath
            cp $configPath $out
          '';

      make-xwayland-satellite =
        {
          src,
          patches ? [ ],
          rustPlatform,
          pkg-config,
          makeWrapper,
          xwayland,
          xcb-util-cursor,
          withSystemd ? true,
        }:
        rustPlatform.buildRustPackage {
          pname = "xwayland-satellite";
          version = package-version src;
          inherit src patches;
          cargoLock = {
            lockFile = "${src}/Cargo.lock";
            allowBuiltinFetchGit = true;
          };
          nativeBuildInputs = [
            pkg-config
            rustPlatform.bindgenHook
            makeWrapper
          ];

          buildInputs = [
            xcb-util-cursor
          ];

          buildNoDefaultFeatures = true;
          buildFeatures = nixpkgs.lib.optional withSystemd "systemd";

          # All tests require a display server to be running.
          doCheck = false;

          # https://github.com/Supreeeme/xwayland-satellite/blob/388d291e82ffbc73be18169d39470f340707edaa/src/lib.rs#L51
          # https://github.com/rustyhorde/vergen/blob/9374f497395238b68ec4c6b43f69c4a78a111121/vergen-gitcl/src/lib.rs#L232
          VERGEN_GIT_DESCRIBE = version-string src;

          postInstall = ''
            wrapProgram $out/bin/xwayland-satellite \
              --prefix PATH : "${nixpkgs.lib.makeBinPath [ xwayland ]}"
          ''
          + nixpkgs.lib.optionalString withSystemd ''
            install -Dm0644 resources/xwayland-satellite.service -t $out/lib/systemd/user
          '';

          postFixup = nixpkgs.lib.optionalString withSystemd ''
            substituteInPlace $out/lib/systemd/user/xwayland-satellite.service \
              --replace-fail /usr/local/bin $out/bin
          '';

          meta = {
            description = "Rootless Xwayland integration to any Wayland compositor implementing xdg_wm_base";
            homepage = "https://github.com/Supreeeme/xwayland-satellite";
            license = nixpkgs.lib.licenses.mpl20;
            maintainers = with nixpkgs.lib.maintainers; [ sodiboo ];
            mainProgram = "xwayland-satellite";
            platforms = nixpkgs.lib.platforms.linux;
          };
        };

      make-package-set = pkgs: {
        niri-stable = pkgs.callPackage make-niri {
          src = inputs.niri-stable;
        };
        niri-unstable = pkgs.callPackage make-niri {
          src = inputs.niri-unstable;
        };
        xwayland-satellite-stable = pkgs.callPackage make-xwayland-satellite {
          src = inputs.xwayland-satellite-stable;
        };
        xwayland-satellite-unstable = pkgs.callPackage make-xwayland-satellite {
          src = inputs.xwayland-satellite-unstable;
        };
      };

      combined-closure =
        pkgs-name: pkgs:
        pkgs.runCommand "niri-flake-packages-for-${pkgs-name}" { } (
          ''
            mkdir $out
          ''
          + builtins.concatStringsSep "" (
            nixpkgs.lib.mapAttrsToList (name: package: ''
              ln -s ${package} $out/${name}
            '') (make-package-set pkgs)
          )
        );

      cached-packages-for =
        system:
        nixpkgs.legacyPackages.${system}.runCommand "all-niri-flake-packages" { } (
          ''
            mkdir $out
          ''
          + builtins.concatStringsSep "" (
            nixpkgs.lib.mapAttrsToList
              (name: nixpkgs': ''
                ln -s ${combined-closure name nixpkgs'.legacyPackages.${system}} $out/${name}
              '')
              {
                nixos-unstable = nixpkgs;
                "nixos-25.05" = nixpkgs-stable;
              }
          )
        );

      systems = [
        "x86_64-linux"
        "aarch64-linux"
      ];

      forAllSystems = nixpkgs.lib.genAttrs systems;
    in
    {
      lib = {
        inherit kdl;
        internal = {
          inherit make-package-set validated-config-for;
          package-set = abort "niri-flake internals: `package-set.\${package} pkgs` is now `(make-package-set pkgs).\${package}`";
          docs-markdown = docs.make-docs (settings.fake-docs { inherit fmt-date fmt-time; });
          docs-html = html-docs.make-docs (settings.type-with html-docs.settings-fmt);
          settings-module = settings.module;
          memo-binds = nixpkgs.lib.pipe (binds "${inputs.niri-unstable}/niri-config/src/binds.rs") [
            (map (bind: "  \"${bind.name}\""))
            (builtins.concatStringsSep "\n")
            (memo'd: ''
              # This is a generated file.
              # It caches the output of `parse-binds.nix` for the latest niri-unstable.
              # That script is slow and also now exceeds the default call depth limit.
              # So, we memoize it here. It doesn't change anyway.
              [
              ${memo'd}
              ]
            '')
          ];
        };
      };

      packages = forAllSystems (system: make-package-set inputs.nixpkgs.legacyPackages.${system});

      overlays.niri = final: prev: make-package-set final;

      apps = forAllSystems (
        system:
        (builtins.mapAttrs (name: package: {
          type = "app";
          program = nixpkgs.lib.getExe package;
        }) (make-package-set inputs.nixpkgs.legacyPackages.${system}))
        // {
          default = self.apps.${system}.niri-stable;
        }
      );

      formatter = forAllSystems (system: inputs.nixpkgs.legacyPackages.${system}.nixfmt-rfc-style);

      devShells = forAllSystems (system: {
        default = import ./shell.nix {
          flake = self;
          inherit system;
        };
      });

      homeModules.stylix = stylix-module;
      homeModules.config =
        {
          config,
          pkgs,
          ...
        }:
        let
          cfg = config.programs.niri;
        in
        {
          imports = [
            settings.module
          ];

          options.programs.niri = {
            package = nixpkgs.lib.mkOption {
              type = nixpkgs.lib.types.package;
              default = (make-package-set pkgs).niri-stable;
              description = "The niri package to use.";
            };
          };

          config.lib.niri = {
            actions = nixpkgs.lib.mergeAttrsList (
              map (name: {
                ${name} = kdl.magic-leaf name;
              }) (import ./memo-binds.nix)
            );
          };

          config.xdg.configFile.niri-config = {
            enable = cfg.finalConfig != null;
            target = "niri/config.kdl";
            source = validated-config-for pkgs cfg.package cfg.finalConfig;
          };
        };
      nixosModules.niri =
        {
          config,
          options,
          pkgs,
          ...
        }:
        let
          cfg = config.programs.niri;
        in
        {
          # The module from this flake predates the module in nixpkgs by a long shot.
          # To avoid conflicts, we disable the nixpkgs module.
          # Eventually, this module (e.g. `niri.nixosModules.niri`) will be deprecated
          # in favour of other modules that aren't redundant with nixpkgs (and don't yet exist)
          disabledModules = [ "programs/wayland/niri.nix" ];

          options.programs.niri = {
            enable = nixpkgs.lib.mkEnableOption "niri";
            package = nixpkgs.lib.mkOption {
              type = nixpkgs.lib.types.package;
              default = (make-package-set pkgs).niri-stable;
              description = "The niri package to use.";
            };
          };

          options.niri-flake.cache.enable = nixpkgs.lib.mkEnableOption "the niri-flake binary cache" // {
            default = true;
          };

          config = nixpkgs.lib.mkMerge [
            (nixpkgs.lib.mkIf config.niri-flake.cache.enable {
              nix.settings = {
                substituters = [ "https://niri.cachix.org" ];
                trusted-public-keys = [ "niri.cachix.org-1:Wv0OmO7PsuocRKzfDoJ3mulSl7Z6oezYhGhR+3W2964=" ];
              };
            })
            (nixpkgs.lib.mkIf cfg.enable {
              environment.systemPackages = [
                pkgs.xdg-utils
                cfg.package
              ];
              xdg = {
                autostart.enable = nixpkgs.lib.mkDefault true;
                menus.enable = nixpkgs.lib.mkDefault true;
                mime.enable = nixpkgs.lib.mkDefault true;
                icons.enable = nixpkgs.lib.mkDefault true;
              };

              services.displayManager.sessionPackages = [ cfg.package ];
              hardware.graphics.enable = nixpkgs.lib.mkDefault true;

              xdg.portal = {
                enable = true;
                extraPortals = nixpkgs.lib.mkIf (
                  !cfg.package.cargoBuildNoDefaultFeatures
                  || builtins.elem "xdp-gnome-screencast" cfg.package.cargoBuildFeatures
                ) [ pkgs.xdg-desktop-portal-gnome ];
                configPackages = [ cfg.package ];
              };

              security.polkit.enable = true;
              services.gnome.gnome-keyring.enable = true;
              systemd.user.services.niri-flake-polkit = {
                description = "PolicyKit Authentication Agent provided by niri-flake";
                wantedBy = [ "niri.service" ];
                after = [ "graphical-session.target" ];
                partOf = [ "graphical-session.target" ];
                serviceConfig = {
                  Type = "simple";
                  ExecStart = "${pkgs.kdePackages.polkit-kde-agent-1}/libexec/polkit-kde-authentication-agent-1";
                  Restart = "on-failure";
                  RestartSec = 1;
                  TimeoutStopSec = 10;
                };
              };

              security.pam.services.swaylock = { };
              programs.dconf.enable = nixpkgs.lib.mkDefault true;
              fonts.enableDefaultPackages = nixpkgs.lib.mkDefault true;
            })
            (nixpkgs.lib.optionalAttrs (options ? home-manager) {
              home-manager.sharedModules = [
                self.homeModules.config
                { programs.niri.package = nixpkgs.lib.mkForce cfg.package; }
              ]
              ++ nixpkgs.lib.optionals (options ? stylix) [ self.homeModules.stylix ];
            })
          ];
        };
      homeModules.niri =
        {
          config,
          pkgs,
          ...
        }:
        let
          cfg = config.programs.niri;
        in
        {
          imports = [
            self.homeModules.config
          ];
          options.programs.niri = {
            enable = nixpkgs.lib.mkEnableOption "niri";
          };

          config = nixpkgs.lib.mkIf cfg.enable {
            home.packages = [ cfg.package ];
            services.gnome-keyring.enable = true;
            xdg.portal = {
              enable = true;
              extraPortals = nixpkgs.lib.mkIf (
                !cfg.package.cargoBuildNoDefaultFeatures
                || builtins.elem "xdp-gnome-screencast" cfg.package.cargoBuildFeatures
              ) [ pkgs.xdg-desktop-portal-gnome ];
              configPackages = [ cfg.package ];
            };
          };
        };

      checks = forAllSystems (
        system:
        let
          test-nixos-for =
            nixpkgs: modules:
            (nixpkgs.lib.nixosSystem {
              inherit system;
              modules = [
                {
                  # This doesn't need to be a bootable system. It just needs to build.
                  system.stateVersion = "23.11";
                  fileSystems."/".fsType = "ext4";
                  fileSystems."/".device = "/dev/sda1";
                  boot.loader.systemd-boot.enable = true;
                }
              ]
              ++ modules;
            }).config.system.build.toplevel;
        in
        {
          cached-packages = cached-packages-for system;
          empty-config-valid-stable =
            let
              eval = nixpkgs.lib.evalModules {
                modules = [
                  settings.module
                  {
                    config.programs.niri.settings = { };
                  }
                ];
              };
            in
            validated-config-for inputs.nixpkgs.legacyPackages.${system} self.packages.${system}.niri-stable
              eval.config.programs.niri.finalConfig;

          nixos-unstable = test-nixos-for nixpkgs [
            self.nixosModules.niri
            {
              programs.niri.enable = true;
            }
          ];

          nixos-stable = test-nixos-for nixpkgs-stable [
            self.nixosModules.niri
            {
              programs.niri.enable = true;
            }
          ];
        }
      );
    };
}
</file>

<file path="generate-docs.nix">
{
  inputs,
  lib,
  ...
}:
let
  showOption = lib.concatStringsSep ".";
  match = name: cases: cases.${name} or cases._;
  indent =
    entries:
    "${lib.pipe entries [
      lib.toList
      (lib.concatStringsSep "\n")
      (lib.splitString "\n")
      (map (s: "  ${s}"))
      (lib.concatStringsSep "\n")
    ]}";

  delimit-pretty =
    start: content: end:
    lib.concatStringsSep "\n" [
      start
      content
      end
    ];
  delimit-min =
    start: content: end:
    lib.concatStrings [
      start
      content
      end
    ];
  display-value =
    {
      pretty ? true,
      omit-empty-composites ? false,
    }:
    let
      display-value' = display-value { inherit pretty; };
      indent' = if pretty then indent else lib.id;
      delimit' = if pretty then delimit-pretty else delimit-min;
    in
    v:
    match (builtins.typeOf v) {
      string = lib.strings.escapeNixString v;
      int = toString v;
      float = toString v;
      bool = if v then "true" else "false";
      set =
        if v == { } then
          if omit-empty-composites then null else "{}"
        else
          delimit' "{" (indent' (lib.mapAttrsToList (name: val: "${name} = ${display-value' val};") v)) "}";
      null = "null";
      list =
        if v == [ ] then
          if omit-empty-composites then null else "[]"
        else
          delimit' "[" (indent' (map display-value' v)) "]";
      _ = "<${(builtins.typeOf v)}>";
    };

  maybe = f: v: if v != null then f v else null;

  unstable-note = ''
    > [!important]
    > This option is not yet available in stable niri.
    >
    > If you wish to modify this option, you should make sure ${link' "programs.niri.package"} is set to ${pkg-link "niri-unstable"}.
    >
    > Otherwise, your system might fail to build.
  '';

  unstable-enum = values: ''
    > [!important]
    > The following values for this option are not yet available in stable niri:
    >
    ${lib.pipe values [
      (map (display-value {
        pretty = false;
      }))
      (map (s: "> - `${s}`"))
      (lib.concatStringsSep "\n")
    ]}
    >
    > If you wish to use one of the mentioned values, you should make sure ${link' "programs.niri.package"} is set to ${pkg-link "niri-unstable"}.
    >
    > Otherwise, your system might fail to build.
  '';

  section =
    contents:
    lib.mkOption {
      type = lib.mkOptionType { name = "docs-override"; };
      description = contents;
    };

  header = title: section "# ${title}";
  fake-option =
    loc: contents:
    section ''
      ## `${loc}`

      ${contents}
    '';

  link-niri-commit =
    {
      rev,
      shortRev,
    }:
    "[`${shortRev}`](https://github.com/YaLTeR/niri/tree/${rev})";
  link-niri-release =
    version: "[`${version}`](https://github.com/YaLTeR/niri/releases/tag/${version})";

  link-stylix-opt = opt: "[`${opt}`](https://danth.github.io/stylix/options/hm.html#${anchor opt})";

  link-this-github =
    path: "https://github.com/sodiboo/niri-flake/blob/${inputs.self.rev or "main"}/${path}";

  test = pat: str: lib.strings.match pat str != null;

  anchor = lib.flip lib.pipe [
    (lib.replaceStrings (lib.upperChars ++ [ " " ]) (lib.lowerChars ++ [ "-" ]))
    (lib.splitString "")
    (lib.filter (test "[a-z0-9-]"))
    lib.concatStrings
  ];
  anchor' = loc: anchor "`${loc}`";

  link = title: "[${title}](#${anchor title})";
  link' = loc: "[`${lib.removePrefix "programs.niri.settings." loc}`](#${anchor "`${loc}`"})";

  module-doc =
    name: desc: opts:
    {
      _ = section ''
        # `${name}`

        ${desc}
      '';
    }
    // opts;

  pkg-header = name: "packages.<system>.${name}";
  pkg-link = name: "[`pkgs.${name}`](#${anchor' (pkg-header name)})";

  nixpkgs-link =
    name: "[`pkgs.${name}`](https://search.nixos.org/packages?channel=unstable&show=${name})";

  libinput-link =
    page: header: "https://wayland.freedesktop.org/libinput/doc/latest/${page}.html#${anchor header}";

  libinput-doc = page: header: "[${header}](${libinput-link page header})";

  make-default =
    text:
    if lib.length (lib.splitString "\n" text) == 1 then
      "- default: `${text}`"
    else
      ''
        - default:
        ${indent (delimit-pretty "```nix" text "```")}
      '';

  describe-type =
    type:
    let
      span = content: "`${content}`";
    in
    if type.name == "rename" then
      (span type.description) + ", which is a ${describe-type type.nestedTypes.real}"
    else if type.name == "shorthand" then
      link' "${type.description}"
    else if type.name == "nullOr" && type.nestedTypes.elemType.name == "rename" then
      span type.description
      + " (where ${span type.nestedTypes.elemType.description} is a ${describe-type type.nestedTypes.elemType.nestedTypes.real})"
    else if type.name == "nullOr" && type.nestedTypes.elemType.name == "shorthand" then
      span "null or" + link' "${type.nestedTypes.elemType.description}"
    else
      span type.description;

  describe-type' = type: lib.replaceStrings [ "``" ] [ "" ] (describe-type type);

  render-option =
    opt:
    assert opt._type or null == "option";
    lib.optional (opt.visible != false) (

      if opt.type.name == "docs-override" then
        "${opt.description}"
      else if opt.type.name == "submodule" && opt.description or null == null then
        "<!-- ${showOption opt.loc} -->"
      else
        lib.concatStringsSep "\n" (
          lib.remove null [
            "## ${opt.override-header or "`${showOption opt.loc}`"}"
            (
              let
                described = describe-type' opt.type;
              in
              lib.optionalString (described != "`submodule`") "- type: ${described}"
            )
            (maybe make-default opt.defaultText)
            ""
            (maybe lib.id opt.description or null)
          ]
        )
    )
    ++ lib.optionals (opt.visible == true) (render-suboptions opt.loc (opt.type.getSubOptions opt.loc));

  render-suboptions =
    loc: options:
    assert !(options ? _type);
    let
      to-list = lib.mapAttrsToList (name: opt: { inherit name opt; });

      options' =
        if options ? _module.niri-flake-ordered-record then
          let
            ord-record = options._module.niri-flake-ordered-record;
            ordering = ord-record.ordering.value;
            extra-docs-options = ord-record.extra-docs-options;

            ordering' = builtins.listToAttrs (
              lib.imap0 (i: v: {
                name = v;
                value = i;
              }) ordering
            );
            max-ordering = builtins.length ordering;
          in
          builtins.sort (
            a: b: (ordering'.${a.name} or max-ordering) < (ordering'.${b.name} or max-ordering)
          ) (to-list (builtins.removeAttrs (options // extra-docs-options) [ "_module" ]))
        else
          to-list (builtins.removeAttrs options [ "_module" ]);

    in
    builtins.concatMap (
      { name, opt }:
      if opt ? _type then
        render-option (
          opt
          // {
            defaultText =
              opt.defaultText
                or (if opt ? default then display-value { omit-empty-composites = true; } opt.default else null);
            visible = if opt.niri-flake-document-internal or false then true else opt.visible or true;
            loc = opt.override-loc or lib.id opt.loc;
          }
        )
      else
        render-suboptions (loc ++ [ name ]) opt
    ) options';

  make-docs = lib.flip lib.pipe [
    lib.types.submodule
    (m: m.getSubOptions [ ])
    (render-suboptions [ ])
    (lib.concatStringsSep "\n\n")
  ];
in
{
  inherit make-docs;
  lib = {
    inherit
      unstable-note
      unstable-enum
      section
      header
      fake-option
      test
      anchor
      anchor'
      link
      link'
      module-doc
      pkg-header
      pkg-link
      nixpkgs-link
      libinput-link
      libinput-doc
      link-niri-commit
      link-niri-release
      link-stylix-opt
      link-this-github
      display-value
      ;
  };

  settings-fmt =
    let
      body = lib.strings.trimWith { end = true; };

      indent-except-first-line =
        text:
        let
          lines = lib.splitString "\n" text;
          lines' = [ (builtins.head lines) ] ++ (map (line: "  ${line}") (builtins.tail lines));
        in

        if lines == [ ] then "" else builtins.concatStringsSep "\n" lines';
    in
    rec {
      link-to-setting = loc: "#${anchor' "`${showOption loc}`"}";

      bare-link = url: url;
      masked-link =
        {
          href,
          content,
        }:
        "[${content}](${href})";

      block-quote =
        content:
        lib.pipe content [
          body
          (lib.splitString "\n")
          (map (s: "> ${s}\n"))
          lib.concatStrings
        ];

      code = code: "`${code}`";

      admonition = lib.genAttrs [ "note" "tip" "important" "warning" "caution" ] (
        kind: content:
        block-quote ''
          [!${kind}]
          ${content}
        ''
      );

      list = items: ''
        ${lib.concatStringsSep "\n" (map (item: "- ${indent-except-first-line (body item)}") items)}
      '';
      ordered-list = items: ''
        ${lib.concatStringsSep "\n" (map (item: "1. ${indent-except-first-line (body item)}") items)}
      '';

      nix-code-block = code: ''
        ```nix
        ${body code}
        ```
      '';

      em = text: "*${text}*";
      strong = text: "**${text}**";

      table =
        {
          headers,
          align,
          rows,
        }:
        assert (builtins.length headers == builtins.length align);
        ''
          | ${builtins.concatStringsSep " | " headers} |
          | ${
            builtins.concatStringsSep " | " (
              map (
                align:
                if align == null then
                  "---"
                else
                  {
                    left = ":---";
                    center = ":---:";
                    right = "---:";
                  }
                  .${align}
              ) align
            )
          } |
          ${lib.concatStringsSep "\n" (
            map (
              row:
              assert builtins.length headers == builtins.length row;
              "| ${builtins.concatStringsSep " | " row} |"
            ) rows
          )}
        '';

      kbd = code;

      img =
        {
          src,
          title,
          alt,
        }:
        ''
          ![${alt}](${src} "${builtins.replaceStrings [ "\"" ] [ "\\\"" ] title}")
        '';
    };
}
</file>

<file path="generate-html-docs.nix">
{
  inputs,
  lib,
  kdl,
  ...
}:
let
  showOption = lib.concatStringsSep ".";
  match = name: cases: cases.${name} or cases._;
  indent =
    entries:
    "${lib.pipe entries [
      lib.toList
      (lib.concatStringsSep "\n")
      (lib.splitString "\n")
      (map (s: "  ${s}"))
      (lib.concatStringsSep "\n")
    ]}";

  delimit-pretty =
    start: content: end:
    lib.concatStringsSep "\n" [
      start
      content
      end
    ];
  delimit-min =
    start: content: end:
    lib.concatStrings [
      start
      content
      end
    ];
  display-value =
    {
      pretty ? true,
      omit-empty-composites ? false,
    }:
    let
      display-value' = display-value { inherit pretty; };
      indent' = if pretty then indent else lib.id;
      delimit' = if pretty then delimit-pretty else delimit-min;
    in
    v:
    match (builtins.typeOf v) {
      string = lib.strings.escapeNixString v;
      int = toString v;
      float = toString v;
      bool = if v then "true" else "false";
      set =
        if v == { } then
          if omit-empty-composites then null else "{}"
        else
          delimit' "{" (indent' (lib.mapAttrsToList (name: val: "${name} = ${display-value' val};") v)) "}";
      null = "null";
      list =
        if v == [ ] then
          if omit-empty-composites then null else "[]"
        else
          delimit' "[" (indent' (map display-value' v)) "]";
      _ = "<${(builtins.typeOf v)}>";
    };

  escape-html =
    let
      html-escapes = {
        "\"" = "&quot;";
        "'" = "&apos;";
        "<" = "&lt;";
        ">" = "&gt;";
        "&" = "&amp;";
      };
    in
    builtins.replaceStrings (builtins.attrNames html-escapes) (builtins.attrValues html-escapes);

  html-skeleton = main-generated-content: ''
    <!DOCTYPE html>
    <html lang="en">

    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="https://sodi.boo/css/pico.blue.min.css" />
        <!-- <link rel="stylesheet" href="style.css" /> -->
        <title>niri-flake settings docs</title>

        <style>${extra-css}</style>
    </head>

    <body>
        <header class="container">
            <nav aria-label="breadcrumb">
                <ul>
                    <li><a href="#">niri-flake</a></li>
                    <li>settings</li>
                </ul>
            </nav>
        </header>


        <main class="container">

    ${main-generated-content}

        </main>
    </body>

    </html>
  '';

  extra-css = ''
    html {
      scroll-behavior: smooth;
    }
    code:not(.block) {
      display: unset;
    }
    a {
      --pico-code-color: var(--pico-color-primary);
    }
    ${base-colors}
    ${builtins.concatStringsSep "\n" admonitions-css}
  '';

  base-colors = ''
    :root {
      --gray-1: #515c67;
      --gray-2: #414853;
      --gray-3: #32363f;
      --gray-soft: #65758529;
      --indigo-1: #a8b1ff;
      --indigo-2: #5c73e7;
      --indigo-3: #3e63dd;
      --indigo-soft: #646cff29;
      --purple-1: #c8abfa;
      --purple-2: #a879e6;
      --purple-3: #8e5cd9;
      --purple-soft: #9f7aea29;
      --green-1: #3dd68c;
      --green-2: #30a46c;
      --green-3: #298459;
      --green-soft: #10b98129;
      --yellow-1: #f9b44e;
      --yellow-2: #da8b17;
      --yellow-3: #a46a0a;
      --yellow-soft: #eab30829;
      --red-1: #f66f81;
      --red-2: #f14158;
      --red-3: #b62a3c;
      --red-soft: #f43f5e29;
    }
  '';

  admonitions-template = {
    note = {
      title = "Note";
      color = "indigo";
    };
    tip = {
      title = "Tip";
      color = "green";
    };
    important = {
      title = "Important";
      color = "purple";
    };
    warning = {
      title = "Warning";
      color = "yellow";
    };
    caution = {
      title = "Caution";
      color = "red";
    };
  };

  admonitions-components = lib.mapAttrs (
    kind:
    {
      title,
      color,
    }:
    body: ''
      <div class="admonition ${kind}">
      <div class="admonition-title">${title}</div>
      ${body}
      </div>
    ''
  ) admonitions-template;

  admonitions-css = lib.mapAttrsToList (
    kind:
    {
      title,
      color,
    }:
    ''
      .admonition.${kind} {
        border: 1px solid transparent;
        background-color: var(--${color}-soft);
        border-radius: 8px;
        padding: 16px 16px 8px;

        .admonition-title {
          color: var(--${color}-3);
          font-weight: 600;
          margin-bottom: .5em;
        }
      }
    ''
  ) admonitions-template;

  break-paragraphs =
    text:
    lib.pipe text [
      (lib.replaceStrings [ "\\\n" ] [ "" ])
      (lib.splitString "\n\n")
      (lib.remove "\n")
      (lib.remove "")
      (map (s: "<p>${s}</p>"))
      lib.concatStrings
    ];

  describe-type =
    type:
    let
      code = c: "<code>${escape-html c}</code>";
    in
    if type.name == "rename" then
      (code type.description) + ", which is a ${describe-type type.nestedTypes.real}"
    else if type.name == "shorthand" then
      describe-type type.nestedTypes.real
    else if type.name == "nullOr" && type.nestedTypes.elemType.name == "rename" then
      code type.description
      + " (where ${code type.nestedTypes.elemType.description} is a ${describe-type type.nestedTypes.elemType.nestedTypes.real})"
    else if type.name == "nullOr" && type.nestedTypes.elemType.name == "shorthand" then
      describe-type (lib.types.nullOr type.nestedTypes.elemType.nestedTypes.real)
    else
      code type.description;

  render-option =
    opt:
    assert opt._type or null == "option";
    lib.optional (opt.visible or true != false) ''
      <details${lib.optionalString (opt.visible or true == true) " open"}>
      <summary>
      <a id="${showOption opt.loc}" href="#${showOption opt.loc}">${escape-html (showOption opt.loc)}</a>

      </summary>

      ${lib.concatStringsSep "\n" [
        (
          let
            described = describe-type opt.type;
          in
          lib.optionalString (described != "<code>submodule</code>") ''
            <p>
            type: ${described}
            </p>
          ''
        )
        (lib.optionalString (opt.defaultText != null) (''
          <p>
          default: <code>${escape-html opt.defaultText}</code>
          </p>
        ''))
        (lib.optionalString (opt.description or null != null) (''
          ${break-paragraphs opt.description}
        ''))
        (lib.optionalString (opt.visible or true != false) (
          render-suboptions (expand-suboptions opt.loc (opt.type.getSubOptions opt.loc))
        ))
      ]}
    '';

  render-options-node =
    loc: options:
    assert !(options ? _type);

    let
      suboptions = expand-suboptions loc options;

    in
    lib.optional (suboptions != [ ]) ''
      <details open>
      <summary>
      <a id="${showOption loc}" href="#${showOption loc}">${escape-html (showOption loc)}</a>
      </summary>

      ${render-suboptions suboptions}
      </details>
    '';

  # (lib.remove "")

  # (
  #   suboptions:
  #   lib.optionalString (suboptions != [ ]) ''
  #     <ul class="options">
  #     ${lib.concatStrings (map (s: "<li>${s}</li>") suboptions)}
  #     </ul>
  #   ''
  # )

  render-suboptions = suboptions: ''
    <ul class="options">
    ${lib.concatStrings (map (s: "<hr><li>${s}</li>") suboptions)}
    </ul>
  '';

  expand-suboptions =
    loc: options:
    assert !(options ? _type);
    let
      to-list = lib.mapAttrsToList (name: opt: { inherit name opt; });

      options' =
        if options ? _module.niri-flake-ordered-record then
          let
            ord-record = options._module.niri-flake-ordered-record;
            ordering = ord-record.ordering.value;
            extra-docs-options = ord-record.extra-docs-options;

            ordering' = builtins.listToAttrs (
              lib.imap0 (i: v: {
                name = v;
                value = i;
              }) ordering
            );
            max-ordering = builtins.length ordering;
          in
          builtins.sort (
            a: b: (ordering'.${a.name} or max-ordering) < (ordering'.${b.name} or max-ordering)
          ) (to-list (builtins.removeAttrs (options // extra-docs-options) [ "_module" ]))
        else
          to-list (builtins.removeAttrs options [ "_module" ]);

    in
    builtins.concatMap (
      { name, opt }:
      if opt ? _type then
        render-option (
          opt
          // {
            defaultText =
              opt.defaultText
                or (if opt ? default then display-value { omit-empty-composites = true; } opt.default else null);

            loc = opt.override-loc or lib.id opt.loc;
          }
        )
      else
        render-options-node (loc ++ [ name ]) opt
    ) options';

  make-docs = lib.flip lib.pipe [
    (ty: ty.getSubOptions [ ])
    (expand-suboptions [ ])
    (render-suboptions)
    html-skeleton
  ];
in
{
  inherit make-docs;
  settings-fmt =
    let
      body = break-paragraphs;

      literal = lit: builtins.replaceStrings [ "\n" ] [ "<br>" ] (escape-html lit);
    in
    rec {
      bare-link =
        href:
        masked-link {
          href = href;
          content = href;
        };
      masked-link =
        {
          href,
          content,
        }:
        "<a href=\"${href}\">${content}</a>";

      code = code: "<code>${literal code}</code>";

      link-to-setting = loc: "#${showOption loc}";

      admonition = builtins.mapAttrs (
        _: wrap: content:
        wrap (body content)
      ) admonitions-components;

      list = items: "<ul>${lib.concatStrings (map (s: "<li>${body s}</li>") items)}</ul>";
      ordered-list = items: "<ol>${lib.concatStrings (map (s: "<li>${body s}</li>") items)}</ol>";

      nix-code-block = code: ''
        <pre><code class="block language-nix">${literal code}</code></pre>
      '';

      em = text: "<em>${text}</em>";
      strong = text: "<strong>${text}</strong>";

      table =
        {
          headers,
          align,
          rows,
        }:
        assert (builtins.length headers == builtins.length align);
        let

          align' = map (
            align:
            if align == null then
              ""
            else
              {
                left = " align=\"left\"";
                center = " align=\"center\"";
                right = " align=\"right\"";
              }
              .${align}
          ) align;

          with-align = lib.imap0 (
            i: content: {
              align = builtins.elemAt align' i;
              inherit content;
            }
          );

          header-row = "<tr>${
            lib.concatStrings (
              map (
                {
                  align,
                  content,
                }:
                "<th${align}>${content}</th>"
              ) (with-align headers)
            )
          }</tr>";

          body-rows = map (
            row:
            assert builtins.length headers == builtins.length row;
            "<tr>${
              lib.concatStrings (
                map (
                  {
                    align,
                    content,
                  }:
                  "<td${align}>${content}</td>"
                ) (with-align row)
              )
            }</tr>"
          ) rows;
        in
        "<table><thead>${header-row}</thead><tbody>${lib.concatStrings body-rows}</tbody></table>";

      kbd = keys: "<kbd>${escape-html keys}</kbd>";
      # kbd = code;

      img =
        {
          src,
          alt,
          title,
        }:
        "<img src=\"${src}\" alt=\"${builtins.replaceStrings [ "\n" ] [ "  " ] alt}\" title=\"${
          builtins.replaceStrings [ "\"" ] [ "\\\"" ] title
        }\">";
    };
}
</file>

<file path="justfile">
# deps: fish, fd, entr, moreutils (sponge)

# i don't wanna deal with xargs
set shell := ["fish", "-c"]

current-system := `nix eval --impure --raw --expr builtins.currentSystem`
nom-path := `command -v nom || true`

default: check

fmt:
    nixfmt $(fd '^[^.]*\\.nix$' .)

hook:
    -ln -s ../../pre-commit .git/hooks/pre-commit
    -ln -s ../../post-commit .git/hooks/post-commit

ref:
    nix eval --raw --file fetch-refs.nix > refs.nix

# that's an ugly just command. but hey, it works. and doesn't require `nom` to be installed.
# but if you do have `nom` installed, the check command will have a nicer output
# for the long-running package builds.
check: fmt
    {{if nom-path != "" { "nom build --show-trace .#checks."+current-system+".cached-packages" } else {""} }}
    nix flake check --quiet --quiet --show-trace

# docs really do exceed the default call depth limit. as a workaround, increase it.

check-docs: check
    NIX_CONFIG="max-call-depth = 20000" nix eval --quiet --quiet --raw .#lib.internal.docs-markdown > /dev/null

doc: check
    NIX_CONFIG="max-call-depth = 20000" nix eval --quiet --quiet --raw .#lib.internal.docs-markdown | sponge docs.md

html-doc: check
    NIX_CONFIG="max-call-depth = 20000" nix eval --quiet --quiet --raw .#lib.internal.docs-html | sponge docs.html.gen
    @[ -s docs.html.gen ]
    cat docs.html.gen | sponge docs.html

watch:
    fd .nix . | entr just doc

watch-html:
    fd .nix . | entr just html-doc

doc-both: fmt
    NIX_CONFIG="max-call-depth = 20000" nix eval --quiet --quiet --raw .#lib.internal.docs-markdown --show-trace | sponge docs.md.gen
    @[ -s docs.md.gen ]
    NIX_CONFIG="max-call-depth = 20000" nix eval --quiet --quiet --raw .#lib.internal.docs-html --show-trace | sponge docs.html.gen
    @[ -s docs.html.gen ]
    mv docs.md.gen docs.md
    mv docs.html.gen docs.html

watch-both:
    fd .nix . | entr -r just doc-both
</file>

<file path="kdl.nix">
{ lib, ... }:
let
  fold-args =
    lib.foldl
      (
        self: arg:
        if lib.isAttrs arg then
          self // { properties = self.properties // arg; }
        else
          self // { arguments = self.arguments ++ [ arg ]; }
      )
      {
        arguments = [ ];
        properties = { };
      };
  node = name: args: children: {
    inherit name;
    inherit (fold-args (lib.toList args)) arguments properties;
    inherit children;
  };

  plain = name: node name [ ];
  leaf = name: args: node name args [ ];
  magic-leaf = node-name: {
    ${node-name} = [ ];
    __functor = self: arg: {
      inherit (self) __functor;
      ${node-name} = self.${node-name} ++ lib.toList arg;
    };
  };
  flag = name: node name [ ] [ ];

  serialize.string = lib.flip lib.pipe [
    (lib.escape [
      "\\"
      "\""
    ])
    # including newlines will cause the serialized output to contain additional indentation
    # so we escape them
    (lib.replaceStrings [ "\n" ] [ "\\n" ])
    (v: "\"${v}\"")
  ];
  serialize.path = serialize.string;
  serialize.int = toString;
  serialize.float = toString;
  serialize.bool = v: if v then "true" else "false";
  serialize.null = lib.const "null";

  serialize.value = v: serialize.${builtins.typeOf v} v;

  # this is not a complete list of valid identifiers
  # but it is good enough for niri
  # if this rejects a valid ident, literally nothing bad happens
  # essentially, this regex boils down to any sequence of letters, numbers or +/-
  # but not something that looks like a number (e.g. 0, -4, +12)
  bare-ident = "[A-Za-z][A-Za-z0-9+-]*|[+-]|[+-][A-Za-z+-][A-Za-z0-9+-]*";
  serialize.ident = v: if lib.strings.match bare-ident v != null then v else serialize.string v;

  serialize.prop =
    {
      name,
      value,
    }:
    "${serialize.ident name}=${serialize.value value}";

  single-indent = "    ";

  should-collapse =
    children:
    let
      length = lib.length children;
    in
    length == 0 || (length == 1 && should-collapse (lib.head children).children);

  serialize.node = serialize.node-with "";
  serialize.node-with =
    indent:
    {
      name,
      arguments,
      properties,
      children,
    }:
    indent
    + lib.concatStringsSep " " (
      lib.flatten [
        (serialize.ident name)
        (map serialize.value arguments)
        (map serialize.prop (lib.attrsToList properties))
        (
          if lib.length children == 0 then
            [ ]
          else if should-collapse children then
            "{ ${serialize.nodes children}; }"
          else
            "{\n${serialize.nodes-with (indent + single-indent) children}\n${indent}}"
        )
      ]
    );

  serialize.nodes = serialize.nodes-with "";
  serialize.nodes-with =
    indent:
    lib.flip lib.pipe [
      (map (serialize.node-with indent))
      (lib.concatStringsSep "\n")
    ];

  kdl-value = lib.types.nullOr (
    lib.types.oneOf [
      lib.types.str
      lib.types.int
      lib.types.float
      lib.types.bool
    ]
  );

  kdl-node = lib.types.submodule {
    options.name = lib.mkOption {
      type = lib.types.str;
    };
    options.arguments = lib.mkOption {
      type = lib.types.listOf kdl-value;
      default = [ ];
    };
    options.properties = lib.mkOption {
      type = lib.types.attrsOf kdl-value;
      default = { };
    };
    options.children = lib.mkOption {
      type = kdl-document;
      default = [ ];
    };
  };

  kdl-leaf = lib.mkOptionType {
    name = "kdl-leaf";
    description = "kdl leaf";
    descriptionClass = "noun";
    check =
      v: lib.isAttrs v && lib.length (builtins.attrNames (builtins.removeAttrs v [ "__functor" ])) == 1;
    merge = lib.mergeUniqueOption {
      message = "";
      merge =
        loc: defs:
        let
          def = builtins.head defs;

          name = builtins.head (builtins.attrNames (builtins.removeAttrs def.value [ "__functor" ]));

          args = kdl-args.merge (loc ++ name) [
            {
              inherit (def) file;
              value = def.value.${name};
            }
          ];
        in
        {
          ${name} = args;
        };
    };
  };

  kdl-args =
    let
      arg = lib.types.either (lib.types.attrsOf kdl-value) kdl-value;
      args = lib.types.either (lib.types.listOf arg) arg;
    in
    lib.mkOptionType {
      name = "kdl-args";
      description = "kdl arguments";
      descriptionClass = "noun";

      inherit (lib.types.uniq args) check merge;
    };

  kdl-nodes = lib.types.listOf kdl-node // {
    name = "kdl-nodes";
    description = "kdl nodes";
    descriptionClass = "noun";
  };

  kdl-document = lib.mkOptionType {
    name = "kdl-document";
    description = "kdl document";
    descriptionClass = "noun";

    check = v: builtins.isList v || builtins.isAttrs v;
    merge =
      loc: defs:
      kdl-nodes.merge loc (
        map (def: {
          inherit (def) file;
          value =
            let
              value' = lib.remove null (lib.flatten def.value);
            in
            lib.warnIf (def.value != value')
              "kdl document defined in `${def.file}` for `${lib.showOption loc}` is not normalized. please ensure that it is a flat list of nodes."
              value';
        }) defs
      );
  };
in
{
  inherit
    node
    plain
    leaf
    magic-leaf
    flag
    serialize
    ;
  types = {
    inherit
      kdl-value
      kdl-node
      kdl-nodes
      kdl-leaf
      kdl-args
      kdl-document
      ;
  };
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 sodiboo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="memo-binds.nix">
# This is a generated file.
# It caches the output of `parse-binds.nix` for the latest niri-unstable.
# That script is slow and also now exceeds the default call depth limit.
# So, we memoize it here. It doesn't change anyway.
[
  "quit"
  "suspend"
  "power-off-monitors"
  "power-on-monitors"
  "toggle-debug-tint"
  "debug-toggle-opaque-regions"
  "debug-toggle-damage"
  "spawn"
  "spawn-sh"
  "do-screen-transition"
  "screenshot"
  "screenshot-window"
  "toggle-keyboard-shortcuts-inhibit"
  "close-window"
  "fullscreen-window"
  "toggle-windowed-fullscreen"
  "focus-window-in-column"
  "focus-window-previous"
  "focus-column-left"
  "focus-column-right"
  "focus-column-first"
  "focus-column-last"
  "focus-column-right-or-first"
  "focus-column-left-or-last"
  "focus-column"
  "focus-window-or-monitor-up"
  "focus-window-or-monitor-down"
  "focus-column-or-monitor-left"
  "focus-column-or-monitor-right"
  "focus-window-down"
  "focus-window-up"
  "focus-window-down-or-column-left"
  "focus-window-down-or-column-right"
  "focus-window-up-or-column-left"
  "focus-window-up-or-column-right"
  "focus-window-or-workspace-down"
  "focus-window-or-workspace-up"
  "focus-window-top"
  "focus-window-bottom"
  "focus-window-down-or-top"
  "focus-window-up-or-bottom"
  "move-column-left"
  "move-column-right"
  "move-column-to-first"
  "move-column-to-last"
  "move-column-left-or-to-monitor-left"
  "move-column-right-or-to-monitor-right"
  "move-column-to-index"
  "move-window-down"
  "move-window-up"
  "move-window-down-or-to-workspace-down"
  "move-window-up-or-to-workspace-up"
  "consume-or-expel-window-left"
  "consume-or-expel-window-right"
  "consume-window-into-column"
  "expel-window-from-column"
  "swap-window-left"
  "swap-window-right"
  "toggle-column-tabbed-display"
  "set-column-display"
  "center-column"
  "center-window"
  "center-visible-columns"
  "focus-workspace-down"
  "focus-workspace-up"
  "focus-workspace"
  "focus-workspace-previous"
  "move-window-to-workspace-down"
  "move-window-to-workspace-up"
  "move-column-to-workspace-down"
  "move-column-to-workspace-up"
  "move-workspace-down"
  "move-workspace-up"
  "move-workspace-to-index"
  "move-workspace-to-monitor"
  "set-workspace-name"
  "unset-workspace-name"
  "focus-monitor-left"
  "focus-monitor-right"
  "focus-monitor-down"
  "focus-monitor-up"
  "focus-monitor-previous"
  "focus-monitor-next"
  "focus-monitor"
  "move-window-to-monitor-left"
  "move-window-to-monitor-right"
  "move-window-to-monitor-down"
  "move-window-to-monitor-up"
  "move-window-to-monitor-previous"
  "move-window-to-monitor-next"
  "move-window-to-monitor"
  "move-column-to-monitor-left"
  "move-column-to-monitor-right"
  "move-column-to-monitor-down"
  "move-column-to-monitor-up"
  "move-column-to-monitor-previous"
  "move-column-to-monitor-next"
  "move-column-to-monitor"
  "set-window-width"
  "set-window-height"
  "reset-window-height"
  "switch-preset-column-width"
  "switch-preset-column-width-back"
  "switch-preset-window-width"
  "switch-preset-window-width-back"
  "switch-preset-window-height"
  "switch-preset-window-height-back"
  "maximize-column"
  "set-column-width"
  "expand-column-to-available-width"
  "switch-layout"
  "show-hotkey-overlay"
  "move-workspace-to-monitor-left"
  "move-workspace-to-monitor-right"
  "move-workspace-to-monitor-down"
  "move-workspace-to-monitor-up"
  "move-workspace-to-monitor-previous"
  "move-workspace-to-monitor-next"
  "toggle-window-floating"
  "move-window-to-floating"
  "move-window-to-tiling"
  "focus-floating"
  "focus-tiling"
  "switch-focus-between-floating-and-tiling"
  "toggle-window-rule-opacity"
  "set-dynamic-cast-window"
  "set-dynamic-cast-monitor"
  "clear-dynamic-cast-target"
  "toggle-overview"
  "open-overview"
  "close-overview"
]
</file>

<file path="parse-binds.nix">
{ lib, ... }:
with lib;
let
  short-circuit = v: steps: pipe v (map (step: x: if x == null then null else step x) steps);

  coalesce = flip pipe [
    (remove null)
    head
  ];

  ifilter =
    f:
    flip pipe [
      (imap0 (i: v: { inherit i v; }))
      (filter ({ i, ... }: f i))
      (map ({ v, ... }: v))
    ];

  filter-prev =
    f: l:
    if l == [ ] then
      [ ]
    else
      [ (head l) ]
      ++ (ifilter (flip pipe [
        (elemAt l)
        f
      ]) (tail l));

  kebaberize = flip pipe [
    (replaceStrings strings.upperChars (map (c: "-${c}") strings.lowerChars))
    (removePrefix "-")
  ];
in
flip short-circuit [
  (path: if builtins.pathExists path then path else null)
  builtins.readFile
  (strings.splitString "\n")
  (lists.foldl
    (
      {
        state,
        actions,
      }:
      line:
      {
        leading = {
          state = if line == "pub enum Action {" then "actions" else "leading";
          inherit actions;
        };
        actions =
          if line == "}" then
            {
              state = "trailing";
              inherit actions;
            }
          else
            {
              state = "actions";
              actions = actions ++ [ line ];
            };
        trailing = {
          state = "trailing";
          inherit actions;
        };
      }
      .${state}
    )
    {
      state = "leading";
      actions = [ ];
    }
  )
  (
    {
      state,
      actions,
    }:
    assert (state == "trailing");
    actions
  )
  (remove "")
  (map (removePrefix "    "))
  (filter-prev (prev: prev != "#[knuffel(skip)]"))
  (remove "#[knuffel(skip)]")
  (map (
    flip short-circuit [
      (strings.match ''([A-Za-z]*)(\((.*)\))?,'')
      (
        m:
        let
          raw-name = elemAt m 0;
          raw = elemAt m 2;
          name = kebaberize raw-name;
          params =
            if raw == null then
              {
                kind = "empty";
              }
            else
              coalesce [
                (short-circuit raw [
                  (strings.match ''#\[knuffel\(argument(, str)?\)] ([A-Za-z0-9]+)'')
                  (m: {
                    kind = "arg";
                    as-str = elemAt m 0 != null;
                    type = elemAt m 1;
                  })
                ])
                (short-circuit raw [
                  (strings.match ''#\[knuffel\(arguments\)] Vec<([A-Za-z0-9]+)>'')
                  (m: {
                    kind = "list";
                    type = elemAt m 0;
                  })
                ])
                (short-circuit raw [
                  (strings.match ''#\[knuffel\(property\(name = "([^"]*)"\)(, default( = true)?)?\)] ([A-Za-z0-9]+)'')
                  (
                    m:
                    let
                      field = elemAt m 0;
                      use-default = elemAt m 1 != null;
                      type = elemAt m 3;
                    in
                    {
                      kind = "prop";
                      none-important = false;
                      inherit field use-default type;
                    }
                  )
                ])
                (short-circuit raw [
                  (strings.match ''#\[knuffel\(property\(name = "([^"]*)"\)\)] Option<([A-Za-z0-9]+)>'')
                  (
                    m:
                    let
                      field = elemAt m 0;
                      type = elemAt m 1;
                    in
                    {
                      kind = "prop";
                      # Option<T> always has a default value.
                      use-default = true;
                      # And it is actively meaningful to omit.
                      none-important = true;
                      inherit field type;
                    }
                  )
                ])
                {
                  kind = "unknown";
                  inherit raw-name raw;
                }
              ];
        in
        {
          inherit name params;
        }
      )
    ]
  ))
  (remove null)
]
</file>

<file path="post-commit">
#!/usr/bin/env bash

if [[ ! -e .git/rebase-merge/done ]]; then

# buffer the output of nix eval through a temporary file
# because that way, we can move it to the new place atomically
# vs clearing the file during eval.

# in other words, this is reimplementing sponge(1)
# why not just use sponge? because this runs in CI (which doesn't have sponge)
tmp="$(mktemp)"

# lol yes the docs really do exceed the default call depth limit.
# luckily, this basically only affects my CI and not any users.
export NIX_CONFIG="max-call-depth = 20000"

nix eval --raw "git+file:.?ref=HEAD&shallow=1#lib.internal.docs-markdown" --show-trace > $tmp

# GitHub Actions doesn't seem to have a HEAD ref (???)
if [ $? -ne 0 ]; then
echo "git didn't like the HEAD i gave it; falling back to working directory" >&2
nix eval --raw .#lib.internal.docs-markdown --show-trace > $tmp
fi

mv $tmp docs.md

nix eval --raw --file fetch-refs.nix --show-trace > refs.nix
nix eval --raw .#lib.internal.memo-binds --show-trace > memo-binds.nix

git diff --quiet docs.md refs.nix
if [ $? -ne 0 ]; then

git add docs.md
git add memo-binds.nix
git add refs.nix
git commit --no-verify --amend --no-edit

# restore the docs from the working directory if you commit with unstaged changes
nix eval --no-warn-dirty --raw .#lib.internal.docs-markdown --show-trace > $tmp

mv $tmp docs.md

fi

fi
</file>

<file path="pre-commit">
#!/usr/bin/env bash

just check-docs
</file>

<file path="README.md">
This flake contains nix packages for [niri](https://github.com/YaLTeR/niri), a scrollable-tiling Wayland compositor. You can try it right now: add the binary cache with `cachix use niri` and then `nix run github:sodiboo/niri-flake`. You can also try the latest commit to the `main` branch with `nix run github:sodiboo/niri-flake#niri-unstable`.

This flake also contains NixOS and home-manager modules to install all necessary components of a working Wayland environment, and to let you manage your configuration declaratively, validating it at build-time. This ensures that your config's schema is always in sync with the installed version of niri.

**The main location for documentation is [`docs.md`](./docs.md)**. The most important outputs are `overlays.niri` and `nixosModules.niri`. You may also use my configuration as a reference at [`github:sodiboo/system`](https://github.com/sodiboo/system/blob/main/personal/niri.mod.nix)

The rest of this README covers miscellaneous topics related to this flake or repo as a whole.

Feel free to contact me at [`@sodiboo:gaysex.cloud`](https://matrix.to/#/@sodiboo:gaysex.cloud) in the [`#niri:matrix.org`](https://matrix.to/#/#niri:matrix.org) channel or through GitHub issues if you have any questions or concerns.

# A note on the automated pull requests in this repository

This repository uses automated pull requests extensively in order to automatically update the lockfile. If you wish to view pull requests made by humans, you can filter for [`is:pr -label:automated`](https://github.com/sodiboo/niri-flake/pulls?q=is%3Apr+-label%3Aautomated).

This is done in order to keep the `niri-unstable` version up-to-date. Niri doesn't have an inherent "unstable" versioning scheme (like e.g. Rust or NixOS does) and that terminology is specific to this flake. It is just the latest commit to main. It's equivalent to `niri-git` on the AUR.

Previously, this was done by telling you to override the niri-src input with the latest version (which puts it in your lockfile), but doing it here has two main benefits:

1. I can run various hooks to automatically update documentation with, at the very least, the niri version, but also other generated items such as listing the available actions (parsed from source code and enumerated in `docs.md`).
2. I can perform checks on the updated lockfile to ensure that nothing breaks with new niri updates.

There are two less obvious benefits:

3. By requiring the build job to succeed, i can ensure that the latest niri versions are always in my binary cache before the pull request is merged. This means you won't need to build it locally.
4. By also automatically updating nixpkgs, i can run checks to ensure the modules keep working with the latest nixpkgs.

Currently, there is no `home-manager` input to this flake since i felt it was unnecessary for *just* checks, and therefore configurations involving home-manager are *not* automatically tested at this time.

# Binary Cache

I have a binary cache for this flake's outputs. `niri.cachix.org` hosts builds of `niri-stable` and `niri-unstable` for `nixos-unstable` and `nixos-25.05`. It only contains builds for `x86_64-linux` for the time being, mainly because GitHub Actions doesn't support other platforms. (and i do not wish to use qemu for this)

> [!note]
> This binary cache is managed by me, sodiboo. By using it, you are trusting me to not serve you malicious software. Using a binary cache is entirely optional.
>
> If you do not wish to use my binary cache, but still want the convenience of one, you could set `programs.niri.package = pkgs.niri;`, which is provided by nixpkgs. This package will receive updates slower.

If you use NixOS, add the `niri.nixosModules.niri` module and don't enable niri yet. Rebuild your system once to enable the binary cache, *then* enable niri. You can set `niri-flake.cache.enable = false;` to prevent this from happening.

If you're not using the NixOS module, you can add the cache to your system by running `cachix use niri`. This works on any system with nix installed, not just NixOS.

# Using `niri-unstable`

Both `niri.nixosModules.niri` and `niri.homeModules.niri` provide the option to use a custom version of niri. This is done by setting `programs.niri.package` to the desired derivation. If you want to use the unstable version of niri, you can set it like so:

```nix
{pkgs, ...}: {
  nixpkgs.overlays = [ inputs.niri.overlays.niri ];
  programs.niri.package = pkgs.niri-unstable;
}
```

You can also set the package to the one from nixpkgs (`pkgs.niri`), which will likely receive updates slower than the `niri-stable` provided here.

`niri.homeModules.config` also provides the option to set the package. This won't install niri by itself, but it does set the package version used for build-time validation.

# Configuration of niri

`programs.niri.settings` is the preferred way to configure niri. This is provided by `niri.homeModules.config`, which is automatically imported when using home-manager as a NixOS module. All options are documented in [`docs.md`](./docs.md#programsnirisettings).

```nix
{
  programs.niri.settings = {
    outputs."eDP-1".scale = 2.0;
  };
}
```

If for whatever reason you want or need to override this, you can set `programs.niri.config`.
You should give this option structured output from `niri.lib.kdl`.

```nix
{
  programs.niri.config = with inputs.niri.lib.kdl; [
    (node "output" "eDP-1" [
      (leaf "scale" 2.0)
    ])
  ];
}
```

But you can also pass it a string:

```nix
{
  programs.niri.config = ''
    output "eDP-1" {
      scale 2.0
    }
  '';
}
```

or set `programs.niri.config = null;` to prevent this module from generating a config file. By default, it will generate a config file based on `programs.niri.settings` if it is not `null`.

For debugging (primarily development of this flake i guess), there is also `programs.niri.finalConfig` which is always a string (or null) and represents the final config file that will be end up in your config directory.

> [!note]
> `programs.niri.settings` is not guaranteed to be compatible with niri versions other than the two provided by this flake. \
> In particular, this means that i do not guarantee compatibility with the one from nixpkgs at all times (i.e. when nixpkgs is lagging behind due to build failures or other reasons). \
> In practice, you will not have an issue with this unless you are running old versions of niri that are 2 or more releases behind. I will try my best not to break compatibility with nixpkgs.
>
> This does not apply to `programs.niri.config` as it is inherently version-agnostic and still provides build-time validation.

# Stylix

A module is provided to integrate with Stylix. To use this, the main prerequisite is that you don't ever set `programs.niri.config`; this will override everything from `programs.niri.settings`, which is where the stylix module places config.

If you've installed home-manager and stylix as a NixOS module, then this will be automatically imported. Else, you'll have to import `niri.homeModules.stylix` yourself.

The stylix module provides the option to disable it: `stylix.targets.niri.enable = false;`. Note that it is already disabled by default if you have `stylix.autoEnable` set to false.

When enabled, the stylix module will set the active/inactive border colors, and set `layout.border` to be on by default. It also sets the xcursor theme and size.

# Additional notes

When installing niri using the modules provided by this flake:

- The niri package will be installed, including its systemd units and the `niri-session` binary.
- `xdg-desktop-portal-gnome` will be installed, as it is necessary for screencasting.
- The GNOME keyring will be enabled. You probably want a keyring installed.

Specifically the NixOS module provides the following additional functionality:

- It will enable polkit, and run the KDE polkit agent.
- If you prefer a different polkit authentication agent, you can set `systemd.user.services.niri-flake-polkit.enable = false;`
- It enables various other features that Wayland compositors may need, such as `dconf`, `opengl` and default fonts. It also adds a pam entry for `swaylock`, which is necessary if you wish to use `swaylock`.

Some additional software you may want to install to get a full desktop experience:

- A notification daemon such as `mako`
- A bar such as `waybar`
- A launcher such as `fuzzel`

These will usually be installed through home-manager. No particular configuration is necessary for them to work with niri specifically, as they generally start on `graphical-session.target` which includes niri.

If using waybar, you'll want to set `programs.waybar.settings.mainBar.layer = "top";`, to ensure it is visible over applications running in niri. You'll also wanna set `programs.waybar.systemd.enable = true;` which i've found seems to exceed the default restart limit of 5, so you may want to run `systemctl --user reset-failed waybar.service` in `spawn-at-startup` to get it to start.

For electron applications such as vscode, you will want to set `programs.niri.settings.environment."NIXOS_OZONE_WL" = "1"`. Several packages in nixpkgs look for this variable, and pass some ozone flags in that case. Note that you must use `niri-session` to start niri for this to have any effect, because running just `niri` will not set the neccecary environment variables.

Visual Studio Code does not properly detect the correct keyring to use on my system. It works fine if you launch it with `code --password-store="gnome-libsecret"`. You persist this flag in `Preferences > Configure Runtime Arguments` (`argv.json`), by setting `"password-store": "gnome-libsecret"`.
</file>

<file path="refs.nix">
# This file is generated automatically by fetch-refs.nix
# Do not edit it manually, your changes will be lost.
#
# Both niri and xwayland-satellite are listed.
# This is because commit hashes are globally unique.
{
  # niri
  "dd967554d10ea289ef480b142953f9a3d44fe4cf" = "v0.1.0";
  "69e7afc538eecdbb0d34a24147f12d671e48ab51" = "v0.1.0-alpha.1";
  "57f267454fa0c746707c430baa1fbd12124f636c" = "v0.1.0-alpha.2";
  "ffe25f5cc4755dfc8e0dc41cd0845cd7d185f3cc" = "v0.1.0-alpha.3";
  "6945ccde189b05eb9d9388a4ca5603a39dff9a19" = "v0.1.0-beta.1";
  "72c8f569aca37ec45420b086a1aa488f5c4a2bd7" = "v0.1.1";
  "9d8f640503819ff1905c9040d3c7910a50400bbd" = "v0.1.10";
  "75c79116a7e40cbc0e110ce0cdd500e896458679" = "v0.1.10.1";
  "62892d636112230dc16778b91331fbe97576b005" = "v0.1.2";
  "acd33653b3d908b1c97e2247048af50613e4a77d" = "v0.1.3";
  "7ff2de19b9304b3afdadb44aeeee4e85dfcb5218" = "v0.1.4";
  "6a80078259ca3e3854b0748a15e98c7293d0822a" = "v0.1.5";
  "d96a66ddff1a6b88dbe3e23b049f7075533b216f" = "v0.1.6";
  "e7c201abba6fedaa57001639810af3b6bd9b852e" = "v0.1.7";
  "9063a5dbdc0d4470dc1e13ce5749838e32af6a44" = "v0.1.8";
  "6a48728ffb1e638839b07f9ab2f06b2adb41dc61" = "v0.1.9";
  "e05bc269e678ecf828b96ae79c991c13b00b38a5" = "v25.01";
  "b94a5db8790339cf9134873d8b490be69e02ac71" = "v25.02";
  "ae89cb6017668f3a81ccd92461cbbc70ab8377d0" = "v25.05";
  "8ba57fcf25d2fc9565131684a839d58703f1dae7" = "v25.05.1";
  "01be0e65f4eb91a9cd624ac0b76aaeab765c7294" = "v25.08";
  # xwayland-satellite
  "e70cb817516834450cb424d31dcbf70ad13b9718" = "v0.1";
  "c95655299e3ffa8790fd3d71b996923a6042de59" = "v0.2";
  "601223d3ae277a876680ea06269555fae1b09131" = "v0.3";
  "b6d281967cb0b7bf1dfdb8d0f597b517dc4aa5c5" = "v0.4";
  "a713cf46cb7db84a0d1b57c3a397c610cad3cf98" = "v0.5";
  "44590a416d4a3e8220e19e29e0b6efe64a80315d" = "v0.5.1";
  "3ba30b149f9eb2bbf42cf4758d2158ca8cceef73" = "v0.6";
  "388d291e82ffbc73be18169d39470f340707edaa" = "v0.7";
}
</file>

<file path="settings.nix">
{
  inputs,
  kdl,
  lib,
  docs,
  binds,
  settings,
  ...
}:
{
  type-with =
    fmt:
    let
      inherit (lib)
        flip
        pipe
        showOption
        mkOption
        mkOptionType
        types
        ;
      inherit (lib.types)
        nullOr
        attrsOf
        listOf
        submodule
        enum
        ;

      binds-stable = binds "${inputs.niri-stable}/niri-config/src/binds.rs";
      binds-unstable = binds "${inputs.niri-unstable}/niri-config/src/binds.rs";

      record = record' null;

      record' =
        description: options:
        types.submoduleWith {
          inherit description;
          shorthandOnlyDefinesConfig = true;
          modules = [
            { inherit options; }
          ];
        };

      required = type: mkOption { inherit type; };
      nullable = type: optional (nullOr type) null;
      optional = type: default: mkOption { inherit type default; };
      readonly = type: value: optional type value // { readOnly = true; };
      docs-only =
        type:
        required (type // { check = _: true; })
        // {
          internal = true;
          visible = false;
          readOnly = true;
          apply = _: null;
          niri-flake-document-internal = true;
        };

      attrs = type: optional (attrsOf type) { };
      list = type: optional (listOf type) [ ];

      attrs-record = attrs-record' null;

      attrs-record' =
        description: opts:
        attrs (
          if builtins.isFunction opts then
            types.submoduleWith {
              inherit description;
              shorthandOnlyDefinesConfig = true;
              modules = [
                (
                  { name, ... }:
                  {
                    options = opts name;
                  }
                )
              ];
            }
          else
            record' description opts
        );

      float-or-int = types.either types.float types.int;

      obsolete-warning = from: to: defs: ''
        ${from} is obsolete.
        Use ${to} instead.
        ${builtins.concatStringsSep "\n" (map (def: "- defined in ${def.file}") defs)}
      '';

      rename-warning = from: to: obsolete-warning (showOption from) (showOption to);

      libinput-anchor-for-header = lib.flip lib.pipe [
        (lib.replaceStrings (lib.upperChars ++ [ " " ]) (lib.lowerChars ++ [ "-" ]))
        (lib.splitString "")
        (lib.filter (str: lib.strings.match "[a-z0-9-]" str != null))
        lib.concatStrings
      ];
      libinput-link-href =
        page: header:
        "https://wayland.freedesktop.org/libinput/doc/latest/${page}.html#${libinput-anchor-for-header header}";
      libinput-link = page: header: fmt.bare-link (libinput-link-href page header);

      libinput-doc =
        page: header:
        fmt.masked-link {
          href = libinput-link-href page header;
          content = header;
        };

      link-niri-release =
        version:
        fmt.masked-link {
          href = "https://github.com/YaLTeR/niri/releases/tag/${version}";
          content = fmt.code version;
        };

      link' =
        loc:
        fmt.masked-link {
          href = fmt.link-to-setting loc;
          content = fmt.code (lib.removePrefix "programs.niri.settings." (lib.showOption loc));
        };

      subopts =
        opt:
        assert opt._type == "option";
        opt.type.getSubOptions opt.loc;
      link-opt =
        opt:
        assert opt._type == "option";
        link' opt.loc;

      unstable-note = fmt.admonition.important ''
        This option is not yet available in stable niri.

        If you wish to modify this option, you should make sure you're using the latest unstable niri.

        Otherwise, your system might fail to build.
      '';

      basic-pointer = default-natural-scroll: {
        natural-scroll = optional types.bool default-natural-scroll // {
          description = ''
            Whether scrolling should move the content in the scrolled direction (as opposed to moving the viewport)

            Further reading:
            ${fmt.list [
              (libinput-link "configuration" "Scrolling")
              (libinput-link "scrolling" "Natural scrolling vs. traditional scrolling")
            ]}
          '';
        };
        middle-emulation = optional types.bool false // {
          description = ''
            Whether a middle mouse button press should be sent when you press the left and right mouse buttons

            Further reading:
            ${fmt.list [
              (libinput-link "configuration" "Middle Button Emulation")
              (libinput-link "middle-button-emulation" "Middle button emulation")
            ]}
          '';
        };
        accel-speed = nullable float-or-int // {
          description = ''
            Further reading:
            ${fmt.list [
              (libinput-link "configuration" "Pointer acceleration")
            ]}
          '';
        };
        accel-profile =
          nullable (enum [
            "adaptive"
            "flat"
          ])
          // {
            description = ''
              Further reading:
              ${fmt.list [
                (libinput-link "pointer-acceleration" "Pointer acceleration profiles")
              ]}
            '';
          };
        scroll-button = nullable types.int // {
          description =
            let
              input-event-codes-h = fmt.masked-link {
                href = "https://github.com/torvalds/linux/blob/e42b1a9a2557aa94fee47f078633677198386a52/include/uapi/linux/input-event-codes.h#L355-L363";
                content = fmt.code "input-event-codes.h";
              };
            in
            ''
              When ${fmt.code ''scroll-method = "on-button-down"''}, this is the button that will be used to enable scrolling. This button must be on the same physical device as the pointer, according to libinput docs. The type is a button code, as defined in ${input-event-codes-h}. Most commonly, this will be set to ${fmt.code "BTN_LEFT"}, ${fmt.code "BTN_MIDDLE"}, or ${fmt.code "BTN_RIGHT"}, or at least some mouse button, but any button from that file is a valid value for this option (though, libinput may not necessarily do anything useful with most of them)

              Further reading:
              ${fmt.list [
                (libinput-link "scrolling" "On-Button scrolling")
              ]}
            '';
        };
        scroll-button-lock = optional types.bool false // {
          description = ''
            When this is false, ${fmt.code "scroll-button"} needs to be held down for pointer motion to be converted to scrolling. When this is true, ${fmt.code "scroll-button"} can be pressed and released to "lock" the device into this state, until it is pressed and released a second time.

            Further reading:
            ${fmt.list [
              (libinput-link "scrolling" "On-Button scrolling")
            ]}
          '';
        };
        scroll-method =
          nullable (
            types.enum [
              "no-scroll"
              "two-finger"
              "edge"
              "on-button-down"
            ]
          )
          // {
            description = ''
              When to convert motion events to scrolling events.
              The default and supported values vary based on the device type.

              Further reading:
              ${fmt.list [
                (libinput-link "scrolling" "Scrolling")
              ]}
            '';
          };
      };

      pointer-tablet-common = {
        enable = optional types.bool true;
        left-handed = optional types.bool false // {
          description = ''
            Whether to accomodate left-handed usage for this device.
            This varies based on the exact device, but will for example swap left/right mouse buttons.

            Further reading:
            ${fmt.list [
              (libinput-link "configuration" "Left-handed Mode")
            ]}
          '';
        };
      };

      preset-size =
        dimension: object:
        types.attrTag {
          fixed = lib.mkOption {
            type = types.int;
            description = ''
              The ${dimension} of the ${object} in logical pixels
            '';
          };
          proportion = lib.mkOption {
            type = types.float;
            description = ''
              The ${dimension} of the ${object} as a proportion of the screen's ${dimension}
            '';
          };
        };

      preset-width = preset-size "width" "column";
      preset-height = preset-size "height" "window";

      emptyOr =
        elemType:
        mkOptionType {
          name = "emptyOr";
          description =
            if
              builtins.elem elemType.descriptionClass [
                "noun"
                "conjunction"
              ]
            then
              "{} or ${elemType.description}"
            else
              "{} or (${elemType.description})";
          descriptionClass = "conjunction";
          check = v: v == { } || elemType.check v;
          nestedTypes.elemType = elemType;
          merge =
            loc: defs: if builtins.all (def: def.value == { }) defs then { } else elemType.merge loc defs;

          inherit (elemType) getSubOptions;
        };

      default-width = emptyOr preset-width;
      default-height = emptyOr preset-height;

      shorthand-for =
        type-name: real:
        mkOptionType {
          name = "shorthand";
          description = "<${type-name}>";
          descriptionClass = "noun";
          inherit (real) check merge getSubOptions;
          nestedTypes = { inherit real; };
        };

      rename =
        name: real:
        mkOptionType {
          name = "rename";
          description = "${name}";
          descriptionClass = "noun";
          inherit (real) check merge getSubOptions;
          nestedTypes = { inherit real; };
        };

      # niri seems to have deprecated this way of defining colors; so we won't support it
      # color-array = mkOptionType {
      #   name = "color";
      #   description = "[red green blue alpha]";
      #   descriptionClass = "noun";
      #   check = v: isList v && length v == 4 && all isInt v;
      # };

      decoration =
        self:

        let
          css-color = fmt.masked-link {
            href = "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value";
            content = fmt.code "<color>";
          };

          css-linear-gradient = fmt.masked-link {
            href = "https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient";
            content = fmt.code "linear-gradient()";
          };

          css-color-interpolation-method = fmt.masked-link {
            href = "https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method";
            content = fmt.code "<color-interpolation-method>";
          };

          csscolorparser-crate = fmt.masked-link {
            href = "https://crates.io/crates/csscolorparser";
            content = fmt.code "csscolorparser";
          };
        in
        types.attrTag {
          color = lib.mkOption {
            type = types.str;
            description = ''
              A solid color to use for the decoration.

              This is a CSS ${css-color} value, like ${fmt.code ''"rgb(255 0 0)"''}, ${fmt.code ''"#C0FFEE"''}, or ${fmt.code ''"sandybrown"''}.

              The specific crate that niri uses to parse this also supports some nonstandard color functions, like ${fmt.code "hwba()"}, ${fmt.code "hsv()"}, ${fmt.code "hsva()"}. See ${csscolorparser-crate} for details.
            '';
          };
          gradient = lib.mkOption {
            description = ''
              A linear gradient to use for the decoration.

              This is meant to approximate the CSS ${css-linear-gradient} function, but niri does not fully support all the same parameters. Only an angle in degrees is supported.
            '';
            type = record' "gradient" {
              from = required types.str // {
                description = ''
                  The starting ${css-color} of the gradient.

                  For more details, see ${link-opt (subopts self).color}.
                '';
              };
              to = required types.str // {
                description = ''
                  The ending ${css-color} of the gradient.

                  For more details, see ${link-opt (subopts self).color}.
                '';
              };
              angle = optional types.int 180 // {
                description = ''
                  The angle of the gradient, in degrees, measured clockwise from a gradient that starts at the bottom and ends at the top.

                  This is the same as the angle parameter in the CSS ${css-linear-gradient} function, except you can only express it in degrees.
                '';
              };
              in' =
                nullable (enum [
                  "srgb"
                  "srgb-linear"
                  "oklab"
                  "oklch shorter hue"
                  "oklch longer hue"
                  "oklch increasing hue"
                  "oklch decreasing hue"
                ])
                // {
                  description = ''
                    The colorspace to interpolate the gradient in. This option is named ${fmt.code "in'"} because ${fmt.code "in"} is a reserved keyword in Nix.

                    This is a subset of the ${css-color-interpolation-method} values in CSS.
                  '';
                };
              relative-to =
                optional (enum [
                  "window"
                  "workspace-view"
                ]) "window"
                // {
                  description = ''
                    The rectangle that this gradient is contained within.

                    If a gradient is ${fmt.code "relative-to"} the ${fmt.code ''"window"''}, then the gradient will start and stop at the window bounds. If you have many windows, then the gradients will have many starts and stops.

                    ${fmt.img {
                      src = "/assets/relative-to-window.png";
                      alt = ''
                        four windows arranged in two columns; a big window to the left of three stacked windows.
                        a gradient is drawn from the bottom left corner of each window, which is yellow, transitioning to red at the top right corner of each window.
                        the three vertical windows look identical, with a yellow and red corner, and the other two corners are slightly different shades of orange.
                        the big window has a yellow and red corner, with the top left corner being a very red orange orange, and the bottom right corner being a very yellow orange.
                        the top edge of the top stacked window has a noticeable transition from a yellowish orange to completely red.
                      '';
                      title = ''behaviour of relative-to="window"'';
                    }}

                    If the gradient is instead ${fmt.code "relative-to"} the ${fmt.code ''"workspace-view"''}, then the gradient will start and stop at the bounds of your view. Windows decorations will take on the color values from just the part of the screen that they occupy

                    ${fmt.img {
                      src = "/assets/relative-to-workspace-view.png";
                      alt = ''
                        four windows arranged in two columns; a big window to the left of three stacked windows.
                        a gradient is drawn from the bottom left corner of the workspace view, which is yellow, transitioning to red at the top right corner of the workspace view.
                        it looks like the gradient starts in the bottom left of the big window, and ends in the top right of the upper stacked window.
                        the bottom left corner of the top stacked window is a red orange color, and the bottom left corner of the middle stacked window is a more neutral orange color.
                        the bottom edge of the big window is almost entirely yellow, and the top edge of the top stacked window is almost entirely red.
                      '';
                      title = ''behaviour of relative-to="workspace-view"'';
                    }}

                    these beautiful images are sourced from the release notes for ${link-niri-release "v0.1.3"}
                  '';
                };
            };
          };
        };

      make-decoration-options =
        options:
        builtins.mapAttrs (
          name:
          { description }:
          nullable (shorthand-for "decoration" (decoration (options.${name})))
          // {
            visible = "shallow";
            inherit description;
          }
        );

      borderish =
        {
          enable-by-default,
          name,
          window,
          description,
        }:
        section' (
          { options, ... }:
          {
            imports = make-ordered-options [
              {
                enable = optional types.bool enable-by-default // {
                  description = ''
                    Whether to enable the ${name}.
                  '';
                };
                width = optional float-or-int 4 // {
                  description = ''
                    The width of the ${name} drawn around each ${window}.
                  '';
                };
              }

              (make-decoration-options options {
                urgent.description = ''
                  The color of the ${name} for windows that are requesting attention.
                '';
                active.description = ''
                  The color of the ${name} for the window that has keyboard focus.
                '';
                inactive.description = ''
                  The color of the ${name} for windows that do not have keyboard focus.
                '';
              })
            ];
          }
        )
        // {
          inherit description;
        };

      border-rule =
        {
          name,
          description,
          window,
        }:
        section' (
          { options, ... }:
          {
            imports = make-ordered-options [
              {
                enable = nullable types.bool // {
                  description = ''
                    Whether to enable the ${name}.
                  '';
                };
                width = nullable float-or-int // {
                  description = ''
                    The width of the ${name} drawn around each ${window}.
                  '';
                };
              }

              (make-decoration-options options {
                urgent.description = ''
                  The color of the ${name} for windows that are requesting attention.
                '';
                active.description = ''
                  The color of the ${name} for the window that has keyboard focus.
                '';
                inactive.description = ''
                  The color of the ${name} for windows that do not have keyboard focus.
                '';
              })
            ];
          }
        )
        // {
          inherit description;
        };

      shadow-rule = section {
        enable = nullable types.bool;
        offset =
          nullable (record {
            x = required float-or-int;
            y = required float-or-int;
          })
          // {
            description = shadow-descriptions.offset;
          };

        softness = nullable float-or-int // {
          description = shadow-descriptions.softness;
        };

        spread = nullable float-or-int // {
          description = shadow-descriptions.spread;
        };

        draw-behind-window = nullable types.bool;

        color = nullable types.str;

        inactive-color = nullable types.str;
      };

      geometry-corner-radius-rule = nullable (record {
        top-left = required types.float;
        top-right = required types.float;
        bottom-right = required types.float;
        bottom-left = required types.float;
      });

      shadow-descriptions =
        let
          css-box-shadow =
            prop:
            fmt.masked-link {
              href = "https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow#syntax";
              content = "CSS box-shadow ${prop}";
            };
        in
        {
          offset = ''
            The offset of the shadow from the window, measured in logical pixels.

            This behaves like a ${css-box-shadow "offset"}
          '';

          softness = ''
            The softness/size of the shadow, measured in logical pixels.

            This behaves like a ${css-box-shadow "blur radius"}
          '';

          spread = ''
            The spread of the shadow, measured in logical pixels.

            This behaves like a ${css-box-shadow "spread radius"}
          '';
        };

      regex = rename "regular expression" types.str;

      rule-descriptions =
        {
          surface,
          surfaces,
          surface-rule,
          Surface-rules,
          example-fields,

          self,
          spawn-at-startup,
        }:

        let
          matches = link-opt (subopts self).matches;
          excludes = link-opt (subopts self).excludes;
        in
        {
          top-option = ''
            ${Surface-rules}.

            A ${surface-rule} will match based on ${matches} and ${excludes}. Both of these are lists of "match rules".

            A given match rule can match based on one of several fields. For a given match rule to "match" a ${surface}, it must match on all fields.

            ${fmt.list (
              example-fields
              ++ [
                "The ${fmt.code "at-startup"} field, when non-null, will match a ${surface} based on whether it was opened within the first 60 seconds of niri starting up."
                "If a field is null, it will always match."
              ]
            )}

            For a given ${surface-rule} to match a ${surface}, the above logic is employed to determine whether any given match rule matches, and the interactions between the match rules decide whether the ${surface-rule} as a whole will match. For a given ${surface-rule}:

            ${fmt.list [
              ''
                A given ${surface} is "considered" if any of the match rules in ${matches} successfully match this ${surface}. If all of the match rules do not match this ${surface}, then that ${surface} will never match this ${surface-rule}.
              ''
              ''
                If ${matches} contains no match rules, it will match any ${surface} and "consider" it for this ${surface-rule}.
              ''
              ''
                If a given ${surface} is "considered" for this ${surface-rule} according to the above rules, the selection can be further refined with ${excludes}. If any of the match rules in ${fmt.code "excludes"} match this ${surface}, it will be rejected and this ${surface-rule} will not match the given ${surface}.
              ''
            ]}

            That is, a given ${surface-rule} will apply to a given ${surface} if any of the entries in ${matches} match that ${surface} (or there are none), AND none of the entries in ${excludes} match that ${surface}.

            All fields of a ${surface-rule} can be set to null, which represents that the field shall have no effect on the ${surface} (and in general, the client is allowed to choose the initial value).

            To compute the final set of ${surface-rule}s that apply to a given ${surface}, each ${surface-rule} in this list is consdered in order.

            At first, every field is set to null.

            Then, for each applicable ${surface-rule}:

            ${fmt.list [
              ''
                If a given field is null on this ${surface-rule}, it has no effect. It does nothing and "inherits" the value from the previous rule.
              ''
              ''
                If the given field is not null, it will overwrite the value from any previous rule.
              ''
            ]}

            The "final value" of a field is simply its value at the end of this process. That is, the final value of a field is the one from the ${fmt.em "last"} ${surface-rule} that matches the given ${surface-rule} (not considering null entries, unless there are no non-null entries)

            If the final value of a given field is null, then it usually means that the client gets to decide. For more information, see the documentation for each field.
          '';

          match = ''
            A list of rules to match ${surfaces}.

            If any of these rules match a ${surface} (or there are none), that ${surface-rule} will be considered for this ${surface}. It can still be rejected by ${excludes}

            If all of the rules do not match a ${surface}, then this ${surface-rule} will not apply to that ${surface}.
          '';

          exclude = ''
            A list of rules to exclude ${surfaces}.

            If any of these rules match a ${surface}, then this ${surface-rule} will not apply to that ${surface}, even if it matches one of the rules in ${matches}

            If none of these rules match a ${surface}, then this ${surface-rule} will not be rejected. It will apply to that ${surface} if and only if it matches one of the rules in ${matches}
          '';

          match-at-startup = ''
            When true, this rule will match ${surfaces} opened within the first 60 seconds of niri starting up. When false, this rule will match ${surfaces} opened ${fmt.em "more than"} 60 seconds after niri started up. This is useful for applying different rules to ${surfaces} opened from ${link-opt spawn-at-startup} versus those opened later.
          '';

          opacity = ''
            The opacity of the ${surface}, ranging from 0 to 1.

            If the final value of this field is null, niri will fall back to a value of 1.

            Note that this is applied in addition to the opacity set by the client. Setting this to a semitransparent value on a ${surface} that is already semitransparent will make it even more transparent.
          '';

          block-out-from = ''
            Whether to block out this ${surface} from screen captures. When the final value of this field is null, it is not blocked out from screen captures.

            This is useful to protect sensitive information, like the contents of password managers or private chats. It is very important to understand the implications of this option, as described below, ${fmt.strong "especially if you are a streamer or content creator"}.

            Some of this may be obvious, but in general, these invariants ${fmt.em "should"} hold true:
            ${fmt.list [
              ''
                a ${surface} is never meant to be blocked out from the actual physical screen (otherwise you wouldn't be able to see it at all)
              ''
              ''
                a ${fmt.code "block-out-from"} ${surface} ${fmt.em "is"} meant to be always blocked out from screencasts (as they are often used for livestreaming etc)
              ''
              ''
                a ${fmt.code "block-out-from"} ${surface} is ${fmt.em "not"} supposed to be blocked from screenshots (because usually these are not broadcasted live, and you generally know what you're taking a screenshot of)
              ''
            ]}

            There are three methods of screencapture in niri:

            ${fmt.ordered-list [
              ''
                The ${fmt.code "org.freedesktop.portal.ScreenCast"} interface, which is used by tools like OBS primarily to capture video. When ${fmt.code ''block-out-from = "screencast";''} or ${fmt.code ''block-out-from = "screen-capture";''}, this ${surface} is blocked out from the screencast portal, and will not be visible to screencasting software making use of the screencast portal.
              ''
              ''
                The ${fmt.code "wlr-screencopy"} protocol, which is used by tools like ${fmt.code "grim"} primarily to capture screenshots. When ${fmt.code ''block-out-from = "screencast";''}, this protocol is not affected and tools like ${fmt.code "grim"} can still capture the ${surface} just fine. This is because you may still want to take a screenshot of such ${surfaces}. However, some screenshot tools display a fullscreen overlay with a frozen image of the screen, and then capture that. This overlay is ${fmt.em "not"} blocked out in the same way, and may leak the ${surface} contents to an active screencast. When ${fmt.code ''block-out-from = "screen-capture";''}, this ${surface} is blocked out from ${fmt.code "wlr-screencopy"} and thus will never leak in such a case, but of course it will always be blocked out from screenshots and (sometimes) the physical screen.
              ''
              ''
                The built in ${fmt.code "screenshot"} action, implemented in niri itself. This tool works similarly to those based on ${fmt.code "wlr-screencopy"}, but being a part of the compositor gets superpowers regarding secrecy of ${surface} contents. Its frozen overlay will never leak ${surface} contents to an active screencast, because information of blocked ${surfaces} and can be distinguished for the physical output and screencasts. ${fmt.code "block-out-from"} does not affect the built in screenshot tool at all, and you can always take a screenshot of any ${surface}.
              ''
            ]}

            ${fmt.table {
              headers = [
                (fmt.code "block-out-from")
                "can ${fmt.code "ScreenCast"}?"
                "can ${fmt.code "screencopy"}?"
                "can ${fmt.code "screenshot"}?"
              ];
              align = [
                null
                "center"
                "center"
                "center"
              ];
              rows = [
                [
                  (fmt.code "null")
                  "yes"
                  "yes"
                  "yes"
                ]
                [
                  (fmt.code ''"screencast"'')
                  "no"
                  "yes"
                  "yes"
                ]
                [
                  (fmt.code ''"screen-capture"'')
                  "no"
                  "no"
                  "yes"
                ]
              ];
            }}

            ${fmt.admonition.caution ''
              ${fmt.strong "Streamers: Do not accidentally leak ${surface} contents via screenshots."}

              For ${surfaces} where ${fmt.code ''block-out-from = "screencast";''}, contents of a ${surface} may still be visible in a screencast, if the ${surface} is indirectly displayed by a tool using ${fmt.code "wlr-screencopy"}.

              If you are a streamer, either:
              ${fmt.list [
                "make sure not to use ${fmt.code "wlr-screencopy"} tools that display a preview during your stream, or"
                (fmt.strong "set ${fmt.code ''block-out-from = "screen-capture";''} to ensure that the ${surface} is never visible in a screencast.")
              ]}
            ''}

            ${fmt.admonition.caution ''
              ${fmt.strong "Do not let malicious ${fmt.code "wlr-screencopy"} clients capture your top secret ${surfaces}."}

              (and don't let malicious software run on your system in the first place, you silly goose)

              For ${surfaces} where ${fmt.code ''block-out-from = "screencast";''}, contents of a ${surface} will still be visible to any application using ${fmt.code "wlr-screencopy"}, even if you did not consent to this application capturing your screen.

              Note that sandboxed clients restricted via security context (i.e. Flatpaks) do not have access to ${fmt.code "wlr-screencopy"} at all, and are not a concern.

              ${fmt.strong "If a ${surface}'s contents are so secret that they must never be captured by any (non-sandboxed) application, set ${fmt.code ''block-out-from = "screen-capture";''}."}
            ''}

            Essentially, use ${fmt.code ''block-out-from = "screen-capture";''} if you want to be sure that the ${surface} is never visible to any external tool no matter what; or use ${fmt.code ''block-out-from = "screencast";''} if you want to be able to capture screenshots of the ${surface} without its contents normally being visible in a screencast. (at the risk of some tools still leaking the ${surface} contents, see above)
          '';
        };

      alphabetize =
        sections:
        lib.mergeAttrsList (
          lib.imap0 (i: section: {
            ${builtins.elemAt lib.strings.lowerChars i} = section;
          }) sections
        );

      ordered-record = ordered-record' null;

      ordered-record' =
        description: sections:
        types.submoduleWith {
          inherit description;
          shorthandOnlyDefinesConfig = true;
          modules = make-ordered-options sections;
        };

      make-ordered-options =
        sections:
        let
          grouped = lib.groupBy (s: if s ? __module then "module" else "options") sections;

          options' = grouped.options or [ ];
          module' = map (builtins.getAttr "__module") grouped.module or [ ];

          flat-options = lib.mergeAttrsList options';

          real-options = lib.filterAttrs (_: opt: !(opt ? niri-flake-document-internal)) flat-options;

          extra-docs-options = lib.filterAttrs (_: opt: opt ? niri-flake-document-internal) flat-options;
        in
        module'
        ++ [
          {
            options = real-options;
          }
          {
            options._module.niri-flake-ordered-record = {
              ordering = lib.mkOption {
                internal = true;
                # readOnly = true;
                visible = false;
                description = ''
                  Used to influence the order of options in the documentation, such that they are not always sorted alphabetically.

                  Does not affect any other functionality.
                '';
                default = builtins.concatMap builtins.attrNames options';
              };

              inherit extra-docs-options;
            };
          }

        ];

      make-section = type: optional type { };

      section' = flip pipe [
        submodule
        make-section
      ];
      section = flip pipe [
        record
        make-section
      ];
      ordered-section = flip pipe [
        ordered-record
        make-section
      ];
    in
    submodule (
      { options, ... }:
      {
        # config._module.niri-flake-ordered-record.ordering = lib.mkForce [
        #   "input"
        #   "outputs"
        #   "binds"
        #   "switch-events"
        #   "layout"

        #   "workspaces"

        #   "spawn-at-startup"
        #   "prefer-no-csd"
        #   "screenshot-path"
        #   "environment"
        #   "overview"
        #   "cursor"
        #   "xwayland-satellite"
        #   "clipboard"
        #   "hotkey-overlay"

        #   "window-rules"
        #   "layer-rules"
        #   "animations"
        #   "gestures"

        #   "debug"
        # ];
        imports = make-ordered-options [
          {
            switch-events =
              let
                switch-bind = record' "niri switch bind" {
                  action = required (rename "niri switch action" kdl.types.kdl-leaf) // {
                    description = ''
                      A switch action is represented as an attrset with a single key, being the name, and a value that is a list of its arguments.

                      See also ${link-opt ((subopts options.binds).action)} for more information on how this works, it has the exact same option type. Beware that switch binds are not the same as regular binds, and the actions they take are different. Currently, they can only accept spawn binds. Correct usage is like so:

                      ${fmt.nix-code-block ''
                        {
                          ${options.switch-events} = {
                            tablet-mode-on.action.spawn = ["gsettings" "set" "org.gnome.desktop.a11y.applications" "screen-keyboard-enabled" "true"];
                            tablet-mode-off.action.spawn = ["gsettings" "set" "org.gnome.desktop.a11y.applications" "screen-keyboard-enabled" "false"];
                          };
                        }
                      ''}
                    '';
                  };
                };

                switch-bind' = nullable (shorthand-for "switch-bind" switch-bind) // {
                  visible = "shallow";
                };
              in
              ordered-section [
                {
                  tablet-mode-on = switch-bind';
                  tablet-mode-off = switch-bind';
                  lid-open = switch-bind';
                  lid-close = switch-bind';
                }
                {
                  "<switch-bind>" = docs-only switch-bind // {
                    override-loc = lib.const [ "<switch-bind>" ];
                    description = ''
                      <!--
                      This description doesn't matter to the docs, but is necessary to make this header actually render so the above types can link to it.
                      -->
                    '';
                  };
                }
              ];
            binds = attrs-record' "niri keybind" {
              allow-when-locked = optional types.bool false // {
                description = ''
                  Whether this keybind should be allowed when the screen is locked.

                  This is only applicable for ${fmt.code "spawn"} keybinds.
                '';
              };
              allow-inhibiting = optional types.bool true // {
                description = ''
                  When a surface is inhibiting keyboard shortcuts, this option dictates wether ${fmt.em "this"} keybind will be inhibited as well.

                  By default it is true for all keybinds, meaning an application can block this keybind from being triggered, and the application will receive the key event instead.

                  When false, this keybind will always be triggered, even if an application is inhibiting keybinds. There is no way for a client to observe this keypress.

                  Has no effect when ${fmt.code "action"} is ${fmt.code "toggle-keyboard-shortcuts-inhibit"}. In that case, this value is implicitly false, no matter what you set it to. (note that the value reported in the nix config may be inaccurate in that case; although hopefully you're not relying on the values of specific keybinds for the rest of your config?)
                '';
              };
              cooldown-ms = nullable types.int // {
                description = ''
                  The minimum cooldown before a keybind can be triggered again, in milliseconds.

                  This is mostly useful for binds on the mouse wheel, where you might not want to activate an action several times in quick succession. You can use it for any bind, though.
                '';
              };
              repeat = optional types.bool true // {
                description = ''
                  Whether this keybind should trigger repeatedly when held down.
                '';
              };
              hotkey-overlay =
                optional
                  (types.attrTag {
                    hidden = lib.mkOption {
                      type = types.bool;
                      description = ''
                        When ${fmt.code "true"}, the hotkey overlay will not contain this keybind at all. When ${fmt.code "false"}, it will show the default title of the action.
                      '';
                    };
                    title = lib.mkOption {
                      type = types.str;
                      description = ''
                        The title of this keybind in the hotkey overlay. ${
                          fmt.masked-link {
                            href = "https://docs.gtk.org/Pango/pango_markup.html";
                            content = "Pango markup";
                          }
                        } is supported.
                      '';
                    };
                  })
                  {
                    hidden = false;
                  }
                // {
                  description = ''
                    How this keybind should be displayed in the hotkey overlay.

                    ${fmt.list [
                      ''
                        By default, ${fmt.code "{hidden = false;}"} maps to omitting this from the KDL config; the default title of the action will be used.
                      ''
                      ''
                        ${fmt.code "{hidden = true;}"} will emit ${fmt.code "hotkey-overlay-title=null"} in the KDL config, and the hotkey overlay will not contain this keybind at all.
                      ''
                      ''
                        ${fmt.code ''{title = "foo";}''} will emit ${fmt.code ''hotkey-overlay-title="foo"''} in the KDL config, and the hotkey overlay will show "foo" as the title of this keybind.
                      ''
                    ]}
                  '';
                };
              action = required (rename "niri action" kdl.types.kdl-leaf) // {
                description = ''
                  An action is represented as an attrset with a single key, being the name, and a value that is a list of its arguments. For example, to represent a spawn action, you could do this:

                  ${fmt.nix-code-block ''
                    {
                      ${options.binds} = {
                        "XF86AudioRaiseVolume".action.spawn = ["wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1+"];
                        "XF86AudioLowerVolume".action.spawn = ["wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1-"];
                      };
                    }
                  ''}

                  If there is only a single argument, you can pass it directly. It will be implicitly converted to a list in that case.

                  ${fmt.nix-code-block ''
                    {
                      ${options.binds} = {
                        "Mod+D".action.spawn = "fuzzel";
                        "Mod+1".action.focus-workspace = 1;
                      };
                    }
                  ''}

                  For actions taking properties (named arguments), you can pass an attrset.

                  ${fmt.nix-code-block ''
                    {
                      ${options.binds} = {
                        "Mod+Shift+E".action.quit.skip-confirmation = true;
                      };
                    }
                  ''}

                  There is also a set of functions available under ${fmt.code "config.lib.niri.actions"}.

                  Usage is like so:

                  ${fmt.nix-code-block ''
                    {
                      ${options.binds} = with config.lib.niri.actions; {
                        "XF86AudioRaiseVolume".action = spawn "wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1+";
                        "XF86AudioLowerVolume".action = spawn "wpctl" "set-volume" "@DEFAULT_AUDIO_SINK@" "0.1-";

                        "Mod+D".action = spawn "fuzzel";
                        "Mod+1".action = focus-workspace 1;

                        "Mod+Shift+E".action = quit;
                        "Mod+Ctrl+Shift+E".action = quit { skip-confirmation=true; };

                        "Mod+Plus".action = set-column-width "+10%";
                      }
                    }
                  ''}

                  Keep in mind that each one of these attributes (i.e. the nix bindings) are actually identical functions with different node names, and they can take arbitrarily many arguments. The documentation here is based on the ${fmt.em "real"} acceptable arguments for these actions, but the nix bindings do not enforce this. If you pass the wrong arguments, niri will reject the config file, but evaluation will proceed without problems.

                  For actions that don't take any arguments, just use the corresponding attribute from ${fmt.code "config.lib.niri.actions"}. They are listed as ${fmt.code "action-name"}. For actions that ${fmt.em "do"} take arguments, they are notated like so: ${fmt.code "λ action-name :: <args>"}, to clarify that they "should" be used as functions. Hopefully, ${fmt.code "<args>"} will be clear enough in most cases, but it's worth noting some nontrivial kinds of arguments:

                  ${fmt.list [
                    ''
                      ${fmt.code "size-change"}: This is a special argument type used for some actions by niri. It's a string. \
                      It can take either a fixed size as an integer number of logical pixels (${fmt.code ''"480"''}, ${fmt.code ''"1200"''}) or a proportion of your screen as a percentage (${fmt.code ''"30%"''}, ${fmt.code ''"70%"''}) \
                      Additionally, it can either be an absolute change (setting the new size of the window), or a relative change (adding or subtracting from its size). \
                      Relative size changes are written with a ${fmt.code "+"}/${fmt.code "-"} prefix, and absolute size changes have no prefix.
                    ''
                    ''
                      ${fmt.code "{ field :: type }"}: This means that the action takes a named argument (in kdl, we call it a property). \
                      To pass such an argument, you should pass an attrset with the key and value. You can pass many properties in one attrset, or you can pass several attrsets with different properties. \
                      Required fields are marked with ${fmt.code "*"} before their name, and if no fields are required, you can use the action without any arguments too (see ${fmt.code "quit"} in the example above). \
                      If a field is marked with ${fmt.code "?"}, then omitting it is meaningful. (without ${fmt.code "?"}, it will have a default value)
                    ''
                    ''
                      ${fmt.code "[type]"}: This means that the action takes several arguments as a list. Although you can pass a list directly, it's more common to pass them as separate arguments. \
                      ${fmt.code ''spawn ["foo" "bar" "baz"]''} is equivalent to ${fmt.code ''spawn "foo" "bar" "baz"''}.
                    ''
                  ]}

                  ${fmt.admonition.tip ''
                    You can use partial application to create a spawn command with full support for shell syntax:
                    ${fmt.nix-code-block ''
                      {
                        ${options.binds} = with config.lib.niri.actions; let
                          sh = spawn "sh" "-c";
                        in {
                          "Print".action = sh '''grim -g "$(slurp)" - | wl-copy''';
                        };
                      }
                    ''}
                  ''}

                  ${
                    let
                      show-bind =
                        {
                          name,
                          params,
                          ...
                        }:
                        let
                          is-stable = builtins.any (a: a.name == name) binds-stable;
                          is-unstable = builtins.any (a: a.name == name) binds-unstable;
                          exclusive =
                            if is-stable && is-unstable then
                              ""
                            else if is-stable then
                              " (only on niri-stable)"
                            else
                              " (only on niri-unstable)";
                          type-names = {
                            LayoutSwitchTarget = ''"next" | "prev"'';
                            WorkspaceReference = "u8 | string";
                            SizeChange = "size-change";
                            bool = "bool";
                            u8 = "u8";
                            u16 = "u16";
                            String = "string";
                          };

                          type-or =
                            rust-name: fallback: type-names.${rust-name} or (lib.warn "unhandled type `${rust-name}`" fallback);

                          base = content: "${fmt.code content}${exclusive}";
                          lambda = args: base "λ ${name} :: ${args}";
                        in
                        {
                          empty = base "${name}";
                          arg = lambda (type-or params.type (if params.as-str then "string" else params.type));
                          list = lambda "[${type-or params.type params.type}]";
                          prop = lambda "{ ${
                            lib.optionalString (!params.use-default) "*"
                          }${params.field}${lib.optionalString params.none-important "?"} :: ${
                            type-names.${params.type} or (lib.warn "unhandled type `${params.type}`" params.type)
                          } }";
                          unknown = ''
                            ${lambda "unknown"}

                              The code that generates this documentation does not know how to parse the definition:
                              ```rs
                              ${params.raw-name}(${params.raw})
                              ```
                          '';
                        }
                        .${params.kind}
                          or (abort "action `${name}` with unhandled kind `${params.kind}` for settings docs");
                    in
                    fmt.list (
                      (map show-bind (
                        builtins.filter (
                          stable: builtins.all (unstable: stable.name != unstable.name) binds-unstable
                        ) binds-stable
                      ))
                      ++ (map show-bind binds-unstable)
                    )
                  }
                '';
              };
            };
          }

          {
            screenshot-path =
              optional (nullOr types.str) "~/Pictures/Screenshots/Screenshot from %Y-%m-%d %H-%M-%S.png"
              // {
                description = ''
                  The path to save screenshots to.

                  If this is null, then no screenshots will be saved.

                  If the path starts with a ${fmt.code "~"}, then it will be expanded to the user's home directory.

                  The path is then passed to ${
                    fmt.masked-link {
                      href = "https://man7.org/linux/man-pages/man3/strftime.3.html";
                      content = fmt.code "strftime(3)";
                    }
                  } with the current time, and the result is used as the final path.
                '';
              };
          }

          {
            hotkey-overlay = {
              skip-at-startup = optional types.bool false // {
                description = ''
                  Whether to skip the hotkey overlay shown when niri starts.
                '';
              };

              hide-not-bound = optional types.bool false // {
                description = ''
                  By default, niri has a set of important keybinds that are always shown in the hotkey overlay, even if they are not bound to any key.
                  In particular, this helps new users discover important keybinds, especially if their config has no keybinds at all.

                  You can disable this behaviour by setting this option to ${fmt.code "true"}. Then, niri will only show keybinds that are actually bound to a key.
                '';
              };
            };
          }
          {
            config-notification = {
              disable-failed = optional types.bool false // {
                description = ''
                  Disable the notification that the config file failed to load.
                '';
              };
            };
          }

          {
            clipboard.disable-primary = optional types.bool false // {
              description = ''
                The "primary selection" is a special clipboard that contains the text that was last selected with the mouse, and can usually be pasted with the middle mouse button.

                This is a feature that is not inherently part of the core Wayland protocol, but ${
                  fmt.masked-link {
                    href = "https://wayland.app/protocols/primary-selection-unstable-v1#compositor-support";
                    content = "a widely supported protocol extension";
                  }
                } enables support for it anyway.

                This functionality was inherited from X11, is not necessarily intuitive to many users; especially those coming from other operating systems that do not have this feature (such as Windows, where the middle mouse button is used for scrolling).

                If you don't want to have a primary selection, you can disable it with this option. Doing so will prevent niri from adveritising support for the primary selection protocol.

                Note that this option has nothing to do with the "clipboard" that is commonly invoked with ${fmt.kbd "Ctrl+C"} and ${fmt.kbd "Ctrl+V"}.
              '';
            };
          }

          {
            prefer-no-csd = optional types.bool false // {
              description = ''
                Whether to prefer server-side decorations (SSD) over client-side decorations (CSD).
              '';
            };
          }

          {
            spawn-at-startup =
              list (
                types.attrTag {
                  argv = lib.mkOption {
                    type = types.listOf types.str;
                    description = ''
                      Almost raw process arguments to spawn, without shell syntax.

                      A leading tilde in the zeroth argument will be expanded to the user's home directory. No other preprocessing is applied.

                      Usage is like so:

                      ${fmt.nix-code-block ''
                        {
                          ${options.spawn-at-startup} = [
                            { argv = ["waybar"]; }
                            { argv = ["swaybg" "--image" "/path/to/wallpaper.jpg"]; }
                            { argv = ["~/.config/niri/scripts/startup.sh"]; }
                          ];
                        }
                      ''}
                    '';
                  };
                  sh = lib.mkOption {
                    type = types.str;
                    description = ''
                      A shell command to spawn. Run wild with POSIX syntax.

                      ${fmt.nix-code-block ''
                        {
                          ${options.spawn-at-startup} = [
                            { sh = "echo $NIRI_SOCKET > ~/.niri-socket"; }
                          ];
                        }
                      ''}

                      Note that ${fmt.code ''{ sh = "foo"; }''} is exactly equivalent to ${fmt.code ''{ argv = [ "sh" "-c" "foo" ]; }''}.
                    '';
                  };

                  # alias of argv
                  command = lib.mkOption {
                    type = types.listOf types.str;
                    visible = false;
                  };
                }
              )
              // {
                description = ''
                  A list of commands to run when niri starts.

                  Each command can be represented as its raw arguments, or as a shell invocation.

                  When niri is built with the ${fmt.code "systemd"} feature (on by default), commands spawned this way (or with the ${fmt.code "spawn"} and ${fmt.code "spawn-sh"} actions) will be put in a transient systemd unit, which separates the process from niri and prevents e.g. OOM situations from killing the entire session.
                '';
              };
          }

          {
            workspaces =
              attrs-record (key: {
                name = optional types.str key // {
                  defaultText = "the key of the workspace";
                  description = ''
                    The name of the workspace. You set this manually if you want the keys to be ordered in a specific way.
                  '';
                };
                open-on-output = nullable types.str // {
                  description = ''
                    The name of the output the workspace should be assigned to.
                  '';
                };
              })
              // {
                description = ''
                  Declare named workspaces.

                  Named workspaces are similar to regular, dynamic workspaces, except they can be
                  referred to by name, and they are persistent, they do not close when there are
                  no more windows left on them.

                  Usage is like so:

                  ${fmt.nix-code-block ''
                    {
                      ${options.workspaces}."name" = {};
                      ${options.workspaces}."01-another-one" = {
                        open-on-output = "DP-1";
                        name = "another-one";
                      };
                    }
                  ''}

                  Unless a ${fmt.code "name"} is declared, the workspace will use the attribute key as the name.

                  Workspaces will be created in a specific order: sorted by key. If you do not care
                  about the order of named workspaces, you can skip using the ${fmt.code "name"} attribute, and
                  use the key instead. If you do care about it, you can use the key to order them,
                  and a ${fmt.code "name"} attribute to have a friendlier name.
                '';
              };
          }

          {
            overview = {
              zoom = nullable float-or-int // {
                description = ''
                  Control how much the workspaces zoom out in the overview. zoom ranges from 0 to 0.75 where lower values make everything smaller.
                '';
              };
              backdrop-color = nullable types.str // {
                description = ''
                  Set the backdrop color behind workspaces in the overview. The backdrop is also visible between workspaces when switching.

                  The alpha channel for this color will be ignored.
                '';
              };

              workspace-shadow = {
                enable = optional types.bool true;
                offset =
                  nullable (record {
                    x = optional float-or-int 0.0;
                    y = optional float-or-int 5.0;
                  })
                  // {
                    description = shadow-descriptions.offset;
                  };

                softness = nullable float-or-int // {
                  description = shadow-descriptions.softness;
                };

                spread = nullable float-or-int // {
                  description = shadow-descriptions.spread;
                };

                color = nullable types.str;
              };
            };
          }

          {
            input = {
              keyboard = {
                xkb =
                  let
                    arch-man-xkb =
                      anchor:
                      fmt.masked-link {
                        href = "https://man.archlinux.org/man/xkeyboard-config.7#${anchor}";
                        content = fmt.code "xkeyboard-config(7)";
                      };

                    default-env = default: field: ''
                      If this is set to ${default}, the ${field} will be read from the ${fmt.code "XKB_DEFAULT_${lib.toUpper field}"} environment variable.
                    '';

                    str-fallback = default-env "an empty string";
                    nullable-fallback = default-env "null";

                    base = {
                      layout = optional types.str "" // {
                        description = ''
                          A comma-separated list of layouts (languages) to include in the keymap.

                          See ${arch-man-xkb "LAYOUTS"} for a list of available layouts and their variants.

                          ${str-fallback "layout"}
                        '';
                      };
                      model = optional types.str "" // {
                        description = ''
                          The keyboard model by which to interpret keycodes and LEDs

                          See ${arch-man-xkb "MODELS"} for a list of available models.

                          ${str-fallback "model"}
                        '';
                      };
                      rules = optional types.str "" // {
                        description = ''
                          The rules file to use.

                          The rules file describes how to interpret the values of the model, layout, variant and options fields.

                          ${str-fallback "rules"}
                        '';
                      };
                      variant = optional types.str "" // {
                        description = ''
                          A comma separated list of variants, one per layout, which may modify or augment the respective layout in various ways.

                          See ${arch-man-xkb "LAYOUTS"} for a list of available variants for each layout.

                          ${str-fallback "variant"}
                        '';
                      };
                      options = nullable types.str // {
                        description = ''
                          A comma separated list of options, through which the user specifies non-layout related preferences, like which key combinations are used for switching layouts, or which key is the Compose key.

                          See ${arch-man-xkb "OPTIONS"} for a list of available options.

                          If this is set to an empty string, no options will be used.

                          ${nullable-fallback "options"}
                        '';
                      };
                    };
                    # base' = mapAttrs (name: opt: opt // optionalAttrs (opt.default == "" || opt.default == null) {defaultText = "${if opt.default == "" then "\"\"" else "null"} (inherited from XKB_DEFAULT_${toUpper name}>";}) base;
                  in
                  ordered-section [
                    {
                      file = nullable types.str // {
                        description = ''
                          Path to a ${fmt.code ".xkb"} keymap file. If set, this file will be used to configure libxkbcommon, and all other options will be ignored.
                        '';
                      };
                    }
                    base
                  ]
                  // {
                    description = ''
                      Parameters passed to libxkbcommon, which handles the keyboard in niri.

                      Further reading:
                      ${fmt.list [
                        (fmt.masked-link {
                          href = "https://docs.rs/smithay/latest/smithay/wayland/seat/struct.XkbConfig.html";
                          content = fmt.code "smithay::wayland::seat::XkbConfig";
                        })
                      ]}
                    '';
                  };
                repeat-delay = optional types.int 600 // {
                  description = ''
                    The delay in milliseconds before a key starts repeating.
                  '';
                };
                repeat-rate = optional types.int 25 // {
                  description = ''
                    The rate in characters per second at which a key repeats.
                  '';
                };
                track-layout =
                  optional (enum [
                    "global"
                    "window"
                  ]) "global"
                  // {
                    description = ''
                      The keyboard layout can be remembered per ${fmt.code ''"window"''}, such that when you switch to a window, the keyboard layout is set to the one that was last used in that window.

                      By default, there is only one ${fmt.code ''"global"''} keyboard layout and changing it in any window will affect the keyboard layout used in all other windows too.
                    '';
                  };
                numlock = optional types.bool false // {
                  description = ''
                    Enable numlock by default
                  '';
                };
              };
              touchpad =
                pointer-tablet-common
                // basic-pointer true
                // {
                  tap = optional types.bool true // {
                    description = ''
                      Whether to enable tap-to-click.

                      Further reading:
                      ${fmt.list [
                        (libinput-link "configuration" "Tap-to-click")
                        (libinput-link "tapping" "Tap-to-click behaviour")
                      ]}
                    '';
                  };
                  dwt = optional types.bool false // {
                    description = ''
                      Whether to disable the touchpad while typing.

                      Further reading:
                      ${fmt.list [
                        (libinput-link "configuration" "Disable while typing")
                        (libinput-link "palm-detection" "Disable-while-typing")
                      ]}
                    '';
                  };
                  dwtp = optional types.bool false // {
                    description = ''
                      Whether to disable the touchpad while the trackpoint is in use.

                      Further reading:
                      ${fmt.list [
                        (libinput-link "configuration" "Disable while trackpointing")
                        (libinput-link "palm-detection" "Disable-while-trackpointing")
                      ]}
                    '';
                  };
                  drag = nullable types.bool // {
                    description = ''
                      On most touchpads, "tap and drag" is enabled by default. This option allows you to explicitly enable or disable it.

                      Tap and drag means that to drag an item, you tap the touchpad with some amount of fingers to decide what kind of button press is emulated, but don't hold those fingers, and then you immediately start dragging with one finger.

                      Further reading:
                      ${fmt.list [
                        (libinput-link "tapping" "Tap-and-drag")
                      ]}
                    '';
                  };
                  drag-lock = optional types.bool false // {
                    description = ''
                      By default, a "tap and drag" gesture is terminated by releasing the finger that is dragging.

                      Drag lock means that the drag gesture is not terminated when the finger is released, but only when the finger is tapped again, or after a timeout (unless sticky mode is enabled). This allows you to reset your finger position without losing the drag gesture.

                      Drag lock is only applicable when tap and drag is enabled.

                      Further reading:
                      ${fmt.list [
                        (libinput-link "tapping" "Tap-and-drag")
                      ]}
                    '';
                  };

                  disabled-on-external-mouse = optional types.bool false // {
                    description = ''
                      Whether to disable the touchpad when an external mouse is plugged in.

                      Further reading:
                      ${fmt.list [
                        (libinput-link "configuration" "Send Events Mode")
                      ]}
                    '';
                  };
                  tap-button-map =
                    nullable (enum [
                      "left-middle-right"
                      "left-right-middle"
                    ])
                    // {
                      description = ''
                        The mouse button to register when tapping with 1, 2, or 3 fingers, when ${link-opt options.input.touchpad.tap} is enabled.

                        Further reading:
                        ${fmt.list [
                          (libinput-link "configuration" "Tap-to-click")
                        ]}
                      '';
                    };
                  click-method =
                    nullable (enum [
                      "button-areas"
                      "clickfinger"
                    ])
                    // {
                      description = ''
                        Method to determine which mouse button is pressed when you click the touchpad.

                        ${fmt.list [
                          ''
                            ${fmt.code ''"button-areas"''}: ${libinput-doc "clickpad-softbuttons" "Software button areas"} \
                            The button is determined by which part of the touchpad was clicked.
                          ''
                          ''
                            ${fmt.code ''"clickfinger"''}: ${libinput-doc "clickpad-softbuttons" "Clickfinger behavior"} \
                            The button is determined by how many fingers clicked.
                          ''
                        ]}

                        Further reading:
                        ${fmt.list [
                          (libinput-link "configuration" "Click method")
                          (libinput-link "clickpad-softbuttons" "Clickpad software button behavior")
                        ]}
                      '';
                    };

                  scroll-factor =
                    nullable (
                      types.either float-or-int (record {
                        horizontal = optional float-or-int 1.0;
                        vertical = optional float-or-int 1.0;
                      })
                    )
                    // {
                      description = ''
                        For all scroll events triggered by a finger source, the scroll distance is multiplied by this factor.

                        This is not a libinput property, but rather a niri-specific one.
                      '';
                    };
                };
              mouse =
                pointer-tablet-common
                // basic-pointer false
                // {
                  scroll-factor =
                    nullable (
                      types.either float-or-int (record {
                        horizontal = optional float-or-int 1.0;
                        vertical = optional float-or-int 1.0;
                      })
                    )
                    // {
                      description = ''
                        For all scroll events triggered by a wheel source, the scroll distance is multiplied by this factor.

                        This is not a libinput property, but rather a niri-specific one.
                      '';
                    };
                };
              trackpoint = pointer-tablet-common // basic-pointer false;
              trackball = pointer-tablet-common // basic-pointer false;
              tablet = pointer-tablet-common // {
                map-to-output = nullable types.str;
                calibration-matrix =
                  nullable (mkOptionType {
                    name = "matrix";
                    description = "2x3 matrix";
                    check =
                      matrix:
                      builtins.isList matrix
                      && builtins.length matrix == 2
                      && builtins.all (
                        row: builtins.isList row && builtins.length row == 3 && builtins.all builtins.isFloat row
                      ) matrix;
                    merge = lib.mergeUniqueOption {
                      message = "";
                      merge = loc: defs: builtins.concatLists (builtins.head defs).value;
                    };
                  })
                  // {
                    description = ''
                      An augmented calibration matrix for the tablet.

                      This is represented in Nix as a 2-list of 3-lists of floats.

                      For example:
                      ${fmt.nix-code-block ''
                        {
                          # 90 degree rotation clockwise
                          calibration-matrix = [
                            [ 0.0 -1.0 1.0 ]
                            [ 1.0  0.0 0.0 ]
                          ];
                        }
                      ''}

                      Further reading:
                      ${fmt.list [
                        (fmt.masked-link {
                          href = "https://wayland.freedesktop.org/libinput/doc/1.8.2/group__config.html#ga3d9f1b9be10e804e170c4ea455bd1f1b";
                          content = fmt.code "libinput_device_config_calibration_get_default_matrix()";
                        })
                        (fmt.masked-link {
                          href = "https://wayland.freedesktop.org/libinput/doc/1.8.2/group__config.html#ga09a798f58cc601edd2797780096e9804";
                          content = fmt.code "libinput_device_config_calibration_set_matrix()";
                        })
                        (fmt.masked-link {
                          href = "https://smithay.github.io/smithay/input/struct.Device.html#method.config_calibration_set_matrix";
                          content = "rustdoc because libinput's web docs are an eyesore";
                        })
                      ]}
                    '';
                  };
              };
              touch.enable = optional types.bool true;
              touch.map-to-output = nullable types.str;
              warp-mouse-to-focus =
                let
                  inner = record {
                    enable = optional types.bool false;
                    mode = nullable types.str;
                  };

                  actual-type = mkOptionType {
                    inherit (inner)
                      name
                      description
                      getSubOptions
                      nestedTypes
                      ;

                    check = value: builtins.isBool value || inner.check value;
                    merge =
                      loc: defs:
                      lib.warnIf (builtins.any (def: builtins.isBool def.value) defs)
                        (rename-warning loc (loc ++ [ "enable" ]) (builtins.filter (def: builtins.isBool def.value) defs))
                        inner.merge
                        loc
                        (map (def: if builtins.isBool def.value then def // { value.enable = def.value; } else def) defs);
                  };
                in
                optional actual-type { }
                // {
                  description = ''
                    Whether to warp the mouse to the focused window when switching focus.
                  '';
                };
              focus-follows-mouse.enable = optional types.bool false // {
                description = ''
                  Whether to focus the window under the mouse when the mouse moves.
                '';
              };
              focus-follows-mouse.max-scroll-amount = nullable types.str // {
                description = ''
                  The maximum proportion of the screen to scroll at a time
                '';
              };

              workspace-auto-back-and-forth = optional types.bool false // {
                description = ''
                  When invoking ${fmt.code "focus-workspace"} to switch to a workspace by index, if the workspace is already focused, usually nothing happens. When this option is enabled, the workspace will cycle back to the previously active workspace.

                  Of note is that it does not switch to the previous ${fmt.em "index"}, but the previous ${fmt.em "workspace"}. That means you can reorder workspaces inbetween these actions, and it will still take you to the actual same workspace you came from.
                '';
              };

              power-key-handling.enable = optional types.bool true // {
                description = ''
                  By default, niri will take over the power button to make it sleep instead of power off.

                  You can disable this behaviour if you prefer to configure the power button elsewhere.
                '';
              };

              mod-key = nullable types.str;
              mod-key-nested = nullable types.str;
            };
          }

          {
            outputs = attrs-record (key: {
              name = optional types.str key // {
                defaultText = "the key of the output";
                description = ''
                  The name of the output. You set this manually if you want the outputs to be ordered in a specific way.
                '';
              };
              enable = optional types.bool true;
              backdrop-color = nullable types.str // {
                description = ''
                  The backdrop color that niri draws for this output. This is visible between workspaces or in the overview.
                '';
              };
              background-color = nullable types.str // {
                description = ''
                  The background color of this output. This is equivalent to launching ${fmt.code "swaybg -c <color>"} on that output, but is handled by the compositor itself for solid colors.
                '';
              };
              scale = nullable float-or-int // {
                description = ''
                  The scale of this output, which represents how many physical pixels fit in one logical pixel.

                  If this is null, niri will automatically pick a scale for you.
                '';
              };
              transform = {
                flipped = optional types.bool false // {
                  description = ''
                    Whether to flip this output vertically.
                  '';
                };
                rotation =
                  optional (enum [
                    0
                    90
                    180
                    270
                  ]) 0
                  // {
                    description = ''
                      Counter-clockwise rotation of this output in degrees.
                    '';
                  };
              };
              position =
                nullable (record {
                  x = required types.int;
                  y = required types.int;
                })
                // {
                  description = ''
                    Position of the output in the global coordinate space.

                    This affects directional monitor actions like "focus-monitor-left", and cursor movement.

                    The cursor can only move between directly adjacent outputs.

                    Output scale has to be taken into account for positioning, because outputs are sized in logical pixels.

                    For example, a 3840x2160 output with scale 2.0 will have a logical size of 1920x1080, so to put another output directly adjacent to it on the right, set its x to 1920.

                    If the position is unset or multiple outputs overlap, niri will instead place the output automatically.
                  '';
                };
              mode =
                nullable (record {
                  width = required types.int;
                  height = required types.int;
                  refresh = nullable types.float // {
                    description = ''
                      The refresh rate of this output. When this is null, but the resolution is set, niri will automatically pick the highest available refresh rate.
                    '';
                  };
                })
                // {
                  description = ''
                    The resolution and refresh rate of this display.

                    By default, when this is null, niri will automatically pick a mode for you.

                    If this is set to an invalid mode (i.e unsupported by this output), niri will act as if it is unset and pick one for you.
                  '';
                };

              variable-refresh-rate =
                optional (enum [
                  false
                  "on-demand"
                  true
                ]) false
                // {
                  description = ''
                    Whether to enable variable refresh rate (VRR) on this output.

                    VRR is also known as Adaptive Sync, FreeSync, and G-Sync.

                    Setting this to ${fmt.code ''"on-demand"''} will enable VRR only when a window with ${link-opt (subopts options.window-rules).variable-refresh-rate} is present on this output.
                  '';
                };

              focus-at-startup = optional types.bool false // {
                description = ''
                  Focus this output by default when niri starts.

                  If multiple outputs with ${fmt.code "focus-at-startup"} are connected, then the one with the key that sorts first will be focused. You can change the key to affect the sorting order, and set ${link-opt (subopts options.outputs).name} to be the actual name of the output.

                  When none of the connected outputs are explicitly focus-at-startup, niri will focus the first one sorted by name (same output sorting as used elsewhere in niri).
                '';
              };
            });
          }

          {
            cursor = section' {
              imports = [
                (lib.mkRenamedOptionModule [ "hide-on-key-press" ] [ "hide-when-typing" ])
              ];
              options = {
                theme = optional types.str "default" // {
                  description = ''
                    The name of the xcursor theme to use.

                    This will also set the XCURSOR_THEME environment variable for all spawned processes.
                  '';
                };
                size = optional types.int 24 // {
                  description = ''
                    The size of the cursor in logical pixels.

                    This will also set the XCURSOR_SIZE environment variable for all spawned processes.
                  '';
                };
                hide-when-typing = optional types.bool false // {
                  description = ''
                    Whether to hide the cursor when typing.
                  '';
                };
                hide-after-inactive-ms = nullable types.int // {
                  description = ''
                    If set, the cursor will automatically hide once this number of milliseconds passes since the last cursor movement.
                  '';
                };
              };
            };
          }

          {
            layout = ordered-section [
              {
                focus-ring = borderish {
                  enable-by-default = true;
                  name = "focus ring";
                  window = "focused window";
                  description = ''
                    The focus ring is a decoration drawn ${fmt.em "around"} the last focused window on each monitor. It takes no space away from windows. If you have insufficient gaps, the focus ring can be drawn over adjacent windows, but it will never affect the layout of windows.

                    The focused window of the currently focused monitor, i.e. the window that can receive keyboard input, will be drawn according to ${link-opt (subopts (subopts options.layout).focus-ring).active}, and the last focused window on all other monitors will be drawn according to ${link-opt (subopts (subopts options.layout).focus-ring).inactive}.

                    If you have ${link-opt (subopts options.layout).border} enabled, the focus ring will be drawn around (and under) the border.
                  '';
                };

                border = borderish {
                  enable-by-default = false;
                  name = "border";
                  window = "window";
                  description = ''
                    The border is a decoration drawn ${fmt.em "inside"} every window in the layout. It will take space away from windows. That is, if you have a border of 8px, then each window will be 8px smaller on each edge than if you had no border.

                    The currently focused window, i.e. the window that can receive keyboard input, will be drawn according to ${link-opt (subopts (subopts options.layout).border).active}, and all other windows will be drawn according to ${link-opt (subopts (subopts options.layout).border).inactive}.

                    If you have ${link-opt (subopts options.layout).focus-ring} enabled, the border will be drawn inside (and over) the focus ring.
                  '';
                };
              }
              {
                shadow = section {
                  enable = optional types.bool false;
                  offset =
                    section {
                      x = optional float-or-int 0.0;
                      y = optional float-or-int 5.0;
                    }
                    // {
                      description = shadow-descriptions.offset;
                    };

                  softness = optional float-or-int 30.0 // {
                    description = shadow-descriptions.softness;
                  };

                  spread = optional float-or-int 5.0 // {
                    description = shadow-descriptions.spread;
                  };

                  draw-behind-window = optional types.bool false;

                  # 0x70 is 43.75% so let's use hex notation lol
                  color = optional types.str "#00000070";

                  inactive-color = nullable types.str;
                };
              }
              {
                insert-hint =
                  section' (
                    { options, ... }:
                    {
                      imports = make-ordered-options [
                        {
                          enable = optional types.bool true // {
                            description = ''
                              Whether to enable the insert hint.
                            '';
                          };
                        }
                        (make-decoration-options options {
                          display.description = ''
                            The color of the insert hint.
                          '';
                        })
                      ];
                    }
                  )
                  // {
                    description = ''
                      The insert hint is a decoration drawn ${fmt.em "between"} windows during an interactive move operation. It is drawn in the gap where the window will be inserted when you release the window. It does not occupy any space in the gap, and the insert hint extends onto the edges of adjacent windows. When you release the moved window, the windows that are covered by the insert hint will be pushed aside to make room for the moved window.
                    '';
                  };
              }
              {
                "<decoration>" =
                  let
                    self = docs-only (decoration (self // { loc = [ "<decoration>" ]; })) // {
                      override-loc = lib.const [ "<decoration>" ];
                      description = ''
                        A decoration is drawn around a surface, adding additional elements that are not necessarily part of an application, but are part of what we think of as a "window".

                        This type specifically represents decorations drawn by niri: that is, ${link-opt (subopts options.layout).focus-ring} and/or ${link-opt (subopts options.layout).border}.
                      '';
                    };
                  in
                  self;
              }
              {
                background-color = nullable types.str // {
                  description = ''
                    The default background color that niri draws for workspaces. This is visible when you're not using any background tools like swaybg.
                  '';
                };
              }
              {
                preset-column-widths = list preset-width // {
                  description = ''
                    The widths that ${fmt.code "switch-preset-column-width"} will cycle through.

                    Each width can either be a fixed width in logical pixels, or a proportion of the screen's width.

                    Example:

                    ${fmt.nix-code-block ''
                      {
                        ${(subopts options.layout).preset-column-widths} = [
                          { proportion = 1. / 3.; }
                          { proportion = 1. / 2.; }
                          { proportion = 2. / 3.; }

                          # { fixed = 1920; }
                        ];
                      }
                    ''}
                  '';
                };
                preset-window-heights = list preset-height // {
                  description = ''
                    The heights that ${fmt.code "switch-preset-window-height"} will cycle through.

                    Each height can either be a fixed height in logical pixels, or a proportion of the screen's height.

                    Example:

                    ${fmt.nix-code-block ''
                      {
                        ${(subopts options.layout).preset-window-heights} = [
                          { proportion = 1. / 3.; }
                          { proportion = 1. / 2.; }
                          { proportion = 2. / 3.; }

                          # { fixed = 1080; }
                        ];
                      }
                    ''}
                  '';
                };
              }
              {
                default-column-width = optional default-width { } // {
                  description = ''
                    The default width for new columns.

                    When this is set to an empty attrset ${fmt.code "{}"}, windows will get to decide their initial width. This is not null, such that it can be distinguished from window rules that don't touch this

                    See ${link-opt (subopts options.layout).preset-column-widths} for more information.

                    You can override this for specific windows using ${link-opt (subopts options.window-rules).default-column-width}
                  '';
                };
                center-focused-column =
                  optional (enum [
                    "never"
                    "always"
                    "on-overflow"
                  ]) "never"
                  // {
                    description = ''
                      When changing focus, niri can automatically center the focused column.

                      ${fmt.list [
                        "${fmt.code ''"never"''}: If the focused column doesn't fit, it will be aligned to the edges of the screen."
                        "${fmt.code ''"on-overflow"''}: if the focused column doesn't fit, it will be centered on the screen."
                        "${fmt.code ''"always"''}: the focused column will always be centered, even if it was already fully visible."
                      ]}
                    '';
                  };
                always-center-single-column = optional types.bool false // {
                  description = ''
                    This is like ${fmt.code ''center-focused-column = "always";''}, but only for workspaces with a single column. Changes nothing if ${fmt.code "center-focused-column"} is set to ${fmt.code ''"always"''}. Has no effect if more than one column is present.
                  '';
                };
                default-column-display =
                  optional (enum [
                    "normal"
                    "tabbed"
                  ]) "normal"
                  // {
                    description = ''
                      How windows in columns should be displayed by default.

                      ${fmt.list [
                        "${fmt.code ''"normal"''}: Windows are arranged vertically, spread across the working area height."
                        "${fmt.code ''"tabbed"''}: Windows are arranged in tabs, with only the focused window visible, taking up the full height of the working area."
                      ]}

                      Note that you can override this for a given column at any time. Every column remembers its own display mode, independent from this setting. This setting controls the default value when a column is ${fmt.em "created"}.

                      Also, since a newly created column always contains a single window, you can override this default value with ${link-opt (subopts options.window-rules).default-column-display}.
                    '';
                  };

                tab-indicator = nullable (
                  submodule (
                    { options, ... }:
                    {
                      imports = make-ordered-options [
                        {
                          enable = optional types.bool true;
                          hide-when-single-tab = optional types.bool false;
                          place-within-column = optional types.bool false;
                          gap = optional float-or-int 5.0;
                          width = optional float-or-int 4.0;
                          length.total-proportion = optional types.float 0.5;
                          position = optional (enum [
                            "left"
                            "right"
                            "top"
                            "bottom"
                          ]) "left";
                          gaps-between-tabs = optional float-or-int 0.0;
                          corner-radius = optional float-or-int 0.0;
                        }

                        (make-decoration-options options {
                          urgent.description = ''
                            The color of the tab indicator for windows that are requesting attention.
                          '';
                          active.description = ''
                            The color of the tab indicator for the window that has keyboard focus.
                          '';
                          inactive.description = ''
                            The color of the tab indicator for windows that do not have keyboard focus.
                          '';
                        })

                      ];
                    }
                  )
                );
              }
              {
                empty-workspace-above-first = optional types.bool false // {
                  description = ''
                    Normally, niri has a dynamic amount of workspaces, with one empty workspace at the end. The first workspace really is the first workspace, and you cannot go past it, but going past the last workspace puts you on the empty workspace.

                    When this is enabled, there will be an empty workspace above the first workspace, and you can go past the first workspace to get to an empty workspace, just as in the other direction. This makes workspace navigation symmetric in all ways except indexing.
                  '';
                };
                gaps = optional float-or-int 16 // {
                  description = ''
                    The gap between windows in the layout, measured in logical pixels.
                  '';
                };
                struts =
                  section {
                    left = optional float-or-int 0;
                    right = optional float-or-int 0;
                    top = optional float-or-int 0;
                    bottom = optional float-or-int 0;
                  }
                  // {
                    description = ''
                      The distances from the edges of the screen to the eges of the working area.

                      The top and bottom struts are absolute gaps from the edges of the screen. If you set a bottom strut of 64px and the scale is 2.0, then the output will have 128 physical pixels under the scrollable working area where it only shows the wallpaper.

                      Struts are computed in addition to layer-shell surfaces. If you have a waybar of 32px at the top, and you set a top strut of 16px, then you will have 48 logical pixels from the actual edge of the display to the top of the working area.

                      The left and right structs work in a similar way, except the padded space is not empty. The horizontal struts are used to constrain where focused windows are allowed to go. If you define a left strut of 64px and go to the first window in a workspace, that window will be aligned 64 logical pixels from the left edge of the output, rather than snapping to the actual edge of the screen. If another window exists to the left of this window, then you will see 64px of its right edge (if you have zero borders and gaps)
                    '';
                  };
              }
            ];
          }

          {
            animations =
              let
                animation-kind = types.attrTag {
                  spring = section {
                    damping-ratio = required types.float;
                    stiffness = required types.int;
                    epsilon = required types.float;
                  };
                  easing = section {
                    duration-ms = required types.int;
                    curve =
                      required (enum [
                        "linear"
                        "ease-out-quad"
                        "ease-out-cubic"
                        "ease-out-expo"
                        "cubic-bezier"
                      ])
                      // {
                        description = ''
                          The curve to use for the easing function.
                        '';
                      };

                    # eh? not loving this. but anything better is kinda nontrivial.
                    # will refactor, currently just a stopgap so that it is usable.
                    curve-args = list kdl.types.kdl-value // {
                      description = ''
                        Arguments to the easing curve. ${fmt.code "cubic-bezier"} requires 4 arguments, all others don't allow arguments.
                      '';
                    };
                  };
                };

                anims = {
                  workspace-switch.has-shader = false;
                  horizontal-view-movement.has-shader = false;
                  config-notification-open-close.has-shader = false;
                  exit-confirmation-open-close.has-shader = false;
                  window-movement.has-shader = false;
                  window-open.has-shader = true;
                  window-close.has-shader = true;
                  window-resize.has-shader = true;
                  screenshot-ui-open.has-shader = false;
                  overview-open-close.has-shader = false;
                };
              in
              ordered-section [
                {
                  enable = optional types.bool true;
                  slowdown = nullable float-or-int;
                }
                {
                  all-anims = mkOption {
                    type = types.raw;
                    internal = true;
                    visible = false;

                    default = builtins.attrNames anims;
                  };
                }
                (builtins.mapAttrs (
                  name:
                  (
                    { has-shader }:
                    let
                      inner = record (
                        {
                          enable = optional types.bool true;
                          kind = nullable (shorthand-for "animation-kind" animation-kind) // {
                            visible = "shallow";
                          };
                        }
                        // lib.optionalAttrs has-shader {
                          custom-shader = nullable types.str // {
                            description = ''
                              Source code for a GLSL shader to use for this animation.

                              For example, set it to ${fmt.code "builtins.readFile ./${name}.glsl"} to use a shader from the same directory as your configuration file.

                              See: ${fmt.bare-link "https://github.com/YaLTeR/niri/wiki/Configuration:-Animations#custom-shader"}
                            '';
                          };
                        }
                      );

                      actual-type = mkOptionType {
                        inherit (inner)
                          name
                          description
                          getSubOptions
                          nestedTypes
                          ;

                        check = value: builtins.isNull value || animation-kind.check value || inner.check value;
                        merge =
                          loc: defs:
                          inner.merge loc (
                            map (
                              def:
                              if builtins.isNull def.value then
                                lib.warn (obsolete-warning "${showOption loc} = null;" "${
                                  showOption (loc ++ [ "enable" ])
                                } = false;" [ def ]) def
                                // {
                                  value.enable = false;
                                }
                              else if animation-kind.check def.value then
                                lib.warn (rename-warning loc (loc ++ [ "kind" ]) [ def ]) def // { value.kind = def.value; }
                              else
                                def
                            ) defs
                          );
                      };
                    in
                    optional actual-type { }
                  )
                ) anims)
                {
                  "<animation-kind>" = docs-only animation-kind // {
                    override-loc = lib.const [ "<animation-kind>" ];
                  };
                }
                (
                  let
                    deprecated-shaders = [
                      "window-open"
                      "window-close"
                      "window-resize"
                    ];
                  in
                  {
                    __module =
                      {
                        options,
                        config,
                        ...
                      }:
                      {
                        options.shaders = lib.genAttrs deprecated-shaders (
                          _: required (nullOr types.str) // { visible = false; }
                        );
                        config = lib.genAttrs deprecated-shaders (
                          name:
                          let
                            old = options.shaders.${name};
                          in
                          lib.mkIf (old.isDefined) (
                            lib.warn
                              (rename-warning (old.loc) (options.${name}.loc ++ [ "custom-shader" ]) old.definitionsWithLocations)
                              {
                                custom-shader = config.shaders.${name};
                              }
                          )
                        );
                      };
                  }
                )
              ];

            gestures =
              let
                scroll-description.trigger = measure: ''
                  The ${measure} of the edge of the screen where dragging a window will scroll the view.
                '';
                scroll-description.delay-ms = ''
                  The delay in milliseconds before the view starts scrolling.
                '';
                scroll-description.max-speed-for = measure: ''
                  When the cursor is at boundary of the trigger ${measure}, the view will not be scrolling. Moving the mouse further away from the boundary and closer to the egde will linearly increase the scrolling speed, until the mouse is pressed against the edge of the screen, at which point the view will scroll at this speed. The speed is measured in logical pixels per second.
                '';
              in
              {
                dnd-edge-view-scroll =
                  section {
                    trigger-width = nullable float-or-int // {
                      description = scroll-description.trigger "width";
                    };
                    delay-ms = nullable types.int // {
                      description = scroll-description.delay-ms;
                    };
                    max-speed = nullable float-or-int // {
                      description = scroll-description.max-speed-for "width";
                    };
                  }
                  // {
                    description = ''
                      When dragging a window to the left or right edge of the screen, the view will start scrolling in that direction.
                    '';
                  };
                dnd-edge-workspace-switch =
                  section {
                    trigger-height = nullable float-or-int // {
                      description = scroll-description.trigger "height";
                    };
                    delay-ms = nullable types.int // {
                      description = scroll-description.delay-ms;
                    };
                    max-speed = nullable float-or-int // {
                      description = scroll-description.max-speed-for "height";
                    };
                  }
                  // {
                    description = ''
                      In the overview, when dragging a window to the top or bottom edge of the screen, view will start scrolling in that direction.

                      This does not happen when the overview is not open.
                    '';
                  };
                hot-corners.enable = optional types.bool true // {
                  description = ''
                    Put your mouse at the very top-left corner of a monitor to toggle the overview. Also works during drag-and-dropping something.
                  '';
                };
              };
          }

          {
            environment = attrs (nullOr types.str) // {
              description = ''
                Environment variables to set for processes spawned by niri.

                If an environment variable is already set in the environment, then it will be overridden by the value set here.

                If a value is null, then the environment variable will be unset, even if it already existed.

                Examples:

                ${fmt.nix-code-block ''
                  {
                    ${options.environment} = {
                      QT_QPA_PLATFORM = "wayland";
                      DISPLAY = null;
                    };
                  }
                ''}
              '';
            };
          }

          {
            window-rules =
              let
                window-rule-descriptions = rule-descriptions {
                  surface = "window";
                  surfaces = "windows";
                  surface-rule = "window rule";
                  Surface-rules = "Window rules";

                  self = options.window-rules;
                  spawn-at-startup = options.spawn-at-startup;

                  example-fields = [
                    ''
                      The ${fmt.code "title"} field, when non-null, is a regular expression. It will match a window if the client has set a title and its title matches the regular expression.
                    ''
                    ''
                      The ${fmt.code "app-id"} field, when non-null, is a regular expression. It will match a window if the client has set an app id and its app id matches the regular expression.
                    ''
                  ];
                };

                window-match = ordered-record' "match rule" [
                  {
                    app-id = nullable regex // {
                      description = ''
                        A regular expression to match against the app id of the window.

                        When non-null, for this field to match a window, a client must set the app id of its window and the app id must match this regex.
                      '';
                    };
                    title = nullable regex // {
                      description = ''
                        A regular expression to match against the title of the window.

                        When non-null, for this field to match a window, a client must set the title of its window and the title must match this regex.
                      '';
                    };
                  }
                  {
                    is-urgent = nullable types.bool // {
                      description = ''
                        When non-null, for this field to match a window, the value must match whether the window is in the urgent state or not.

                        A window can request attention by sending an XDG activation request. Such a request can be associated with an input event (e.g. in response to you clicking a notification), in which case it will be focused right away. It can also request attention without an input event, in which case it will simply be marked as "urgent". An urgent state doesn't do anything by itself, but it can be matched on to apply a window rule only to such windows.
                      '';
                    };
                    is-active = nullable types.bool // {
                      description = ''
                        When non-null, for this field to match a window, the value must match whether the window is active or not.

                        Every monitor has up to one active window, and ${fmt.code "is-active=true"} will match the active window on each monitor. A monitor can have zero active windows if no windows are open on it. There can never be more than one active window on a monitor.
                      '';
                    };
                    is-active-in-column = nullable types.bool // {
                      description = ''
                        When non-null, for this field to match a window, the value must match whether the window is active in its column or not.

                        Every column has exactly one active-in-column window. If it is the active column, this window is also the active window. A column may not have zero active-in-column windows, or more than one active-in-column window.

                        The active-in-column window is the window that was last focused in that column. When you switch focus to a column, the active-in-column window will be the new focused window.
                      '';
                    };
                    is-focused = nullable types.bool // {
                      description = ''
                        When non-null, for this field to match a window, the value must match whether the window has keyboard focus or not.

                        A note on terminology used here: a window is actually a toplevel surface, and a surface just refers to any rectangular region that a client can draw to. A toplevel surface is just a surface with additional capabilities and properties (e.g. "fullscreen", "resizable", "min size", etc)

                        For a window to be focused, its surface must be focused. There is up to one focused surface, and it is the surface that can receive keyboard input. There can never be more than one focused surface. There can be zero focused surfaces if and only if there are zero surfaces. The focused surface does ${fmt.em "not"} have to be a toplevel surface. It can also be a layer-shell surface. In that case, there is a surface with keyboard focus but no ${fmt.em "window"} with keyboard focus.
                      '';
                    };
                    is-floating = nullable types.bool // {
                      description = ''
                        When not-null, for this field to match a window, the value must match whether the window is floating (true) or tiled (false).
                      '';
                    };
                    is-window-cast-target = nullable types.bool // {
                      description = ''
                        When non-null, matches based on whether the window is being targeted by a window cast.
                      '';
                    };
                  }
                  {
                    at-startup = nullable types.bool // {
                      description = window-rule-descriptions.match-at-startup;
                    };
                  }
                ];
              in
              list (
                ordered-record' "window rule" [
                  {
                    matches = list window-match // {
                      description = ''
                        A list of rules to match windows.

                        If any of these rules match a window (or there are none), that window rule will be considered for this window. It can still be rejected by ${link-opt (subopts options.window-rules).excludes}

                        If all of the rules do not match a window, then this window rule will not apply to that window.
                      '';
                    };
                  }
                  {
                    excludes = list window-match // {
                      description = ''
                        A list of rules to exclude windows.

                        If any of these rules match a window, then this window rule will not apply to that window, even if it matches one of the rules in ${link-opt (subopts options.window-rules).matches}

                        If none of these rules match a window, then this window rule will not be rejected. It will apply to that window if and only if it matches one of the rules in ${link-opt (subopts options.window-rules).matches}
                      '';
                    };
                  }
                  {
                    default-column-width = nullable default-width // {
                      description = ''
                        The default width for new columns.

                        If the final value of this option is null, it default to ${link-opt (subopts options.layout).default-column-width}

                        If the final value option is not null, then its value will take priority over ${link-opt (subopts options.layout).default-column-width} for windows matching this rule.

                        An empty attrset ${fmt.code "{}"} is not the same as null. When this is set to an empty attrset ${fmt.code "{}"}, windows will get to decide their initial width. When set to null, it represents that this particular window rule has no effect on the default width (and it should instead be taken from an earlier rule or the global default).

                      '';
                    };
                    default-window-height = nullable default-height // {
                      description = ''
                        The default height for new floating windows.

                        This does nothing if the window is not floating when it is created.

                        There is no global default option for this in the layout section like for the column width. If the final value of this option is null, then it defaults to the empty attrset ${fmt.code "{}"}.

                        If this is set to an empty attrset ${fmt.code "{}"}, then it effectively "unsets" the default height for this window rule evaluation, as opposed to ${fmt.code "null"} which doesn't change the value at all. Future rules may still set it to a value and unset it again as they wish.

                        If the final value of this option is an empty attrset ${fmt.code "{}"}, then the client gets to decide the height of the window.

                        If the final value of this option is not an empty attrset ${fmt.code "{}"}, and the window spawns as floating, then the window will be created with the specified height.
                      '';
                    };
                    default-column-display =
                      nullable (enum [
                        "normal"
                        "tabbed"
                      ])
                      // {
                        description = ''
                          When this window is inserted into the tiling layout such that a new column is created (e.g. when it is first opened, when it is expelled from an existing column, when it's moved to a new workspace, etc), this setting controls the default display mode of the column.

                          If the final value of this field is null, then the default display mode is taken from ${link-opt (subopts options.layout).default-column-display}.
                        '';
                      };
                  }
                  {
                    open-on-output = nullable types.str // {
                      description = ''
                        The output to open this window on.

                        If final value of this field is an output that exists, the new window will open on that output.

                        If the final value is an output that does not exist, or it is null, then the window opens on the currently focused output.
                      '';
                    };
                    open-on-workspace = nullable types.str // {
                      description = ''
                        The workspace to open this window on.

                        If the final value of this field is a named workspace that exists, the window will open on that workspace.

                        If the final value of this is a named workspace that does not exist, or it is null, the window opens on the currently focused workspace.
                      '';
                    };
                    open-maximized = nullable types.bool // {
                      description = ''
                        Whether to open this window in a maximized column.

                        If the final value of this field is null or false, then the window will not open in a maximized column.

                        If the final value of this field is true, then the window will open in a maximized column.
                      '';
                    };
                    open-fullscreen = nullable types.bool // {
                      description = ''
                        Whether to open this window in fullscreen.

                        If the final value of this field is true, then this window will always be forced to open in fullscreen.

                        If the final value of this field is false, then this window is never allowed to open in fullscreen, even if it requests to do so.

                        If the final value of this field is null, then the client gets to decide if this window will open in fullscreen.
                      '';
                    };
                    open-floating = nullable types.bool // {
                      description = ''
                        Whether to open this window as floating.

                        If the final value of this field is true, then this window will always be forced to open as floating.

                        If the final value of this field is false, then this window is never allowed to open as floating.

                        If the final value of this field is null, then niri will decide whether to open the window as floating or as tiled.
                      '';
                    };

                    open-focused = nullable types.bool // {
                      description = ''
                        Whether to focus this window when it is opened.

                        If the final value of this field is null, then the window will be focused based on several factors:

                        ${fmt.list [
                          "If it provided a valid activation token that hasn't expired, it will be focused."
                          "If the strict activation policy is enabled (not by default), the procedure ends here. It will be focused if and only if the activation token is valid."
                          "Otherwise, if no valid activation token was presented, but the window is a dialog, it will open next to its parent and be focused anyways."
                          "If the window is not a dialog, it will be focused if there is no fullscreen window; we don't want to steal its focus unless a dialog belongs to it."
                        ]}

                        (a dialog here means a toplevel surface that has a non-null parent)

                        If the final value of this field is not null, all of the above is ignored. Whether the window provides an activation token or not, doesn't matter. The window will be focused if and only if this field is true. If it is false, the window will not be focused, even if it provides a valid activation token.
                      '';
                    };
                  }
                  {
                    block-out-from =
                      nullable (enum [
                        "screencast"
                        "screen-capture"
                      ])
                      // {
                        description = window-rule-descriptions.block-out-from;
                      };

                    geometry-corner-radius = geometry-corner-radius-rule // {
                      description = ''
                        The corner radii of the window decorations (border, focus ring, and shadow) in logical pixels.

                        By default, the actual window surface will be unaffected by this.

                        Set ${link-opt (subopts options.window-rules).clip-to-geometry} to true to clip the window to its visual geometry, i.e. apply the corner radius to the window surface itself.
                      '';
                    };

                    clip-to-geometry = nullable types.bool // {
                      description = ''
                        Whether to clip the window to its visual geometry, i.e. whether the corner radius should be applied to the window surface itself or just the decorations.
                      '';
                    };

                    border = border-rule {
                      name = "border";
                      window = "matched window";
                      description = ''
                        See ${link-opt (subopts options.layout).border}.
                      '';
                    };
                    focus-ring = border-rule {
                      name = "focus ring";
                      window = "matched window with focus";
                      description = ''
                        See ${link-opt (subopts options.layout).focus-ring}.
                      '';
                    };

                    tab-indicator =
                      let
                        layout-tab-indicator = subopts (subopts options.layout).tab-indicator;
                      in
                      section' (
                        { options, ... }:
                        {
                          options = make-decoration-options options {
                            urgent.description = ''
                              See ${link-opt layout-tab-indicator.urgent}.
                            '';
                            active.description = ''
                              See ${link-opt layout-tab-indicator.active}.
                            '';
                            inactive.description = ''
                              See ${link-opt layout-tab-indicator.inactive}.
                            '';
                          };
                        }
                      );

                    shadow = shadow-rule;
                    draw-border-with-background = nullable types.bool // {
                      description = ''
                        Whether to draw the focus ring and border with a background.

                        Normally, for windows with server-side decorations, niri will draw an actual border around them, because it knows they will be rectangular.

                        Because client-side decorations can take on arbitrary shapes, most notably including rounded corners, niri cannot really know the "correct" place to put a border, so for such windows it will draw a solid rectangle behind them instead.

                        For most windows, this looks okay. At worst, you have some uneven/jagged borders, instead of a gaping hole in the region outside of the corner radius of the window but inside its bounds.

                        If you wish to make windows sucha s your terminal transparent, and they use CSD, this is very undesirable. Instead of showing your wallpaper, you'll get a solid rectangle.

                        You can set this option per window to override niri's default behaviour, and instruct it to omit the border background for CSD windows. You can also explicitly enable it for SSD windows.
                      '';
                    };
                    opacity = nullable types.float // {
                      description = window-rule-descriptions.opacity;
                    };
                  }
                  (
                    let
                      sizing-info = bound: ''
                        Sets the ${bound} (in logical pixels) that niri will ever ask this window for.

                        Keep in mind that the window itself always has a final say in its size, and may not respect the ${bound} set by this option.
                      '';

                      sizing-opt =
                        bound:
                        nullable types.int
                        // {
                          description = sizing-info bound;
                        };
                    in
                    {
                      min-width = sizing-opt "minimum width";
                      max-width = sizing-opt "maximum width";
                      min-height = sizing-opt "minimum height";
                      max-height = nullable types.int // {
                        description = ''
                          ${sizing-info "maximum height"}

                          Also, note that the maximum height is not taken into account when automatically sizing columns. That is, when a column is created normally, windows in it will be "automatically sized" to fill the vertical space. This algorithm will respect a minimum height, and not make windows any smaller than that, but the max height is only taken into account if it is equal to the min height. In other words, it will only accept a "fixed height" or a "minimum height". In practice, most windows do not set a max size unless it is equal to their min size, so this is usually not a problem without window rules.

                          If you manually change the window heights, then max-height will be taken into account and restrict you from making it any taller, as you'd intuitively expect.
                        '';
                      };
                    }
                  )
                  {
                    baba-is-float = nullable types.bool // {
                      description = ''
                        Makes your window FLOAT up and down, like in the game Baba Is You.

                        Made for April Fools 2025.
                      '';
                    };
                    default-floating-position =
                      nullable (record {
                        x = required float-or-int;
                        y = required float-or-int;
                        relative-to = required (enum [
                          "top-left"
                          "top-right"
                          "bottom-left"
                          "bottom-right"
                          "top"
                          "bottom"
                          "left"
                          "right"
                        ]);
                      })
                      // {
                        description = ''
                          The default position for this window when it enters the floating layout.

                          If a window is created as floating, it will be placed at this position.

                          If a window is created as tiling, then later made floating, it will be placed at this position.

                          If a window has already been placed as floating through one of the above methods, and moved back to the tiling layout, then this option has no effect the next time it enters the floating layout. It will be placed at the same position it was last time.

                          The ${fmt.code "x"} and ${fmt.code "y"} fields are the distances from the edge of the screen to the edge of the window, in logical pixels. The ${fmt.code "relative-to"} field determines which two edges of the window and screen that these distances are measured from.
                        '';
                      };
                  }
                  {
                    variable-refresh-rate = nullable types.bool // {
                      description = ''
                        Takes effect only when the window is on an output with ${link-opt (subopts options.outputs).variable-refresh-rate} set to ${fmt.code ''"on-demand"''}. If the final value of this field is true, then the output will enable variable refresh rate when this window is present on it.
                      '';
                    };
                  }
                  {
                    scroll-factor = nullable float-or-int;
                  }
                  {
                    tiled-state = nullable types.bool;
                  }
                ]
              )
              // {
                description = window-rule-descriptions.top-option;
              };
          }

          {
            layer-rules =
              let
                layer-rule-descriptions = rule-descriptions {
                  surface = "layer surface";
                  surfaces = "layer surfaces";
                  surface-rule = "layer rule";
                  Surface-rules = "Layer rules";

                  self = options.layer-rules;
                  spawn-at-startup = options.spawn-at-startup;

                  example-fields = [
                    ''
                      The ${fmt.code "namespace"} field, when non-null, is a regular expression. It will match a layer surface for which the client has set a namespace that matches the regular expression.
                    ''
                  ];
                };

                layer-match = ordered-record' "match rule" [
                  {
                    namespace = nullable regex // {
                      description = ''
                        A regular expression to match against the namespace of the layer surface.

                        All layer surfaces have a namespace set once at creation. When this rule is non-null, the regex must match the namespace of the layer surface for this rule to match.
                      '';
                    };
                  }
                  {
                    at-startup = nullable types.bool // {
                      description = layer-rule-descriptions.match-at-startup;
                    };
                  }
                ];
              in
              list (
                ordered-record' "layer rule" [
                  {
                    matches = list layer-match // {
                      description = layer-rule-descriptions.match;
                    };
                  }
                  {
                    excludes = list layer-match // {
                      description = layer-rule-descriptions.exclude;
                    };
                  }
                  {
                    block-out-from =
                      nullable (enum [
                        "screencast"
                        "screen-capture"
                      ])
                      // {
                        description = layer-rule-descriptions.block-out-from;
                      };

                    opacity = nullable types.float // {
                      description = layer-rule-descriptions.opacity;
                    };
                  }
                  {
                    shadow = shadow-rule;
                    geometry-corner-radius = geometry-corner-radius-rule // {
                      description = ''
                        The corner radii of the surface decorations (shadow) in logical pixels.
                      '';
                    };
                  }
                  {
                    place-within-backdrop = nullable types.bool // {
                      description = ''
                        Set to ${fmt.code "true"} to place the surface into the backdrop visible in the Overview and between workspaces.
                        This will only work for background layer surfaces that ignore exclusive zones (typical for wallpaper tools). Layers within the backdrop will ignore all input.
                      '';
                    };

                    baba-is-float = nullable types.bool // {
                      description = ''
                        Make your layer surfaces FLOAT up and down.

                        This is a natural extension of the April Fools' 2025 feature.
                      '';
                    };
                  }
                ]
              )
              // {
                description = layer-rule-descriptions.top-option;
              };
          }

          {
            xwayland-satellite =
              section {
                enable = optional types.bool true;
                path = nullable types.str // {
                  description = ''
                    Path to the xwayland-satellite binary.

                    Set it to something like ${fmt.code "lib.getExe pkgs.xwayland-satellite-unstable"}.
                  '';
                };
              }
              // {
                description = ''
                  Xwayland-satellite integration. Requires unstable niri and unstable xwayland-satellite.
                '';
              };
          }

          {
            debug = attrs kdl.types.kdl-args // {
              description = ''
                Debug options for niri.

                ${fmt.code "kdl arguments"} in the type refers to a list of arguments passed to a node under the ${fmt.code "debug"} section. This is a way to pass arbitrary KDL-valid data to niri. See ${link-opt (subopts options.binds).action} for more information on all the ways you can use this.

                Note that for no-argument nodes, there is no special way to define them here. You can't pass them as just a "string" because that makes no sense here. You must pass it an empty array of arguments.

                Here's an example of how to use this:

                ${fmt.nix-code-block ''
                  {
                    ${options.debug} = {
                      disable-cursor-plane = [];
                      render-drm-device = "/dev/dri/renderD129";
                    };
                  }
                ''}

                This option is, just like ${link-opt (subopts options.binds).action}, not verified by the nix module. But, it will be validated by niri before committing the config.

                Additionally, i don't guarantee stability of the debug options. They may change at any time without prior notice, either because of niri changing the available options, or because of me changing this to a more reasonable schema.
              '';
            };
          }
        ];
      }
    );

  module =
    { config, ... }:
    let
      cfg = config.programs.niri;

      inherit (lib) mkOption types;
      inherit (docs.lib) link';
    in
    {
      options.programs.niri = {
        settings = mkOption {
          type = types.nullOr (settings.type-with docs.settings-fmt);
          default = null;
          description = ''
            Nix-native settings for niri.

            By default, when this is null, no config file is generated.

            Beware that setting ${link' "programs.niri.config"} completely overrides everything under this option.
          '';
        };

        config = mkOption {
          type = types.nullOr (types.either types.str kdl.types.kdl-document);
          default = settings.render cfg.settings;
          defaultText = null;
          description = ''
            The niri config file.

            - When this is null, no config file is generated.
            - When this is a string, it is assumed to be the config file contents.
            - When this is kdl document, it is serialized to a string before being used as the config file contents.

            By default, this is a KDL document that reflects the settings in ${link' "programs.niri.settings"}.
          '';
        };

        finalConfig = mkOption {
          type = types.nullOr types.str;
          default =
            if builtins.isString cfg.config then
              cfg.config
            else if cfg.config != null then
              kdl.serialize.nodes cfg.config
            else
              null;
          readOnly = true;
          defaultText = null;
          description = ''
            The final niri config file contents.

            This is a string that reflects the document stored in ${link' "programs.niri.config"}.

            It is exposed mainly for debugging purposes, such as when you need to inspect how a certain option affects the resulting config file.
          '';
        };
      };
    };
  fake-docs =
    {
      fmt-date,
      fmt-time,
    }:
    {
      imports = [ settings.module ];

      options._ =
        let
          inherit (docs.lib)
            section
            header
            pkg-header
            module-doc
            fake-option
            pkg-link
            nixpkgs-link
            link-niri-release
            link-niri-commit
            link-stylix-opt
            link'
            ;

          pkg-output =
            name: desc:
            fake-option (pkg-header name) ''
              ${desc}

              To access this package under `pkgs.${name}`, you should use ${link' "overlays.niri"}.
            '';

          enable-option = fake-option "programs.niri.enable" ''
            - type: `boolean`
            - default: `false`

            Whether to install and enable niri.

            This also enables the necessary system components for niri to function properly, such as desktop portals and polkit.
          '';

          package-option = fake-option "programs.niri.package" ''
            - type: `package`
            - default: ${pkg-link "niri-stable"}

            The package that niri will use.

            You may wish to set it to the following values:

            - ${nixpkgs-link "niri"}
            - ${pkg-link "niri-stable"}
            - ${pkg-link "niri-unstable"}
          '';

          patches =
            pkg:
            builtins.concatMap (
              patch:
              let
                m = lib.strings.match "${lib.escapeRegex "https://github.com/YaLTeR/niri/commit/"}([0-9a-f]{40})${lib.escapeRegex ".patch"}" patch.url;
              in
              if m != null then
                [
                  {
                    rev = builtins.head m;
                    inherit (patch) url;
                  }
                ]
              else
                [ ]
            ) (pkg.patches or [ ]);

          stable-patches = patches inputs.self.packages.x86_64-linux.niri-stable;
        in
        {
          a.nonmodules = {
            _ = header "Packages provided by this flake";

            a.packages = {
              _ = fake-option (pkg-header "<name>") ''
                (where `<system>` is one of: `x86_64-linux`, `aarch64-linux`)

                > [!important]
                > Packages for `aarch64-linux` are untested. They might work, but i can't guarantee it.

                You should preferably not be using these outputs directly. Instead, you should use ${link' "overlays.niri"}.
              '';
              niri-stable = pkg-output "niri-stable" ''
                The latest stable tagged version of niri, along with potential patches.

                Currently, this is release ${link-niri-release inputs.self.packages.x86_64-linux.niri-stable.version}${
                  if stable-patches != [ ] then " plus the following patches:" else " with no additional patches."
                }

                ${builtins.concatStringsSep "\n" (
                  map (
                    {
                      rev,
                      url,
                    }:
                    "- [`${rev}`](${lib.removeSuffix ".patch" url})"
                  ) stable-patches
                )}
              '';
              niri-unstable = pkg-output "niri-unstable" ''
                The latest commit to the development branch of niri.

                Currently, this is exactly commit ${
                  link-niri-commit { inherit (inputs.niri-unstable) shortRev rev; }
                } which was authored on `${fmt-date inputs.niri-unstable.lastModifiedDate} ${fmt-time inputs.niri-unstable.lastModifiedDate}`.

                > [!warning]
                > `niri-unstable` is not a released version, there are no stability guarantees, and it may break your workflow from itme to time.
                >
                > The specific package provided by this flake is automatically updated without any testing. The only guarantee is that it builds.
              '';
            };

            b.overlay = fake-option "overlays.niri" ''
              A nixpkgs overlay that provides `niri-stable` and `niri-unstable`.

              It is recommended to use this overlay over directly accessing the outputs. This is because the overlay ensures that the dependencies match your system's nixpkgs version, which is most important for `mesa`. If `mesa` doesn't match, niri will be unable to run in a TTY.

              You can enable this overlay by adding this line to your configuration:

              ```nix
              {
                nixpkgs.overlays = [ niri.overlays.niri ];
              }
              ```

              You can then access the packages via `pkgs.niri-stable` and `pkgs.niri-unstable` as if they were part of nixpkgs.
            '';
          };
          b.modules = {
            a.nixos =
              module-doc "nixosModules.niri"
                ''
                  The full NixOS module for niri.

                  By default, this module does the following:

                  - It will enable a binary cache managed by me, sodiboo. This helps you avoid building niri from source, which can take a long time in release mode.
                  - If you have home-manager installed in your NixOS configuration (rather than as a standalone program), this module will automatically import ${link' "homeModules.config"} for all users and give it the correct package to use for validation.
                  - If you have home-manager and stylix installed in your NixOS configuration, this module will also automatically import ${link' "homeModules.stylix"} for all users.
                ''
                {
                  enable = enable-option;
                  package = package-option;
                  z.cache = fake-option "niri-flake.cache.enable" ''
                    - type: `boolean`
                    - default: `true`

                    Whether or not to enable the binary cache [`niri.cachix.org`](https://niri.cachix.org/) in your nix configuration.

                    Using a binary cache can save you time, by avoiding redundant rebuilds.

                    This cache is managed by me, sodiboo, and i use GitHub Actions to automaticaly upload builds of ${pkg-link "niri-stable"} and ${pkg-link "niri-unstable"} (for nixpkgs unstable and stable). By using it, you are trusting me to not upload malicious builds, and as such you may disable it.

                    If you do not wish to use this cache, then you may wish to set ${link' "programs.niri.package"} to ${nixpkgs-link "niri"}, in order to take advantage of the NixOS cache.
                  '';
                };

            b.home =
              module-doc "homeModules.niri"
                ''
                  The full home-manager module for niri.

                  By default, this module does nothing. It will import ${link' "homeModules.config"}, which provides many configuration options, and it also provides some options to install niri.
                ''
                {
                  enable = enable-option;
                  package = package-option;
                };

            c.stylix =
              module-doc "homeModules.stylix"
                ''
                  Stylix integration. It provides a target to enable niri.

                  This module is automatically imported if you have home-manager and stylix installed in your NixOS configuration.

                  If you use standalone home-manager, you must import it manually if you wish to use stylix with niri. (since it can't be automatically imported in that case)
                ''
                {
                  target = fake-option "stylix.targets.niri.enable" ''
                    - type: `boolean`
                    - default: ${link-stylix-opt "stylix.autoEnable"}

                    Whether to style niri according to your stylix config.

                    Note that enabling this stylix target will cause a config file to be generated, even if you don't set ${link' "programs.niri.config"}.

                    This also means that, with stylix installed, having everything set to default *does* generate an actual config file.
                  '';
                };
          };

          z.pre-config =
            module-doc "homeModules.config"
              ''
                Configuration options for niri. This module is automatically imported by ${link' "nixosModules.niri"} and ${link' "homeModules.niri"}.

                By default, this module does nothing. It provides many configuration options for niri, such as keybindings, animations, and window rules.

                When its options are set, it generates `$XDG_CONFIG_HOME/niri/config.kdl` for the user. This is the default path for niri's config file.

                It will also validate the config file with the `niri validate` command before committing that config. This ensures that the config file is always valid, else your system will fail to build. When using ${link' "programs.niri.settings"} to configure niri, that's not necessary, because it will always generate a valid config file. But, if you set ${link' "programs.niri.config"} directly, then this is very useful.
              ''
              {
                a.variant = section ''
                  ## type: `variant of`

                  Some of the options below make use of a "variant" type.

                  This is a type that behaves similarly to a submodule, except you can only set *one* of its suboptions.

                  An example of this usage is in ${link' "programs.niri.settings.animations.<name>"}, where each event can have either an easing animation or a spring animation. \
                  You cannot set parameters for both, so `variant` is used here.
                '';

                b.package = fake-option "programs.niri.package" ''
                  - type: `package`
                  - default: ${pkg-link "niri-stable"}

                  The `niri` package that the config is validated against. This cannot be modified if you set the identically-named option in ${link' "nixosModules.niri"} or ${link' "homeModules.niri"}.
                '';
              };
        };
    };

  render =
    cfg:
    if cfg == null then
      null
    else
      let
        normalize-nodes = nodes: lib.remove null (lib.flatten nodes);

        node =
          name: args: children:
          kdl.node name args (normalize-nodes children);
        plain = name: node name [ ];
        leaf = name: args: node name args [ ];
        flag = name: node name [ ] [ ];

        optional-node = cond: v: if cond then v else null;

        nullable =
          f: name: value:
          optional-node (value != null) (f name value);
        flag' = name: lib.flip optional-node (flag name);
        plain' =
          name: children:
          optional-node (builtins.any (v: v != null) (lib.flatten children)) (plain name children);

        map' =
          node: f: name: val:
          node name (f val);

        each = list: f: map f list;
        each' = attrs: each (builtins.attrValues attrs);

        toggle =
          disabled: cfg: contents:
          if cfg.enable then contents else flag disabled;

        toggle' = disabled: cfg: contents: [
          (flag' disabled (cfg.enable == false))
          contents
        ];

        pointer = cfg: [
          (flag' "natural-scroll" cfg.natural-scroll)
          (flag' "middle-emulation" cfg.middle-emulation)
          (nullable leaf "accel-speed" cfg.accel-speed)
          (nullable leaf "accel-profile" cfg.accel-profile)
          (nullable leaf "scroll-button" cfg.scroll-button)
          (flag' "scroll-button-lock" cfg.scroll-button-lock)
          (nullable leaf "scroll-method" cfg.scroll-method)
        ];

        pointer-tablet =
          cfg: inner:
          (toggle "off" cfg [
            (flag' "left-handed" cfg.left-handed)
            inner
          ]);

        touchy = cfg: [
          (nullable leaf "map-to-output" cfg.map-to-output)
        ];

        tablet =
          cfg:
          touchy cfg
          ++ [
            (nullable leaf "calibration-matrix" cfg.calibration-matrix)
          ];

        touch =
          cfg:
          (toggle "off" cfg [
            (touchy cfg)
          ]);

        gradient' =
          name: cfg:
          leaf name (
            lib.concatMapAttrs (
              name: value:
              lib.optionalAttrs (value != null) {
                ${lib.removeSuffix "'" name} = value;
              }
            ) cfg
          );

        borderish = map' plain (
          cfg:
          toggle "off" cfg [
            (leaf "width" cfg.width)
            (nullable leaf "urgent-color" cfg.urgent.color or null)
            (nullable gradient' "urgent-gradient" cfg.urgent.gradient or null)
            (nullable leaf "active-color" cfg.active.color or null)
            (nullable gradient' "active-gradient" cfg.active.gradient or null)
            (nullable leaf "inactive-color" cfg.inactive.color or null)
            (nullable gradient' "inactive-gradient" cfg.inactive.gradient or null)
          ]
        );

        shadow = map' (nullable plain) (
          cfg:
          optional-node (cfg.enable) [
            (flag "on")
            (leaf "offset" cfg.offset)
            (leaf "softness" cfg.softness)
            (leaf "spread" cfg.spread)

            (leaf "draw-behind-window" cfg.draw-behind-window)
            (leaf "color" cfg.color)
            (nullable leaf "inactive-color" cfg.inactive-color)
          ]
        );

        tab-indicator = map' plain (
          cfg:
          toggle "off" cfg [
            (flag' "hide-when-single-tab" cfg.hide-when-single-tab)
            (flag' "place-within-column" cfg.place-within-column)
            (leaf "gap" cfg.gap)
            (leaf "width" cfg.width)
            (leaf "length" cfg.length)
            (leaf "position" cfg.position)
            (leaf "gaps-between-tabs" cfg.gaps-between-tabs)
            (leaf "corner-radius" cfg.corner-radius)
            (nullable leaf "urgent-color" cfg.urgent.color or null)
            (nullable gradient' "urgent-gradient" cfg.urgent.gradient or null)
            (nullable leaf "active-color" cfg.active.color or null)
            (nullable gradient' "active-gradient" cfg.active.gradient or null)
            (nullable leaf "inactive-color" cfg.inactive.color or null)
            (nullable gradient' "inactive-gradient" cfg.inactive.gradient or null)
          ]
        );

        preset-sizes = map' (nullable plain) (
          cfg: if cfg == [ ] then null else map (lib.mapAttrsToList leaf) (lib.toList cfg)
        );

        animation = map' plain' (
          cfg:
          toggle "off" cfg [
            (optional-node (cfg.kind ? easing) [
              (leaf "duration-ms" cfg.kind.easing.duration-ms)
              (leaf "curve" ([ cfg.kind.easing.curve ] ++ cfg.kind.easing.curve-args))
            ])
            (nullable leaf "spring" cfg.kind.spring or null)
            (nullable leaf "custom-shader" cfg.custom-shader or null)
          ]
        );

        opt-props = lib.filterAttrs (lib.const (value: value != null));
        border-rule = map' plain' (cfg: [
          (flag' "on" (cfg.enable == true))
          (flag' "off" (cfg.enable == false))
          (nullable leaf "width" cfg.width)
          (nullable leaf "urgent-color" cfg.urgent.color or null)
          (nullable gradient' "urgent-gradient" cfg.urgent.gradient or null)
          (nullable leaf "active-color" cfg.active.color or null)
          (nullable gradient' "active-gradient" cfg.active.gradient or null)
          (nullable leaf "inactive-color" cfg.inactive.color or null)
          (nullable gradient' "inactive-gradient" cfg.inactive.gradient or null)
        ]);

        shadow-rule = map' plain' (cfg: [
          (flag' "on" (cfg.enable == true))
          (flag' "off" (cfg.enable == false))
          (nullable leaf "offset" cfg.offset)
          (nullable leaf "softness" cfg.softness)
          (nullable leaf "spread" cfg.spread)
          (nullable leaf "draw-behind-window" cfg.draw-behind-window)
          (nullable leaf "color" cfg.color)
          (nullable leaf "inactive-color" cfg.inactive-color)
        ]);

        tab-indicator-rule = map' plain' (cfg: [
          (nullable leaf "urgent-color" cfg.urgent.color or null)
          (nullable gradient' "urgent-gradient" cfg.urgent.gradient or null)
          (nullable leaf "active-color" cfg.active.color or null)
          (nullable gradient' "active-gradient" cfg.active.gradient or null)
          (nullable leaf "inactive-color" cfg.inactive.color or null)
          (nullable gradient' "inactive-gradient" cfg.inactive.gradient or null)
        ]);

        corner-radius = cfg: [
          cfg.top-left
          cfg.top-right
          cfg.bottom-right
          cfg.bottom-left
        ];

        transform =
          cfg:
          let
            rotation = toString cfg.rotation;
            basic = if cfg.flipped then "flipped-${rotation}" else "${rotation}";
            replacement."0" = "normal";
            replacement."flipped-0" = "flipped";
          in
          replacement.${basic} or basic;

        mode =
          cfg:
          let
            cfg' = builtins.mapAttrs (lib.const toString) cfg;
          in
          if cfg.refresh == null then
            "${cfg'.width}x${cfg'.height}"
          else
            "${cfg'.width}x${cfg'.height}@${cfg'.refresh}";

        bind =
          name: cfg:
          let
            bool-props-with-defaults =
              cfg: defaults:
              opt-props (
                builtins.mapAttrs (
                  name: value: (if (defaults ? ${name}) && (value != defaults.${name}) then value else null)
                ) cfg
              );
          in
          node name
            (
              opt-props {
                inherit (cfg) cooldown-ms;
              }
              // bool-props-with-defaults cfg {
                repeat = true;
                allow-when-locked = false;
                allow-inhibiting = true;
              }
              // lib.optionalAttrs (cfg.hotkey-overlay.hidden or false) {
                hotkey-overlay-title = null;
              }
              // opt-props {
                hotkey-overlay-title = cfg.hotkey-overlay.title or null;
              }
            )
            [
              (lib.mapAttrsToList leaf cfg.action)
            ];

        pointer-tablet' =
          ext: name: cfg:
          plain' name (pointer-tablet cfg (ext cfg));
        pointer' = pointer-tablet' pointer;
        tablet' = pointer-tablet' tablet;
      in
      normalize-nodes [
        (plain "input" [
          (plain "keyboard" [
            (plain "xkb" [
              (nullable leaf "file" cfg.input.keyboard.xkb.file)
              (leaf "layout" cfg.input.keyboard.xkb.layout)
              (leaf "model" cfg.input.keyboard.xkb.model)
              (leaf "rules" cfg.input.keyboard.xkb.rules)
              (leaf "variant" cfg.input.keyboard.xkb.variant)
              (nullable leaf "options" cfg.input.keyboard.xkb.options)
            ])
            (leaf "repeat-delay" cfg.input.keyboard.repeat-delay)
            (leaf "repeat-rate" cfg.input.keyboard.repeat-rate)
            (leaf "track-layout" cfg.input.keyboard.track-layout)
            (flag' "numlock" cfg.input.keyboard.numlock)
          ])
          (plain' "touchpad" (
            pointer-tablet cfg.input.touchpad [
              (flag' "tap" cfg.input.touchpad.tap)
              (flag' "dwt" cfg.input.touchpad.dwt)
              (flag' "dwtp" cfg.input.touchpad.dwtp)
              (nullable leaf "drag" cfg.input.touchpad.drag)
              (flag' "drag-lock" cfg.input.touchpad.drag-lock)
              (flag' "disabled-on-external-mouse" cfg.input.touchpad.disabled-on-external-mouse)
              (pointer cfg.input.touchpad)
              (nullable leaf "click-method" cfg.input.touchpad.click-method)
              (nullable leaf "tap-button-map" cfg.input.touchpad.tap-button-map)
              (nullable leaf "scroll-factor" cfg.input.touchpad.scroll-factor)
            ]
          ))
          (plain' "mouse" (
            pointer-tablet cfg.input.mouse [
              (pointer cfg.input.mouse)
              (nullable leaf "scroll-factor" cfg.input.mouse.scroll-factor)
            ]
          ))
          (pointer' "trackpoint" cfg.input.trackpoint)
          (pointer' "trackball" cfg.input.trackball)
          (tablet' "tablet" cfg.input.tablet)
          (plain' "touch" (touch cfg.input.touch))
          (optional-node cfg.input.warp-mouse-to-focus.enable (
            leaf "warp-mouse-to-focus" (
              lib.optionalAttrs (cfg.input.warp-mouse-to-focus.mode != null) {
                inherit (cfg.input.warp-mouse-to-focus) mode;
              }
            )
          ))
          (optional-node cfg.input.focus-follows-mouse.enable (
            leaf "focus-follows-mouse" (
              lib.optionalAttrs (cfg.input.focus-follows-mouse.max-scroll-amount != null) {
                inherit (cfg.input.focus-follows-mouse) max-scroll-amount;
              }
            )
          ))
          (flag' "workspace-auto-back-and-forth" cfg.input.workspace-auto-back-and-forth)
          (toggle "disable-power-key-handling" cfg.input.power-key-handling [ ])
          (nullable leaf "mod-key" cfg.input.mod-key)
          (nullable leaf "mod-key-nested" cfg.input.mod-key-nested)
        ])

        (each' cfg.outputs (cfg: [
          (node "output" cfg.name [
            (toggle' "off" cfg [
              (nullable leaf "backdrop-color" cfg.backdrop-color)
              (nullable leaf "background-color" cfg.background-color)
              (nullable leaf "scale" cfg.scale)
              (flag' "focus-at-startup" cfg.focus-at-startup)
              (map' leaf transform "transform" cfg.transform)
              (nullable leaf "position" cfg.position)
              (nullable (map' leaf mode) "mode" cfg.mode)
              (optional-node (cfg.variable-refresh-rate != false) (
                leaf "variable-refresh-rate" { on-demand = cfg.variable-refresh-rate == "on-demand"; }
              ))
            ])
          ])
        ]))

        (leaf "screenshot-path" cfg.screenshot-path)
        (flag' "prefer-no-csd" cfg.prefer-no-csd)

        (plain' "overview" [
          (nullable leaf "zoom" cfg.overview.zoom)
          (nullable leaf "backdrop-color" cfg.overview.backdrop-color)
          (plain' "workspace-shadow" [
            (toggle "off" cfg.overview.workspace-shadow [
              (nullable leaf "offset" cfg.overview.workspace-shadow.offset)
              (nullable leaf "softness" cfg.overview.workspace-shadow.softness)
              (nullable leaf "spread" cfg.overview.workspace-shadow.spread)
              (nullable leaf "color" cfg.overview.workspace-shadow.color)
            ])
          ])
        ])

        (plain "layout" [
          (leaf "gaps" cfg.layout.gaps)
          (plain "struts" [
            (leaf "left" cfg.layout.struts.left)
            (leaf "right" cfg.layout.struts.right)
            (leaf "top" cfg.layout.struts.top)
            (leaf "bottom" cfg.layout.struts.bottom)
          ])
          (borderish "focus-ring" cfg.layout.focus-ring)
          (borderish "border" cfg.layout.border)
          (nullable leaf "background-color" cfg.layout.background-color)
          (shadow "shadow" cfg.layout.shadow)
          (nullable tab-indicator "tab-indicator" cfg.layout.tab-indicator)
          (plain' "insert-hint" [
            (toggle "off" cfg.layout.insert-hint [
              (nullable leaf "color" cfg.layout.insert-hint.display.color or null)
              (nullable gradient' "gradient" cfg.layout.insert-hint.display.gradient or null)
            ])
          ])
          (preset-sizes "default-column-width" cfg.layout.default-column-width)
          (preset-sizes "preset-column-widths" cfg.layout.preset-column-widths)
          (preset-sizes "preset-window-heights" cfg.layout.preset-window-heights)
          (leaf "center-focused-column" cfg.layout.center-focused-column)
          (optional-node (cfg.layout.default-column-display != "normal") (
            leaf "default-column-display" cfg.layout.default-column-display
          ))
          (flag' "always-center-single-column" cfg.layout.always-center-single-column)
          (flag' "empty-workspace-above-first" cfg.layout.empty-workspace-above-first)
        ])

        (plain "cursor" [
          (leaf "xcursor-theme" cfg.cursor.theme)
          (leaf "xcursor-size" cfg.cursor.size)
          (flag' "hide-when-typing" cfg.cursor.hide-when-typing)
          (nullable leaf "hide-after-inactive-ms" cfg.cursor.hide-after-inactive-ms)
        ])

        (plain' "hotkey-overlay" [
          (flag' "skip-at-startup" cfg.hotkey-overlay.skip-at-startup)
          (flag' "hide-not-bound" cfg.hotkey-overlay.hide-not-bound)
        ])

        (plain' "config-notification" [
          (flag' "disable-failed" cfg.config-notification.disable-failed)
        ])

        (plain' "clipboard" [
          (flag' "disable-primary" cfg.clipboard.disable-primary)
        ])

        (plain' "environment" (lib.mapAttrsToList leaf cfg.environment))
        (plain' "binds" (lib.mapAttrsToList bind cfg.binds))

        (plain' "switch-events" (
          lib.mapAttrsToList (nullable (
            map' plain (cfg: [
              (lib.mapAttrsToList leaf cfg.action)
            ])
          )) cfg.switch-events
        ))

        (each' cfg.workspaces (cfg: [
          (node "workspace" cfg.name [
            (nullable leaf "open-on-output" cfg.open-on-output)
          ])
        ]))

        (each cfg.spawn-at-startup (cfg: [
          (nullable leaf "spawn-at-startup" cfg.argv or null)
          (nullable leaf "spawn-sh-at-startup" cfg.sh or null)
          (nullable leaf "spawn-at-startup" cfg.command or null)
        ]))

        (each cfg.window-rules (cfg: [
          (plain "window-rule" [
            (map (leaf "match") (map opt-props cfg.matches))
            (map (leaf "exclude") (map opt-props cfg.excludes))
            (nullable preset-sizes "default-column-width" cfg.default-column-width)
            (nullable preset-sizes "default-window-height" cfg.default-window-height)
            (nullable leaf "default-column-display" cfg.default-column-display)
            (nullable leaf "open-on-output" cfg.open-on-output)
            (nullable leaf "open-on-workspace" cfg.open-on-workspace)
            (nullable leaf "open-maximized" cfg.open-maximized)
            (nullable leaf "open-fullscreen" cfg.open-fullscreen)
            (nullable leaf "open-floating" cfg.open-floating)
            (nullable leaf "open-focused" cfg.open-focused)
            (nullable leaf "draw-border-with-background" cfg.draw-border-with-background)
            (nullable (map' leaf corner-radius) "geometry-corner-radius" cfg.geometry-corner-radius)
            (nullable leaf "clip-to-geometry" cfg.clip-to-geometry)
            (border-rule "border" cfg.border)
            (border-rule "focus-ring" cfg.focus-ring)
            (shadow-rule "shadow" cfg.shadow)
            (tab-indicator-rule "tab-indicator" cfg.tab-indicator)
            (nullable leaf "opacity" cfg.opacity)
            (nullable leaf "min-width" cfg.min-width)
            (nullable leaf "max-width" cfg.max-width)
            (nullable leaf "min-height" cfg.min-height)
            (nullable leaf "max-height" cfg.max-height)
            (nullable leaf "block-out-from" cfg.block-out-from)
            (nullable leaf "baba-is-float" cfg.baba-is-float)
            (nullable leaf "default-floating-position" cfg.default-floating-position)
            (nullable leaf "variable-refresh-rate" cfg.variable-refresh-rate)
            (nullable leaf "scroll-factor" cfg.scroll-factor)
            (nullable leaf "tiled-state" cfg.tiled-state)
          ])
        ]))
        (each cfg.layer-rules (cfg: [
          (plain "layer-rule" [
            (map (leaf "match") (map opt-props cfg.matches))
            (map (leaf "exclude") (map opt-props cfg.excludes))
            (nullable leaf "opacity" cfg.opacity)
            (nullable leaf "block-out-from" cfg.block-out-from)
            (shadow-rule "shadow" cfg.shadow)
            (nullable (map' leaf corner-radius) "geometry-corner-radius" cfg.geometry-corner-radius)
            (nullable leaf "place-within-backdrop" cfg.place-within-backdrop)
            (nullable leaf "baba-is-float" cfg.baba-is-float)
          ])
        ]))

        (plain' "gestures" [
          (plain' "dnd-edge-view-scroll" [
            (nullable leaf "trigger-width" cfg.gestures.dnd-edge-view-scroll.trigger-width)
            (nullable leaf "delay-ms" cfg.gestures.dnd-edge-view-scroll.delay-ms)
            (nullable leaf "max-speed" cfg.gestures.dnd-edge-view-scroll.max-speed)
          ])
          (plain' "dnd-edge-workspace-switch" [
            (nullable leaf "trigger-height" cfg.gestures.dnd-edge-workspace-switch.trigger-height)
            (nullable leaf "delay-ms" cfg.gestures.dnd-edge-workspace-switch.delay-ms)
            (nullable leaf "max-speed" cfg.gestures.dnd-edge-workspace-switch.max-speed)
          ])
          (plain' "hot-corners" (toggle "off" cfg.gestures.hot-corners [ ]))
        ])

        (plain' "animations" [
          (toggle "off" cfg.animations [
            (nullable leaf "slowdown" cfg.animations.slowdown)
            (map (name: animation name cfg.animations.${name}) cfg.animations.all-anims)
          ])
        ])

        (plain' "xwayland-satellite" [
          (toggle "off" cfg.xwayland-satellite [
            (nullable leaf "path" cfg.xwayland-satellite.path)
          ])
        ])

        (map' plain' (lib.mapAttrsToList leaf) "debug" cfg.debug)
      ];
}
</file>

<file path="shell.nix">
{
  flake ? builtins.getFlake (toString ./.),
  system ? builtins.currentSystem,
}:
let
  pkgs = flake.inputs.nixpkgs.legacyPackages.${system};
in
pkgs.mkShell {
  packages = with pkgs; [
    flake.formatter.${system}
    just
    fish
    fd
    entr
    moreutils
  ];

  shellHook = ''
    just hook 2>/dev/null
  '';
}
</file>

<file path="stylix.nix">
_:
{
  lib,
  config,
  ...
}:
let
  inherit (lib) mkDefault mkIf;
in
{
  options.stylix.targets.niri.enable = config.lib.stylix.mkEnableTarget "niri" true;

  config = mkIf (config.stylix.enable && config.stylix.targets.niri.enable) {
    programs.niri.settings = {
      cursor = mkIf (config.stylix.cursor != null) {
        size = mkDefault config.stylix.cursor.size;
        theme = mkDefault config.stylix.cursor.name;
      };
      layout.focus-ring.enable = mkDefault false;
      layout.border = with config.lib.stylix.colors.withHashtag; {
        enable = mkDefault true;
        active = mkDefault { color = base0D; };
        inactive = mkDefault { color = base03; };
      };
    };
  };
}
</file>

</files>
